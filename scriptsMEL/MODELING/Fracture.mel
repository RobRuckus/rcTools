/*
	Written By Brian Keffer
	email brian@bk3d.com
	This script breaks an object up into chunks using boolean or polycut
	Find the scripts directory "internalVar -usd" 																																														  //
	main procedure	         "Fracture" "Fracture_UI"																																													  //
*/

//global variables
string $Preview_Plane[];
string $NoiseModifier[];


////////////////////////////////////////////////////////////////////////////////////////  Testing  ///////////////////////////////////////////////////////////////////////////////////////////
//																																															//
//																																															//
//																																															//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////Test Fracture Mesh
global proc Test_Fracture_Mesh()
{
	$Selected_Obj = `ls -sl -fl -l`;
	string $Error_Array[] = {};
	ConvertSelectionToFaces;
	string $Chunk_Faces[] = `ls -sl -fl`;
	select -r $Chunk_Faces[0];
	polyConvertToShell;
	$Face_Shell = `ls -sl -fl`;
		if (`size $Chunk_Faces` != `size $Face_Shell`)
			{
				stringArrayInsertAtIndex(0, $Error_Array, "object has multiple face shells");
            }

	$Open_edges = BK_Find_Open_Edges();
	if (`size $Open_edges` > 0)
		{
			stringArrayInsertAtIndex(0, $Error_Array, "object has open edges");
			select $Open_edges;
		}



	if (`size $Error_Array` > 0)
		{
			confirmDialog -message ($Error_Array[0] + ", " + $Error_Array[1]);
			print $Error_Array;
        }

	else
	{
		select $Selected_Obj;
		confirmDialog -message "Your Mesh is OK for fracturing";
    }


}

/////////////////////////////////////////////////////////////////////////////////Test Locators
global proc Test_Overlapping_Locators()
{
	select -add "Voronoi_Fracture_Locator*";
	select -d "*Shape*";//deselect shapes
	string $Locators[] = `ls -sl -fl`;
	float $CenterA[];
	float $CenterB[];
	string $Overlapping_Locators[] ={};

	for ($a = 0; $a < `size $Locators`; $a++)
			{
				$CenterA = `objectCenter $Locators[$a]`;
				for ($b = 0;

				$b < `size $Locators`; $b++)
				{
					if($a != $b)
					{

                    $CenterB = `objectCenter $Locators[$b]`;
					if ($CenterA[0] == $CenterB[0] && $CenterA[1] == $CenterB[1] && $CenterA[2] == $CenterB[2])
							{
								$Locator_Overlap = 1;
								stringArrayInsertAtIndex(0, $Overlapping_Locators,  ("Locators overlap " + $Locators[$a] + " and "+ $Locators[$b]));
                            }//end if

                    }//end if
                }//end for b
            }//end for a

	select -d $Locators;
	if (`size $Overlapping_Locators` > 0)
	{
		confirmDialog -message "There are overlapping locators";
		select $Overlapping_Locators;
		print $Overlapping_Locators;
    }
	else
		{
			confirmDialog -message "There Are no Overlapping Locators";
        }
}//end proc


////////////////////////////////////////////////////////////////////////////////////////  Preview  ///////////////////////////////////////////////////////////////////////////////////////////
//																																															//
//																																															//
//																																															//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////preview Fracture Plane
//
global proc Preview_FracturePlane()
{
	constructionHistory -toggle true;
	global string $Preview_Plane[];
	global string $NoiseModifier[];
	$UP = `upAxis -q -axis`;
	float $Rand_Rot = `intSliderGrp -q -value FF_Rot`;
	int $Cuts =       `intSliderGrp -q -value FF_Cuts`;
	//$Preview_Toggle = `checkBox -q -v cb_Fracture_Plane`;
	$ShowPreview = `checkBox -q -v cb_Fracture_Plane`;

	//enable and disable preview cutting plane checkbox
	if ($ShowPreview == 1)
		{
			checkBox -e -en 1 cb_Fracture_ForcePlane;
		}

	if ($ShowPreview == 0)
		{
			checkBox -e -en 0 cb_Fracture_ForcePlane;
			checkBox -e -v 0 cb_Fracture_ForcePlane;
		}

	$Selected_Obj = `ls -sl -fl`;
		if (`objExists 	"Fracture_Preview_Plane*"`)
			{
				delete "Fracture_Preview_Plane*";
			}

	if ($ShowPreview == 1)
	{
		$Bias_percent = `intSliderGrp -q -v Bias_percent`;
		float $Obj_Center[] = `objectCenter $Selected_Obj[0]`;
		float $Obj_Bounds[] = `polyEvaluate -b $Selected_Obj`;
		float $X_Bounds = ($Obj_Bounds[1] - $Obj_Bounds[0]);
		float $Y_Bounds = ($Obj_Bounds[3] - $Obj_Bounds[2]);
		float $Z_Bounds = ($Obj_Bounds[5] - $Obj_Bounds[4]);

		float $Adjusted_X = ($Obj_Bounds[0] + ($X_Bounds * (.01 * 50)));
		float $Adjusted_Y = ($Obj_Bounds[2] + ($Y_Bounds * (.01 * 50)));
		float $Adjusted_Z = ($Obj_Bounds[4] + ($Z_Bounds * (.01 * 50)));
		$Obj_Center = {$Adjusted_X , $Adjusted_Y, $Adjusted_Z};

		//get the longest bounds
		float $Longest_Bounds = $X_Bounds;

		if ($X_Bounds > $Y_Bounds && $X_Bounds > $Z_Bounds)
			{
				$Longest_Bounds = $X_Bounds;
			}

		if ($Y_Bounds > $X_Bounds && $Y_Bounds > $Z_Bounds)
			{
				$Longest_Bounds = $Y_Bounds;
			}
		if ($Z_Bounds > $X_Bounds && $Z_Bounds > $Y_Bounds)
			{
				$Longest_Bounds = $Z_Bounds;
			}

		floatSliderGrp -e -maxValue ($Longest_Bounds * 2) -fieldMaxValue ($Longest_Bounds * 2) FF_Face_Size;
		floatSliderGrp -e -maxValue ($Longest_Bounds / 2) -fieldMaxValue ($Longest_Bounds / 2) FF_Noise;// set max value of noise size
		float $Face_Size = `floatSliderGrp -q -value FF_Face_Size`;//set max value of face size
		float $Noise_Amount =`floatSliderGrp -q -value FF_Noise`;

		int $Divisions = ((($Longest_Bounds * 2) / $Face_Size) - 1);//Calculate divisions

		$Preview_Plane =`polyPlane -name "Fracture_Preview_Plane" -ch on -o on -w ($Longest_Bounds * 2)  -h ($Longest_Bounds * 2) -sw $Divisions -sh $Divisions -cuv 2 `;
		//setAttr Fracture_Preview_PlaneShape.backfaceCulling 1;
		//$Noise_Percent = (($Longest_Bounds/2) * $Noise_Amount * .01);
		$NoiseModifier = `polyMoveVertex -constructionHistory 1 -random 1`;
		setAttr ($NoiseModifier[0] + ".localTranslate") -type double3 0 0 $Noise_Amount ;
		//Center Pivot and move back to Center of Object
		$Plane_Location = `xform -q -piv $Preview_Plane`;
		xform -cp $Preview_Plane;
		move -ws -rpr $Obj_Center[0] $Obj_Center[1] $Obj_Center[2] $Preview_Plane;
		//ToggleBackfaceGeometry;
		//move -rpr -ws $Adjusted_X $Obj_Center[1] $Obj_Center[2] $Preview_Plane;
		//rotate 0 0 90 $Preview_Plane;
		select $Selected_Obj;
	}//end if
}//end proc


/////////////////////////////////////////////////////////////////////////////////////////preview Voronoi Particles
//
global proc string[] Preview_Voronoi_Particles()
{
	//checkBox -e -en 1 cb_Fracture_ForceLocators;
	$Iterations = `intSliderGrp -q -v FF_Cuts`;
	$Stop_Frame = `intSliderGrp -q -v Stop_Frame`;
	$Locator_Scale = `floatSliderGrp  -q -v Locator_Scale`;
	$Selection = `ls -sl -fl`;
	$Mesh = $Selection[0];
	//select -d $Mesh;
	progressBar -edit -pr 0 Fracture_progress;//reset progress bar to 0
	$Chunk_Name = `textField -q -tx TF_Fracture_Chunk_Name`;
	$Preview_Locators = `checkBox -q -value cb_Generate_Particles`;
	string $Locators[];

	if (`objExists "Voronoi_Fracture_Locator*"` == 1)
    {
		delete "Voronoi_Fracture_Locator*";
    }


	if ($Preview_Locators == 1 && (`objExists $Mesh` == 1))
	{

		float $Obj_Bounds[] = `polyEvaluate -b $Mesh`;
		float $X_Bounds = ($Obj_Bounds[1] - $Obj_Bounds[0]);
		float $Y_Bounds = ($Obj_Bounds[3] - $Obj_Bounds[2]);
		float $Z_Bounds = ($Obj_Bounds[5] - $Obj_Bounds[4]);

		$Mesh_Center = `objectCenter $Mesh`;
		$Reverse_Mesh = `duplicate $Mesh`;
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 $Reverse_Mesh;

		$Fracture_emitter = `emitter -type surface -n "Fracture_Emitter"  -r 1000 -sro 0 -nuv 0 -cye none -cyi 1 -spd 5 -srn 0 -nsp 1 -tsp 0 -mxd 0 -mnd 0 -dx 1 -dy 0 -dz 0 -sp 0 $Reverse_Mesh`;
		$Fracture_particle = `particle -n "Fracture_Particle"` ;
		collision -r 1 -f 0 -o 0.01  $Reverse_Mesh;
		setAttr ($Fracture_particle[0] + ".maxCount") $Iterations ;
		setAttr "Fracture_ParticleShape.startFrame" 0;


		connectDynamic -em $Fracture_emitter[0] $Fracture_particle[0];

		play -forward 1;
		for ($s = 1; $s < 2; $s++ )
				{
					currentTime $s;
					//refresh -f;
				}

				currentTime $Stop_Frame;
		play -st 0;
		//timeControl -e -endScrub $gPlayBackSlider;

		 for ($l = 0; $l < $Iterations; $l++)
			{
				float $Particle_Location[] = `xform -q -ws -t ($Fracture_particle[0] + ".pt[" + $l + "]")`;
				$Locator = `spaceLocator -name "Voronoi_Fracture_Locator" -p $Particle_Location[0] $Particle_Location[1] $Particle_Location[2]`;
				setAttr ($Locator[0] + "Shape.localScaleX") $Locator_Scale;
				setAttr ($Locator[0] + "Shape.localScaleY") $Locator_Scale;
				setAttr ($Locator[0] + "Shape.localScaleZ") $Locator_Scale;
				xform -cp $Locator;
				$Locators[$l] = $Locator[0];
			}

			delete $Reverse_Mesh;
			delete $Fracture_particle;
			//return $Locators;
	}//end if generate


if (`objExists $Mesh` == 1)
	{
		select $Mesh;
	}
return $Locators;
}//end proc preview Voronoi Particles

/////////////////////////////////////////////////////////////////////////////////////////preview Voronoi Cut Planes
//
global proc Preview_Voronoi_CutPlanes()
{
	$Locators = Generate_Voronoi_Particles();
	float $CenterA[];
	float $CenterB[];
	float $midPoint[];

	$Mesh = `selectedNodes`;
	$Mesh_Center = `objectCenter $Mesh`;
	float $Obj_Bounds[] = `polyEvaluate -b $Mesh`;
	float $X_Bounds = ($Obj_Bounds[1] - $Obj_Bounds[0]);
	float $Y_Bounds = ($Obj_Bounds[3] - $Obj_Bounds[2]);
	float $Z_Bounds = ($Obj_Bounds[5] - $Obj_Bounds[4]);
	float $Extent;
		if ($X_Bounds >= $Y_Bounds && $X_Bounds >= $Z_Bounds)
			{
				$Extent = $X_Bounds;
			}

		if ($Y_Bounds >= $X_Bounds && $Y_Bounds >= $Z_Bounds)
			{
				$Extent = $Y_Bounds;
			}

		if ($Z_Bounds >= $X_Bounds && $Z_Bounds >= $Y_Bounds)
			{
				$Extent = $Z_Bounds;
			}

	for ($a = 0; $a < `size $Locators`; $a++)
			{

				$CenterA = `objectCenter $Locators[$a]`;
				progressBar -edit -maxValue (`size $Locators`) Fracture_progress;
				for ($b = 0; $b < `size $Locators`; $b++)
				{
					if($a != $b)
					{
						$CenterB = `objectCenter $Locators[$b]`;

						//check for overlapping locators
						int $Locator_Overlap = 0;
						if ($CenterA[0] == $CenterB[0] && $CenterA[1] == $CenterB[1] && $CenterA[2] == $CenterB[2])
							{
								$Locator_Overlap = 1;
								//delete $Dup_Mesh;
								error "Locators overlap";
                            }

						if ($Locator_Overlap == 0)
							{
								$Crack_Plane = Create_Fracture_Object($midPoint, $Extent);
								move -ws -rpr $midPoint[0] $midPoint[1] $midPoint[2] $Crack_Plane;
								$Aim = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $Locators[$a] $Crack_Plane`;
								delete $Aim;
							}//end if
						//error;
					}//end if a!=b

				}//end for b

			//stringArrayInsertAtIndex(0, $Chunk_Array, $Dup_Mesh);
			//refresh -f;
			progressBar -edit -step 1 Fracture_progress;
			}//end for a

}//end proc preview Voronoi Cut Planes

/////////////////////////////////////////////////////////////////////////////////////////preview Spline Cut
//

global proc Adjust_Spline_Cut()
{
	$Cut_UDivisions = `intSliderGrp   -q -v fF_SplineCutUSegments`;
	$Cut_VDivisions = `intSliderGrp   -q -v fF_SplineCutVSegments`;

	$Cut_Noise = `floatSliderGrp   -q -v fF_SplineCutNoise`;

	if (`objExists "Fracture_SplinePlane"` == 1)
	{
		string $modifier[] = `listHistory "Fracture_SplinePlane"`;
		$total_modifiers = (`size($modifier)`);
		setAttr ($modifier[$total_modifiers - 4] + ".format") 2;
		setAttr ($modifier[$total_modifiers - 4] + ".vNumber") $Cut_VDivisions;
		setAttr ($modifier[$total_modifiers - 4] + ".uNumber") $Cut_UDivisions;

		setAttr ($modifier[$total_modifiers - 5]  + ".localTranslate") -type double3 0 0 $Cut_Noise;
    }
}

global proc Preview_Spline_Cut()
{

$Cut_UDivisions = `intSliderGrp   -q -v fF_SplineCutUSegments`;
$Cut_VDivisions = `intSliderGrp   -q -v fF_SplineCutVSegments`;
$Cut_Noise = `floatSliderGrp   -q -v fF_SplineCutNoise`;

string $Selection[] = `ls -sl -fl`;
select -d $Selection[0];
string $Selected_Obj[] = `ls -sl -fl`;

Clean_Spline_Preview();

float $Obj_Bounds[] = `polyEvaluate -b $Selected_Obj[0]`;//xmin, xmax, ymin, ymax, zmin, zmax.
		float $X_Bounds = ($Obj_Bounds[1] - $Obj_Bounds[0]);
		float $Y_Bounds = ($Obj_Bounds[3] - $Obj_Bounds[2]);
		float $Z_Bounds = ($Obj_Bounds[5] - $Obj_Bounds[4]);
		float $Cut_Length = $X_Bounds;

		//Find the Longest Length
		if ($X_Bounds > $Y_Bounds && $X_Bounds > $Z_Bounds)
			{
				$Cut_Length = $X_Bounds;
			}

		if ($Y_Bounds > $X_Bounds && $Y_Bounds > $Z_Bounds)
			{
				$Cut_Length = $Y_Bounds;
			}

		if ($Z_Bounds > $X_Bounds && $Z_Bounds > $Y_Bounds)
			{
				$Cut_Length = $Z_Bounds;
			}


		$Start_Spline = `duplicate -name "Fracture_StartSpline" $Selection[0]`;
		$End_Spline = `duplicate -name "Fracture_EndSpline"   $Selection[0]`;

		makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;
		//$Start_Spline_Position = `xform -q -piv -ws $Start_Spline`;// x y z x y z
		$Start_Spline_Position = `objectCenter  $Start_Spline`;//use objet center because the pivot could be at zero which causes a crash
		if ($Start_Spline_Position[0] <= $Obj_Bounds[0] )//xmin
			{
				move -r ($Cut_Length * 2) 0 0 $End_Spline ;
			}

		if ($Start_Spline_Position[0] >= $Obj_Bounds[1] )//xmax
			{
				move -r ($Cut_Length * -2) 0 0 $End_Spline  ;
			}

		if ($Start_Spline_Position[1] <= $Obj_Bounds[2] )//ymin
			{
				move -r 0 ($Cut_Length * 2) 0 $End_Spline;
			}

		if ($Start_Spline_Position[1] >= $Obj_Bounds[3] )//ymax
			{
				move -r 0 ($Cut_Length * -2) 0 $End_Spline ;
			}

		if ($Start_Spline_Position[2] <= $Obj_Bounds[4] )//zmin
			{
				move  -r 0 0 ($Cut_Length * 2) $End_Spline;
			}

		if ($Start_Spline_Position[2] >= $Obj_Bounds[5] )//zmax
			{
				move -r 0 0 ($Cut_Length * -2) $End_Spline;
			}

		//error;
		$Spline_Loft = `loft -name "Fracture_SplinePlane" -ch 1 -u 1 -c 0 -ar 1 -d 1 -ss 1 -rn 0 -po 1 -rsn true $Start_Spline $End_Spline`;
		string $modifier[] = `listHistory`;
		$total_modifiers = (`size($modifier)`);

		setAttr ($modifier[$total_modifiers - 4] + ".format") 2;
		setAttr ($modifier[$total_modifiers - 4] + ".vNumber") $Cut_VDivisions;
		setAttr ($modifier[$total_modifiers - 4] + ".uNumber") $Cut_UDivisions;

		$NoiseModifier = `polyMoveVertex -constructionHistory 1 -random 1`;
		setAttr ($NoiseModifier[0] + ".localTranslate") -type double3 0 0 $Cut_Noise;

		xform -cp;
		//delete -ch;
		select $Selection;
		//select $Total_Pieces[$c];
}//end proc

global proc Preview_Chip()
{
	$Preview_Chip = `checkBox -q -v cb_preview_Chips`;

	Clean_Preview_Chip;

	if ($Preview_Chip == 1)
	{
		$Selection = `ls -sl -fl`;
		$Center = `objectCenter $Selection[0]`;
		$Chip = Create_Chip();
		move -ws -rpr $Center[0] $Center[1] $Center[2] $Chip;
		select $Selection;
    }//end if

} //end proc


global proc Preview_FracturePath()
{

	//$PreviewPath = `checkBox -q -v cb_Preview_FracturePath`;

	int $Path_Segments  = `intSliderGrp -q -v fF_PathSegments`;
	int $Path_Offsets = `intSliderGrp -q -v  fF_PathOffsets`;
	float $Path_OffsetAmount = `floatSliderGrp -q -v fF_PathOffsetAmount`;
	float $Path_Noise = `floatSliderGrp -q -v FF_PathNoise`;

	Clean_PreviewPath();

	$Selection = `ls -sl -fl`;
	$Path = $Selection[0];

	string $Dup_Path[] = `duplicate $Path`;
	rename  $Dup_Path "Fracture_Path";
	$Dup_Path = `ls -sl -fl`;

	rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 1 -kcp 0 -kep 1 -kt 0 -s $Path_Segments -d 3 -tol 1 $Dup_Path[0];
	for ($m = 0; $m < $Path_Segments; $m++)
			{
				$Point_Location = `xform -q -t -ws ($Dup_Path[0] + ".ep[" + $m + "]")`;
				$Locator = `spaceLocator -name "Voronoi_Fracture_Locator" -p $Point_Location[0] $Point_Location[1] $Point_Location[2]`;
				float $Random_Move = `rand ($Path_Noise *-1) $Path_Noise`;
				move -r $Random_Move $Random_Move $Random_Move $Locator;
				xform -cp $Locator;
			}//end for

	for ($d = 0; $d < ($Path_Offsets); $d++)
			{
				$Offset_PathA = `offsetCurve  -name "Fracture_Path" -ch on -rn false -cb 2 -st true -cl true -cr 0 -d ($Path_OffsetAmount * ($d +1) ) -tol 0.01 -sd 5 -ugn false  $Path` ;
				$Offset_PathB = `offsetCurve  -name "Fracture_Path" -ch on -rn false -cb 2 -st true -cl true -cr 0 -d ($Path_OffsetAmount * ($d + 1) * -1) -tol 0.01 -sd 5 -ugn false $Path` ;

				makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $Offset_PathA;
				makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $Offset_PathB;


				rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 1 -kcp 0 -kep 1 -kt 0 -s ($Path_Segments /  ($d + 2)) -d 3 -tol 1 $Offset_PathA[0];
				rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 1 -kcp 0 -kep 1 -kt 0 -s ($Path_Segments /  ($d + 2)) -d 3 -tol 1 $Offset_PathB[0];

				$Spans = `getAttr ($Offset_PathA[0] + ".spans")`;
				for ($e = 0; $e < ($Spans + 1); $e++)
					{
						$Point_LocationA = `xform -q -t -ws ($Offset_PathA[0] + ".ep[" + $e + "]")`;
						$LocatorA = `spaceLocator -name "Voronoi_Fracture_Locator" -p $Point_LocationA[0] $Point_LocationA[1] $Point_LocationA[2]`;
						xform -cp $LocatorA;
						float $Random_Move = `rand ($Path_Noise * -1) $Path_Noise `;
						move -r $Random_Move $Random_Move $Random_Move $LocatorA;

						$Point_LocationB = `xform -q -t -ws ($Offset_PathB[0] + ".ep[" + $e + "]")`;
						$LocatorB = `spaceLocator -name "Voronoi_Fracture_Locator" -p $Point_LocationB[0] $Point_LocationB[1] $Point_LocationB[2]`;
						xform -cp $LocatorB;
						float $Random_Move = `rand ($Path_Noise * -1) $Path_Noise`;
						move -r $Random_Move $Random_Move $Random_Move $LocatorB;
					}//end for e
				//delete $Offset_PathA;
				//delete $Offset_PathB;

			}//end for d

			delete $Dup_Path;
			select $Path;
}//end proc

global proc Clean_PreviewPath()
{
	if (`objExists "Voronoi_Fracture_Locator*"`)
	{
		delete "Voronoi_Fracture_Locator*";
	}

	if (`objExists "Fracture_Path*"`)
	{
		delete "Fracture_Path*";
	}

}//end proc

global proc Clean_Voronoi_Particles()
{
		//checkBox -e -en 0 -v 0 cb_Fracture_ForceLocators;

		if (`objExists "Voronoi_Fracture_Locator*"` == 1)
		{
			delete "Voronoi_Fracture_Locator*";
		}


}//end proc


global proc Clean_Preview_Chip()
{
	if (`objExists "Fracture_PreviewChip"` == 1)
	{
		delete 	"Fracture_PreviewChip*";
    }//end if
}//end proc


global proc Clean_Spline_Preview()
{

	if (`objExists "Fracture_EndSpline" ` == 1)
		{
			delete "Fracture_EndSpline*";
        }

	if (`objExists "Fracture_StartSpline"` == 1 )
		{
			delete "Fracture_StartSpline*";
        }

	if (`objExists "Fracture_SplinePlane"` == 1)
		{
			delete "Fracture_SplinePlane*";
        }
}//end proc


global proc Adjust_PreviewPlane()
{
	global string $Preview_Plane[];
	global string $NoiseModifier[];
	float $Face_Size = `floatSliderGrp -q -value FF_Face_Size`;
	float $Noise_Amount =`floatSliderGrp -q -value FF_Noise`;

	if (`objExists $Preview_Plane[0]` == 1)
	{
		$PlaneSize =`getAttr ($Preview_Plane[1] + ".width")`;
		$Noise_Percent = (($PlaneSize/2) * $Noise_Amount * .01);
		//print $PlaneSize;
		int $Divisions = (($PlaneSize / $Face_Size) );//Calculate divisions
		//print $Divisions;
		global string $Preview_Plane[];
		setAttr ($Preview_Plane[1] + ".subdivisionsHeight") $Divisions;
		setAttr ($Preview_Plane[1] + ".subdivisionsWidth") $Divisions;
		setAttr ($NoiseModifier[0] + ".localTranslate") -type double3 0 0 $Noise_Amount;

		//Center Pivot and move back to Center of Object
		$Plane_Location = `xform -q -ws -piv $Preview_Plane`;
		xform -cp $Preview_Plane;
		move -ws -rpr $Plane_Location[0] $Plane_Location[1] $Plane_Location[2] $Preview_Plane;

    }//end if
}


global proc Fracture_Union()
{
	string $Sel_Objs[] = `selectedNodes`;
	string $Base_Obj[] = $Sel_Objs	;
	for ($c = 1; $c < `size Sel_Objs`; $c++)
				{
					if (`objExists $Base_Obj[0]` && `objExists $Sel_Objs[$c]`)
						{
							$Base_Obj = `polyBoolOp -op 1 -ch 0 $Base_Obj[0] $Sel_Objs[$c]`;
						}//end if
				}//end for c
}//end proc




///////////////////////////////////////////////////////////////////////////////////////////////////Find open border edges
global proc string[] BK_Find_Open_Edges()
{
	ConvertSelectionToEdges;
	polySelectConstraint -w 1 -m 2 -bo true -sh false -t 0x8000;//select only border edges
	$Open_edges =`ls -sl -fl`;
	polySelectConstraint -m 0 -bo false ;//set constraint to nothing
	return $Open_edges;
}//end proc


///////////////////////////////////////////////////////////////////////////////////////////////////Cap Holes

global proc Fracture_Cap_Flat()
{
	$Assign_Shader = `checkBox  -q -v cb_Fracture_AssignShader`;

	$Selected_Object = `selectedNodes`;
	string $Open_edges[] = BK_Find_Open_Edges();
	while (`size $Open_edges` > 0)
		{
			select 	$Open_edges[0];
			SelectEdgeLoop;
			//Extrude edges and collapse
			polyExtrudeEdge;
			MergeToCenter;
			$sel_Vert = `ls -sl -fl`;


			ConvertSelectionToFaces;
			$sel_Faces = `ls -sl -fl -l`;

			if ($Assign_Shader == 1)
			{
				sets -e -forceElement Fracture_Shader_SG $sel_Faces;
			}

			//apply mapping
			polyProjection -ch 1 -type Planar -ibd on -md b $sel_Faces ;

			//delete interior edges
			select $sel_Vert;
			ConvertSelectionToEdges;
			//error;
			doDelete;

			//find open edges
			//
			select -r  $Selected_Object;
			$Open_edges = BK_Find_Open_Edges();
		}//end while
	delete -ch 	$Selected_Object;
	select -r $Selected_Object;
}//end proc

global proc Fracture_Cap_Holes()
{

	$Assign_Shader = `checkBox  -q -v cb_Fracture_AssignShader`;

	$Selected_Object = `selectedNodes`;
	string $Open_edges[] = BK_Find_Open_Edges();
	while (`size $Open_edges` > 0)
		{
			select 	$Open_edges[0];
			SelectEdgeLoop;
			//Extrude edges and collapse
			polyExtrudeEdge;
			MergeToCenter;
			ConvertSelectionToFaces;

			$sel_Faces = `ls -sl -fl -l`;
			//error;
			//Create_Fracture_Shader();
			if ($Assign_Shader == 1)
			{
				sets -e -forceElement Fracture_Shader_SG $sel_Faces;

            }
			polyProjection -ch 1 -type Planar -ibd on -md b $sel_Faces;

			//find open edges
			//
			select -r  $Selected_Object;
			$Open_edges = BK_Find_Open_Edges();
		}//end while
	select -r $Selected_Object;
}//end proc


///////////////////////////////////////////////////////////////////////////////////////////////////Shader
global proc Create_Fracture_Shader()
{
	if (`objExists "Fracture_Shader"` == 0)
	{
		$Fracture_Shader = `shadingNode -name "Fracture_Shader" -asShader lambert`;
		$Fracture_SG = `sets -renderable true -noSurfaceShader true -empty -name "Fracture_Shader_SG"`;//create a Shading Group node
		connectAttr -force ($Fracture_Shader  + ".outColor") ($Fracture_SG + ".surfaceShader");//connects material node to Shading Group node
		setAttr "Fracture_Shader.color" -type double3 1 0 0 ;
    }



}

///////////////////////////////////////////////////////////////////////////////////////////////////Seperate Unsperated Chunks
global proc string[] BK_Seperate_Chunks() //needs to have an object selected
{
	$Chunk_Name = `textField -q -tx TF_Fracture_Chunk_Name`;

	string $Chunks[] = `ls -sl -fl`;
	string $New_Chunks[] = {};
	$Total_Chunk_Count = 0;
	for ($l = 0; $l < `size $Chunks`; $l++)
		{
			int $Face_Shells[] = `polyEvaluate -s $Chunks[$l]`;
			select $Chunks[$l];
			if ($Face_Shells[0] > 1)
				{
					polySeparate -ch 0 $Chunks[$l];
					string $parent_Group[] = `listRelatives -p`;//unparent chunks
					select -r $parent_Group[0];
					ungroup;
					$New_Chunks = `ls -sl -fl`;

					//rename the new chunks
					//
					for ($r = 0; $r < `size $New_Chunks`; $r++)
						{
							xform -cp $New_Chunks[$r];//Centers pivot
							rename $New_Chunks[$r] $Chunk_Name;
						}

					$New_Chunks = `ls -sl -fl`;
					$New_Chunk_Count = (`size $New_Chunks` - 1);
					$Total_Chunk_Count = ($Total_Chunk_Count + $New_Chunk_Count);
				}//end if

        }//end l
	print ($Total_Chunk_Count + " New chunks Created from seperating");
	return $New_Chunks;
}//end proc


///////////////////////////////////////////////////////////////////////////////////////////////////Create Fracture Plane
global proc string Create_Fracture_Object(float $Cen[], float $Extent)
{
	//get UI settings
	//
	float $Noise_Amount =`floatSliderGrp -q -value FF_Noise`;
	float $Face_Size = `floatSliderGrp -q -value FF_Face_Size`;
	$FractureCutMethod = `radioButtonGrp -q -sl Fracture_CutMethod`;
	$Fracture_Triangulate = `checkBox  -q -v  cb_Fracture_Triangulate`;
	$Assign_Shader = `checkBox  -q -v cb_Fracture_AssignShader`;

	string $Cut_Plane[];
	if ($FractureCutMethod == 1)//boolean cut
	{
		int $Divisions = ((($Extent * 2) / $Face_Size) - 1);//Calculate divisions

		if ($Divisions == 0)
		{
			$Divisions = 1;
		}

		//Create the Cutting Plane
		//
		$Cut_Plane = `polyPlane -name "Fracture_CutPlane" -ch on -o on -w ($Extent * 2) -h ($Extent * 2) -sw $Divisions -sh $Divisions -cuv 2 `;

		if ($Assign_Shader == 1)
		{
			sets -e -forceElement Fracture_Shader_SG $Cut_Plane;

        }

		//Adjust Noise Amount if its greater than the Extent
		if ($Noise_Amount > $Extent)
			{
				$Noise_Amount = ($Extent / 2);
				floatSliderGrp -e -v ($Extent / 2) FF_Noise;// set max value of noise size
			}

		$NoiseModifier = `polyMoveVertex -constructionHistory 1 -random 1`;
		setAttr ($NoiseModifier[0] + ".localTranslate") -type double3 0 0 $Noise_Amount ;

		if ($Fracture_Triangulate == 1)
		{
			polyTriangulate -ch 1 $Cut_Plane;
			select $Cut_Plane;
		}
	}

	if ($FractureCutMethod == 2)//poly cut
	{
			$Cut_Plane = `polyPlane -name "Fracture_CutPlane" -ch on -o on -w ($Extent * 4) -h ($Extent * 4) -sw 1 -sh 1 -cuv 2 `;
    }

	//Center Pivot and move back to Center of Object
	xform -cp $Cut_Plane;
	move -ws -rpr $Cen[0] $Cen[1] $Cen[2] $Cut_Plane;
	//error;
	return $Cut_Plane[0];

}//end proc






global proc string[] Generate_Voronoi_Particles()
{
	$Iterations = `intSliderGrp -q -v FF_Cuts`;
	$Stop_Frame = `intSliderGrp -q -v Stop_Frame`;
	$Selection = `ls -sl -fl`;
	$Mesh = $Selection[0];
	//select -d $Mesh;
	progressBar -edit -pr 0 Fracture_progress;//reset progress bar to 0
	$Chunk_Name = `textField -q -tx TF_Fracture_Chunk_Name`;
	$Preview_Locators = `checkBox -q -value cb_Generate_Particles`;
	string $Locators[];

	if (`objExists "Voronoi_Fracture_Locator*"` == 1)
    {
		delete "Voronoi_Fracture_Locator*";
    }
	float $Obj_Bounds[] = `polyEvaluate -b $Mesh`;
	float $X_Bounds = ($Obj_Bounds[1] - $Obj_Bounds[0]);
	float $Y_Bounds = ($Obj_Bounds[3] - $Obj_Bounds[2]);
	float $Z_Bounds = ($Obj_Bounds[5] - $Obj_Bounds[4]);
	$Mesh_Center = `objectCenter $Mesh`;
	$Reverse_Mesh = `duplicate $Mesh`;
	polyNormal -normalMode 0 -userNormalMode 0 -ch 1 $Reverse_Mesh;
	$Fracture_emitter = `emitter -type surface -n "Fracture_Emitter"  -r 1000 -sro 0 -nuv 0 -cye none -cyi 1 -spd 5 -srn 0 -nsp 1 -tsp 0 -mxd 0 -mnd 0 -dx 1 -dy 0 -dz 0 -sp 0 $Reverse_Mesh`;
	collision -r 1 -f 0 -o 0.01  $Reverse_Mesh;//add collision to particles
	$Fracture_particle = `particle -n "Fracture_Particle"` ;
	setAttr ($Fracture_particle[0] + ".maxCount") $Iterations ;
	setAttr "Fracture_ParticleShape.startFrame" 0;

	connectDynamic -em $Fracture_emitter[0] $Fracture_particle[0];
	play -forward 1;
	for ($s = 1; $s < 2; $s++ )
		{
			currentTime $s;
			//refresh -f;
		}

	currentTime $Stop_Frame;
	play -st 0;
		//timeControl -e -endScrub $gPlayBackSlider;

		 for ($l = 0; $l < $Iterations; $l++)
			{
				float $Particle_Location[] = `xform -q -ws -t ($Fracture_particle[0] + ".pt[" + $l + "]")`;
				$Locator = `spaceLocator -name "Voronoi_Fracture_Locator" -p $Particle_Location[0] $Particle_Location[1] $Particle_Location[2]`;
				setAttr ($Locator[0] + "Shape.localScaleX") 0;
				setAttr ($Locator[0] + "Shape.localScaleY") 0;
				setAttr ($Locator[0] + "Shape.localScaleZ") 0;
				xform -cp $Locator;
				$Locators[$l] = $Locator[0];
			}

			delete $Reverse_Mesh;
			delete $Fracture_particle;
			//return $Locators;

select $Mesh;
return $Locators;
}//end proc

///////////////////////////////////////////////////////////////////////////////////////////////////Voronoi_Fracture






global proc Path_Fracture()
{

	int $Path_Segments  = `intSliderGrp -q -v fF_PathSegments`;
	int $Path_Offsets = `intSliderGrp -q -v  fF_PathOffsets`;
	float $Path_OffsetAmount = `floatSliderGrp -q -v fF_PathOffsetAmount`;
	float $Path_Noise = `floatSliderGrp -q -v FF_PathNoise`;


	checkBox -e -v 1 cb_Fracture_ForceLocators;
	radioButtonGrp -e -select 2 Fracture_CutMethod;

	Clean_PreviewPath();

	$Selection = `ls -sl -fl`;
	$Path = $Selection[0];
	$Mesh = $Selection[1];

	string $Dup_Path[] = `duplicate $Path`;
	rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 1 -kcp 0 -kep 1 -kt 0 -s $Path_Segments -d 3 -tol 1 $Dup_Path[0];
	for ($m = 0; $m < $Path_Segments; $m++)
			{
				$Point_Location = `xform -q -t -ws ($Dup_Path[0] + ".ep[" + $m + "]")`;
				$Locator = `spaceLocator -name "Voronoi_Fracture_Locator" -p $Point_Location[0] $Point_Location[1] $Point_Location[2]`;
				setAttr ($Locator[0] + "Shape.localScaleX") 0;
				setAttr ($Locator[0] + "Shape.localScaleY") 0;
				setAttr ($Locator[0] + "Shape.localScaleZ") 0;
				float $Random_Move = `rand ($Path_Noise *-1) $Path_Noise`;
				move -r $Random_Move $Random_Move $Random_Move $Locator;
				xform -cp $Locator;
			}//end for


	for ($d = 0; $d < ($Path_Offsets); $d++)
			{
				$Offset_PathA = `offsetCurve  -ch on -rn false -cb 2 -st true -cl true -cr 0 -d ($Path_OffsetAmount * ($d +1) ) -tol 0.01 -sd 5 -ugn false  $Path` ;
				$Offset_PathB = `offsetCurve  -ch on -rn false -cb 2 -st true -cl true -cr 0 -d ($Path_OffsetAmount * ($d + 1) * -1) -tol 0.01 -sd 5 -ugn false $Path` ;

				makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $Offset_PathA;
				makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $Offset_PathB;

				rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 1 -kcp 0 -kep 1 -kt 0 -s ($Path_Segments /  ($d + 2)) -d 3 -tol 1 $Offset_PathA[0];
				rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 1 -kcp 0 -kep 1 -kt 0 -s ($Path_Segments /  ($d + 2)) -d 3 -tol 1 $Offset_PathB[0];

				$Spans = `getAttr ($Offset_PathA[0] + ".spans")`;
				for ($e = 0; $e < ($Spans + 1); $e++)
					{
						$Point_LocationA = `xform -q -t -ws ($Offset_PathA[0] + ".ep[" + $e + "]")`;
						$LocatorA = `spaceLocator -name "Voronoi_Fracture_Locator" -p $Point_LocationA[0] $Point_LocationA[1] $Point_LocationA[2]`;
						setAttr ($LocatorA[0] + "Shape.localScaleX") 0;
						setAttr ($LocatorA[0] + "Shape.localScaleY") 0;
						setAttr ($LocatorA[0] + "Shape.localScaleZ") 0;
						xform -cp $LocatorA;
						float $Random_Move = `rand ($Path_Noise * -1) $Path_Noise `;
						move -r $Random_Move $Random_Move $Random_Move $LocatorA;

						$Point_LocationB = `xform -q -t -ws ($Offset_PathB[0] + ".ep[" + $e + "]")`;
						$LocatorB = `spaceLocator -name "Voronoi_Fracture_Locator" -p $Point_LocationB[0] $Point_LocationB[1] $Point_LocationB[2]`;
						setAttr ($LocatorB[0] + "Shape.localScaleX") 0;
						setAttr ($LocatorB[0] + "Shape.localScaleY") 0;
						setAttr ($LocatorB[0] + "Shape.localScaleZ") 0;
						xform -cp $LocatorB;
						float $Random_Move = `rand ($Path_Noise * -1) $Path_Noise`;
						move -r $Random_Move $Random_Move $Random_Move $LocatorB;
					}//end for e
				delete $Offset_PathA;
				delete $Offset_PathB;
			}//end for d

	select $Mesh;
	Voronoi_Fracture();
	delete $Dup_Path;
	checkBox -e -v 0 cb_Fracture_ForceLocators;

}



global proc Voronoi_SpeedFracture()
{
	int $Iterations = `intSliderGrp -q -v FF_Cuts`;
	int $Limit_Iterations = (`log $Iterations` );

	intSliderGrp -e -v $Limit_Iterations FF_Cuts;
	for ($i = 0; $i < $Limit_Iterations; $i++)
		{
			//string $Chunks[] = {};

			$Chunks = Voronoi_Fracture();
			//print $Chunks;
			select -cl;
			for ($c = 0; $c < `size $Chunks`; $c++)
				{
					catchQuiet (`select -add $Chunks[$c]`);

                }
			//error;
		}

}


global proc string[] Voronoi_Fracture()
{

	$Fill_Holes  = `checkBox -q -v cb_Fill_Holes`;
	$FractureCutMethod = `radioButtonGrp -q -sl Fracture_CutMethod`;
	$Force_Locators = `checkBox -q -v cb_Fracture_ForceLocators`;
	$No_Divisions = `checkBox  -q -v cb_No_Divisions`;
	$No_Noise = `checkBox   -q -v   cb_No_Noise`;
	$Create_Group =   `checkBox -q -v CB_Group_Chunks`;
	$Fracture_Group = `textField -q -tx TF_Fracture_Group_Name`;
	$Fracture_Triangulate = `checkBox  -q -v  cb_Fracture_Triangulate`;
	$Chunk_Name = 	  `textField -q -tx TF_Fracture_Chunk_Name`;
	$Seperate_Chunks =`checkBox -q -v cb_Seperate_Chunks`;
	$Distance_Check = `intSliderGrp -q -v   Distance_Scale` ;
	$startTime = `timerX`;

	Fracture_CloseWindows();

	string $Chunk_Array[] = {};
	$Selection = `ls -sl -fl`;
	$Chunk_Name = `textField -q -tx TF_Fracture_Chunk_Name`;
	int $FaceCountA[] = {};

	//progressWindow -isInterruptable true;
	//progressWindow -e -maxValue (`size $Selection`);
	string $Rename_Array[] ={};
	for ($i = 0; $i < `size $Selection`; $i++)
		{
			//$Rename_Array = {}; //clear out the nename array
			$Mesh = $Selection[$i];
			if ($Fracture_Triangulate == 1)
				{
					polyTriangulate -ch 1 $Mesh;
				}

			select $Mesh;
			string $Locators[] = {};
			progressBar -edit -pr 0 Fracture_progress;//reset progress bar to 0

			$Mesh_Center = `objectCenter $Mesh`;
			float $Obj_Bounds[] = `polyEvaluate -b $Mesh`;
			float $X_Bounds = ($Obj_Bounds[1] - $Obj_Bounds[0]);
			float $Y_Bounds = ($Obj_Bounds[3] - $Obj_Bounds[2]);
			float $Z_Bounds = ($Obj_Bounds[5] - $Obj_Bounds[4]);
			float $Extent;

			if ($X_Bounds >= $Y_Bounds && $X_Bounds >= $Z_Bounds)
				{
					$Extent = $X_Bounds;
				}

				if ($Y_Bounds >= $X_Bounds && $Y_Bounds >= $Z_Bounds)
				{
					$Extent = $Y_Bounds;
				}

				if ($Z_Bounds >= $X_Bounds && $Z_Bounds >= $Y_Bounds)
				{
					$Extent = $Z_Bounds;
				}



			if ($Force_Locators == 1)
				{
					select "Voronoi_Fracture_Locator*";
					select -d "*Shape*";//deselect shapes
					$Locators = `ls -sl -fl`;
					select $Mesh;
				}

			else
				{
					$Locators = Generate_Voronoi_Particles();

				}


			 float $CenterA[];
			 float $CenterB[];
			 float $midPoint[];

		 for ($a = 0; $a < `size $Locators`; $a++)
			{
				$Dup = `duplicate $Mesh`;
				$Dup_Mesh = $Dup[0];
				hide $Mesh;

				$CenterA = `objectCenter $Locators[$a]`;


				progressBar -edit -maxValue (`size $Locators`) Fracture_progress;
				for ($b = 0; $b < `size $Locators`; $b++)
				{
					if($a != $b)
					{

						$CenterB = `objectCenter $Locators[$b]`;

						//calculate distance of locators
						float $Percent_Dist = 100;
						float $Percent_Dist = 0;
						if ($Distance_Check != 100)
						{
							//distance between a and b
							$midPoint = {(($CenterA[0] + $CenterB[0])/2), (($CenterA[1] + $CenterB[1])/2), (($CenterA[2] + $CenterB[2])/2)};
							$Center_Mesh = `objectCenter $Selection[$i]`;
							float $distancePosX = $midPoint[0] - $Center_Mesh[0];
							float $distancePosY = $midPoint[1] - $Center_Mesh[1];
							float $distancePosZ = $midPoint[2] - $Center_Mesh[2];
							float $distance = `mag <<$distancePosX, $distancePosY, $distancePosZ>>`;
							$Percent_Dist = (($distance / $Extent) * 100);
							//print $Percent_Dist;
						}

						//error;

						//check for overlapping locators
						int $Locator_Overlap = 0;
						if ($CenterA[0] == $CenterB[0] && $CenterA[1] == $CenterB[1] && $CenterA[2] == $CenterB[2])
							{
								$Locator_Overlap = 1;
								//delete $Dup_Mesh;
								error "Locators overlap";
                            }


						if ($Locator_Overlap == 0 && $Percent_Dist < $Distance_Check)
						{
							//Get Mid Distance between Locators
							$midPoint = {(($CenterA[0] + $CenterB[0])/2), (($CenterA[1] + $CenterB[1])/2), (($CenterA[2] + $CenterB[2])/2)};
							$Crack_Plane = Create_Fracture_Object($midPoint, $Extent);
							move -ws -rpr $midPoint[0] $midPoint[1] $midPoint[2] $Crack_Plane;
							$Aim = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $Locators[$a] $Crack_Plane`;
							delete $Aim;

							$FaceCountA = `polyEvaluate -f $Dup_Mesh`;

							if ($FaceCountA[0] == 0)
								{
									delete $Dup_Mesh;
									delete $Crack_Plane;
									//error ("Boolean Object has no Faces" + $Dup_Mesh);
								}//end if

							if ($FaceCountA[0] != 0)
							{
								string $Bool_A[];
								if ($FractureCutMethod == 1)//boolean
									{
										if ($No_Divisions == 1)
											{

												string $History[] =`listHistory $Crack_Plane`;
												$lastHistory = `size $History`;
												setAttr ($History[$lastHistory - 1] + ".subdivisionsWidth") 1;
												setAttr ($History[$lastHistory - 1] + ".subdivisionsHeight") 1;
											}

										if ($No_Noise == 1)
											{

												string $History[] =`listHistory $Crack_Plane`;
												$lastHistory = `size $History`;
												setAttr ($History[$lastHistory - 2] + ".localTranslateZ") 0;
												xform -cp $Crack_Plane;
												//error;
											}

										$Bool_A = `polyBoolOp -name $Chunk_Name -op 2 -ch 0 $Dup_Mesh $Crack_Plane`;
										$Dup_Mesh = $Bool_A[0];


									}

								if ($FractureCutMethod == 2)//polycut
									{
										showHidden $Dup_Mesh;
										$Cut_Rotation = `xform -q -ro $Crack_Plane`;
										delete $Crack_Plane;
										$Cut =`polyCut -ch 0 -df 1 -pc $midPoint[0] $midPoint[1] $midPoint[2] -rx ($Cut_Rotation[0] + 270) -ry ($Cut_Rotation[1]) -rz ($Cut_Rotation[2]) -ps 10000 10000 $Dup_Mesh`;
										//refresh -f;
										int $numFace[] = `polyEvaluate -f $Dup_Mesh`;
										if ($numFace[0] == 1)
											{
												delete $Cut;
                                            }



										if ($numFace[0] != 1 && $Fill_Holes == 1)
											{
												//polyCloseBorder -ch 0 $Dup_Mesh;
												select $Dup_Mesh;
												Fracture_Cap_Flat();
											}

										$Bool_A[0] = $Dup_Mesh;

									}

								$FaceCountA = `polyEvaluate -f $Bool_A`;
								rotate -a 0 0 0 $Locators[$b];//reset rotation
								xform -cp $Dup_Mesh;

							}//end if
						//error;
						}//end if locator overlap == 0

					}//end if a!=b

				delete -ch $Dup_Mesh;
				$totalTime = `timerX -startTime $startTime`;
				text -e -l ("Fracture Progress " + ($a + 1) + " out of " + `size $Locators` + "     elapsed time: " + $totalTime )progressText;
				//refresh -f;
				}//end for b


			if ($Seperate_Chunks == 1)
			{
				select $Dup_Mesh;
				string $New_Chunks[] = BK_Seperate_Chunks();
				appendStringArray ($Chunk_Array,$New_Chunks, `size $New_Chunks`);
			}//end if seperate chunks

			stringArrayInsertAtIndex(0, $Chunk_Array, $Dup_Mesh);
			refresh -f;
			progressBar -edit -step 1 Fracture_progress;
			}//end for a



			//rename the objects
			for ($r = 0; $r < `size $Chunk_Array`; $r++)
			{
				if (`objExists $Chunk_Array[$r]`)//check to see if object still exists
					{
						$newName = `rename $Chunk_Array[$r] $Chunk_Name`;
						stringArrayInsertAtIndex(0, $Rename_Array, $newName);
					}//end if objExists
			}//end for r



			//Group Objects if option is set
			if ($Create_Group == 1)
				{
					group -name $Fracture_Group  $Rename_Array;
				}

			//clean up
			delete $Mesh;
			delete $Locators;

		 }//end for i

return $Rename_Array;
//progressWindow -endProgress;
}


global proc Fracture_CloseWindows()
{
	$allWindows = `lsUI -windows`;
	for ($window in $allWindows)
	{
		if ($window == "polyTexturePlacementPanel1Window")
		{
			 deleteUI "polyTexturePlacementPanel1Window";
		}

		if ($window == "scriptEditorPanel1Window")
		{
			// deleteUI "scriptEditorPanel1Window";
		}
	};
}

///////////////////////////////////////////////////////////////////////////////////////////////////Plane_Fracture
global proc string[] Plane_Fracture(string $CutType)
{

	global string $Preview_Plane[];
	$PolyCut_Extrude = `floatSliderGrp -q -value FF_PolyCut_Extrude`;
	$FractureCutMethod = `radioButtonGrp -q -sl Fracture_CutMethod`;
	$Bias_percent = `intSliderGrp -q -v Bias_percent`;
	$Fill_Holes =     `checkBox  -q -v  cb_Fill_Holes`;
	$Crop_Fracture =  `checkBox -q -v cb_Crop_Fracture`;
	$Create_Group =   `checkBox -q -v CB_Group_Chunks`;
	$Fracture_Group = `textField -q -tx TF_Fracture_Group_Name`;
	$Chunk_Name = 	  `textField -q -tx TF_Fracture_Chunk_Name`;
	$Seperate_Chunks =`checkBox -q -v cb_Seperate_Chunks`;
	$Delete_Slivers = `checkBox  -q -v  cb_Delete_Slivers`;
	$Sliver_Size = `intField -q -v sliver_size`;
	int $Cuts =       `intSliderGrp -q -value FF_Cuts`;
	float $Rand_Rot = `intSliderGrp -q -value FF_Rot`;
	$Force_CuttingPlane = `checkBox -q -v cb_Fracture_ForcePlane`;
	$Fracture_Triangulate = `checkBox  -q -v  cb_Fracture_Triangulate`;


	string $Selected_Objs[] = `ls -sl -fl -l`;//store selected objects object to be fractured
	string $Chunk;
	float $Object_Area[];
	string $Delete_Array[] = {};
	string $Chunk_Array[] = {};
	string $Chunks[] = {};

	$startTime = `timerX`;
	Fracture_CloseWindows();
	if ($Force_CuttingPlane == 1 && (`objExists $Preview_Plane[0]` == 1))
		{
		 $Cuts = 2;
		}

	string $Total_Pieces[] = {};
	$Total_Pieces = $Selected_Objs;

	//seperate chunks and add pieces to Total Pieces
	if ($Seperate_Chunks == 1)
		{

			for ($i = 0; $i < `size $Selected_Objs`; $i++)
			{
				if ($CutType == "Spline")
					{
						select -d $Selected_Objs[0];
                    }

				select $Selected_Objs[$i];
				string $New_Chunks[] = BK_Seperate_Chunks();
				appendStringArray($Total_Pieces, $New_Chunks, `size $New_Chunks`);
            }
		}//end if

	if (`size $Total_Pieces` == 0 )
		{
			appendStringArray($Total_Pieces, $Selected_Objs, 1);
    	}

	if ($CutType != "Spline")
		{
			progressBar -edit -maxValue ($Cuts - 1 ) Fracture_progress;
		}

	for ($x = 0; $x < `size $Total_Pieces`; $x++)
			{

				if (`shortNameOf ($Total_Pieces[$x])` == "Fracture_Preview_Plane")
					{
						confirmDialog -title "Error" -message "You have the fracture preview plane selected Fracture will not continue" -button "Exit" -defaultButton "Exit";
						error " You have the preview plane selected ";
                    }
            }


	for ($o = 0; $o < `size $Total_Pieces`; $o++)
			{

				//print "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
				//print $Total_Pieces[$o];


				string $Chunks[] = {};//clear array
				if (`objExists $Total_Pieces[$o]`)
				{
				select $Total_Pieces[$o];
				$Object_Area =`polyEvaluate -a`;
				if ($CutType != "Spline")
					{
						progressBar -edit -pr 0 Fracture_progress;//reset progress bar to 0
					}
				select -r $Total_Pieces[$o];

				if ($Fracture_Triangulate == 1)
						{
							polyTriangulate -ch 0 $Total_Pieces[$o];
							select -r $Total_Pieces[$o];
						}

				for ($b = 0; $b < ($Cuts - 1); $b++)
					{
						//Fill Holes
						//
						if ($Fill_Holes == 1)
							{
								Fracture_Cap_Flat();
							}

						$Selected_Obj = `ls -sl -fl -l`;

						float $Obj_Bounds[] = `polyEvaluate -b $Selected_Obj[0]`;
						float $X_Bounds = ($Obj_Bounds[1] - $Obj_Bounds[0]);
						float $Y_Bounds = ($Obj_Bounds[3] - $Obj_Bounds[2]);
						float $Z_Bounds = ($Obj_Bounds[5] - $Obj_Bounds[4]);

						//check for largest extents
						//
						float $Extent;
						if ($X_Bounds >= $Y_Bounds && $X_Bounds >= $Z_Bounds)
							{
								$Extent = $X_Bounds;
							}

						if ($Y_Bounds >= $X_Bounds && $Y_Bounds >= $Z_Bounds)
							{
								$Extent = $Y_Bounds;
							}

						if ($Z_Bounds >= $X_Bounds && $Z_Bounds >= $Y_Bounds)
							{
								$Extent = $Z_Bounds;
							}


						$Dup_Obj = `duplicate $Selected_Obj`;

						float $Obj_Center[] = `objectCenter -gl`;//location of crack

						if ($Crop_Fracture == 1)
							{
								//adjust Center of cutting plane
								//
								float $Adjusted_X = ($Obj_Bounds[0] + ($X_Bounds * (.01 * $Bias_percent)));
								float $Adjusted_Y = ($Obj_Bounds[2] + ($Y_Bounds * (.01 * $Bias_percent)));
								float $Adjusted_Z = ($Obj_Bounds[4] + ($Z_Bounds * (.01 * $Bias_percent)));
								$Obj_Center = {$Adjusted_X , $Adjusted_Y, $Adjusted_Z};
							}


						string $Crack_Plane;


						if ($CutType == "Spline")
							{
								$FractureCutMethod = 1; //force boolean cutstyle
								$Crack_Plane = "Fracture_SplinePlane";
								//error;
                            }

						if ($CutType == "Auto" && $Force_CuttingPlane == 0)
							{
								$Crack_Plane = Create_Fracture_Object($Obj_Center, $Extent);//create fracture plane
							}

						if ($Force_CuttingPlane == 1 && (`objExists $Preview_Plane[0]` == 1) )
							{
								$Dup_Preview_Plane = `duplicate $Preview_Plane[0]`;
								$Crack_Plane = $Dup_Preview_Plane[0];
							}

						//Set Random Rotation on Plane
						//
						float $Rand_RotX;
						float $Rand_RotY;
						float $Rand_RotZ;
						if ($Force_CuttingPlane == 0)
							{
								$Rand_RotX  = `rand ($Rand_Rot * -1) $Rand_Rot `;
								$Rand_RotY  = `rand ($Rand_Rot * -1) $Rand_Rot `;
								$Rand_RotZ  = `rand ($Rand_Rot * -1) $Rand_Rot `;
							}
						//Set Bias Rotation

						if ($Crop_Fracture == "1")
							{
								$Preview_Plane_Rotation = `xform -q -ro $Preview_Plane`;
								$Rand_RotX  = $Preview_Plane_Rotation[0];
								$Rand_RotY  = $Preview_Plane_Rotation[1];
								$Rand_RotZ  = $Preview_Plane_Rotation[2];
							}

						if ($CutType == "Spline")
							{
								$Rand_RotY  = 0;
								$Rand_RotZ  = 0;
								$Rand_RotX  = 0;
							}

						if ($Force_CuttingPlane == 0 )
							{
								rotate -ws $Rand_RotX  $Rand_RotY  $Rand_RotZ $Crack_Plane;
							}

						if ($Force_CuttingPlane == 1 && (`objExists $Preview_Plane[0]` == 0) )
							{
								rotate -ws $Rand_RotX $Rand_RotY $Rand_RotZ $Crack_Plane;
							}

						//Duplicate Cutting Plane
						//
						$Dup_Plane = `duplicate $Crack_Plane`;
						polyNormal -normalMode 3 -ch 0 $Dup_Plane[0];


						//Boolean the Object
						//
						string $Bool_A[];
						string $Bool_B[];
						print $FractureCutMethod;
						if ($FractureCutMethod == 1)//boolean
						{
							catchQuiet ($Bool_A = `polyBoolOp -n $Chunk_Name -op 2 -ch 0 $Selected_Obj $Crack_Plane`);//this is the Top
							catchQuiet ($Bool_B = `polyBoolOp -n $Chunk_Name -op 2 -ch 0 $Dup_Obj $Dup_Plane`);//this is the Bottom
						}


						//polycut the object
						if ($FractureCutMethod == 2)//polycut
						{
							if ($Force_CuttingPlane == 1 && (`objExists $Preview_Plane[0]` == 1) )
							{
								$Preview_Plane_Rotation = `xform -q -ro $Preview_Plane`;
								$Rand_RotX  = ($Preview_Plane_Rotation[0] + 90); //add 90 to rotation for plane adjustment
								$Rand_RotY  = $Preview_Plane_Rotation[1];
								$Rand_RotZ  = $Preview_Plane_Rotation[2];
								//print $Preview_Plane_Rotation;
							}


							delete $Crack_Plane $Dup_Plane;
							$CutA = `polyCut  -ch 0 -df 1 -pc $Obj_Center[0] $Obj_Center[1] $Obj_Center[2] -rx $Rand_RotX -ry $Rand_RotY -rz $Rand_RotZ -ps 1000 1000 $Selected_Obj`;
							$Bool_A = $Selected_Obj;
							int $numFace[] = `polyEvaluate -f $Bool_A`;

							if ($numFace[0] == 1)
									{
										delete $CutA;
                                    }

							if ($numFace[0] != 1 && $Fill_Holes == 1)
								{
									//polyCloseBorder -ch 0 $Bool_A;
									select $Bool_A;
									Fracture_Cap_Flat();
								}


							$CutB = `polyCut  -ch 0 -df 1 -pc $Obj_Center[0] $Obj_Center[1] $Obj_Center[2] -rx ($Rand_RotX + 180 ) -ry ($Rand_RotY ) -rz ($Rand_RotZ ) -ps 1000 1000 $Dup_Obj `;
							$Bool_B = $Dup_Obj;

							int $numFace[] = `polyEvaluate -f $Bool_B`;

							if ($numFace[0] == 1)
									{
										delete $CutB;
                                    }

							if ($numFace[0] != 1 && $Fill_Holes == 1)
								{
									//polyCloseBorder -ch 0 $Bool_B;
									select $Bool_B;
									Fracture_Cap_Flat();
								}

						}//end if Fracture polycut

						$FaceCountA = `polyEvaluate -f $Bool_A[0]`;
						$FaceCountB = `polyEvaluate -f $Bool_B[0]`;

						//check if object is the same
						vector $CenterA = `objectCenter $Bool_A[0]`;
						vector $CenterB = `objectCenter $Bool_B[0]`;
						$AreaA = `polyEvaluate -a $Bool_A[0]`;
						$AreaB = `polyEvaluate -a $Bool_B[0]`;
						float $BoundsA[] = `exactWorldBoundingBox $Bool_A[0]`;
						float $BoundsB[] = `exactWorldBoundingBox $Bool_B[0]`;


						if ($CutType == "Spline")
							{
								//duplicate geometry might occur in multi-spline cut so check only in spline cut
								if ($FaceCountA[0] == $FaceCountB[0] && $CenterA == $CenterB && $AreaA[0] == $AreaB[0] && $BoundsA[0] == $BoundsB[0] &&  $BoundsA[1] == $BoundsB[1] &&  $BoundsA[2] == $BoundsB[2] &&  $BoundsA[3] == $BoundsB[3] &&  $BoundsA[4] == $BoundsB[4] &&  $BoundsA[5] == $BoundsB[5])
									{
										delete $Bool_B;//delete duplicate if boolean is bad
										print ($Bool_B[0] + " has been deleted because the object is the same");
									}

                            }


						//check if object has no faces
						//
						if ($FaceCountA[0] < 1 && `objExists $Bool_A[0]` )
							{
								delete $Bool_A;
								print ($Bool_A[0] + " Resulting Object has no Faces");
								//undo;
								//error;
                            }

						//check if object has no faces
						//
						if ($FaceCountB[0] < 1 && `objExists $Bool_B[0]` )
							{
								delete $Bool_B;
							    print ($Bool_B[0] + " Resulting Object has no Faces");
								//undo;
								//error;

                            }

						if ($Crop_Fracture == "0") //fracture center
							{

								if (`objExists $Bool_A[0]`)
								{
									stringArrayInsertAtIndex(0, $Chunks, $Bool_A[0]);
								}

                                if (`objExists $Bool_B[0]`)
								{
									stringArrayInsertAtIndex(0, $Chunks, $Bool_B[0]);
								}

								$Crop_Fracture = 0;
							}

						if ($Crop_Fracture == "1" && $Bias_percent >= 50 ) //fracture top
							{
								if (`objExists $Bool_A[0]`)
								{
									stringArrayInsertAtIndex(0, $Chunks, $Bool_A[0]);
								}
								$Crop_Fracture = 0;
							}


						if ($Crop_Fracture == "1" && $Bias_percent < 50 ) //fracture bottom
							{
								if (`objExists $Bool_B[0]`)
								{
									stringArrayInsertAtIndex(0, $Chunks, $Bool_B[0]);
								}
								$Crop_Fracture = 0;
							}

						//Seperate Chunks
						//
						if ($Seperate_Chunks == 1)
							{
								for ($s = 0; $s < `size $Chunks`; $s++)
									{
										if (`objExists $Chunks[$s]`)//check to see if object still exists
											{
												select $Chunks[$s];
												string $New_Chunks[] = BK_Seperate_Chunks();
												appendStringArray ($Chunks,$New_Chunks, `size $New_Chunks`);
											}//end if


									}//end for $s

							}//end if seperate chunks



						//find the biggest chunk
						//
						float $LastChunk_Area[]= {0};
						float $Chunk_Area[];
							for ($c = 0; $c < `size $Chunks`; $c++)
									{
										if (`objExists $Chunks[$c]`)//check to see if object still exists
										{
											catchQuiet ($Chunk_Area = `polyEvaluate -a $Chunks[$c]` );//get the area
											if ($Chunk_Area[0] >= $LastChunk_Area[0])
												{
													$LastChunk_Area = $Chunk_Area;
													select -r $Chunks[$c];
												}//end if
										}//end if exists


									}//end for c



						//Delete Slivers
						//
						if ($Delete_Slivers == 1)
							{
								for ($d = 0; $d < `size $Chunks`; $d++)
									{
										if (`objExists $Chunks[$d]`)//check to see if object still exists
											{
												float $Chunk_Area[] = `polyEvaluate -a $Chunks[$d]`;
												if ($Chunk_Area[0] < ($Object_Area[0] * ($Sliver_Size *.01) ) )
													{
														delete $Chunks[$d];
													}
											}//end if
									}//end for $s
							}//end if delete slivers


							refresh -f;

					$totalTime = `timerX -startTime $startTime`;
					if ($CutType != "Spline")
						{
							progressBar -edit -step 1 Fracture_progress;
							text -e -l ("Fracture Progress " + ($b + 1) + " out of " + $Cuts + "     elapsed time: " + $totalTime )progressText;
					   	}

					}//end for b
				}//end if


				//Rename Chunks and center pivots and set normal angle
				//
				$Chunk_Array = {};
				for ($r = 0; $r < `size $Chunks`; $r++)
					{
						if (`objExists $Chunks[$r]`)//check to see if object still exists
							{
								$Chunk = `rename $Chunks[$r] $Chunk_Name`;
								stringArrayInsertAtIndex(0, $Chunk_Array, $Chunk);
								xform -cp $Chunk;//Centers pivot
								//polySoftEdge -angle 30 -ch 1 $Chunk;
							}//end if objExists
					}//end for r

				//Group Chunks
				//
				if ($Create_Group == 1)
					{
						group -name $Fracture_Group $Chunk_Array;
					}


			}//end for o



	//Extrude PolyCut on chunks
	//
	if ($FractureCutMethod == 2 && $PolyCut_Extrude != 0)//polycut
		{
			for ($e = 0; $e < `size $Chunk_Array`; $e++)
			{
				polySelectConstraint -m 0 -bo false -sh false -cr false;//reset contraint selection
				select $Chunk_Array[$e];
    			ConvertSelectionToEdges;
				polySelectConstraint -m 2 -bo true -sh false -cr false; ///select border edges
				polyExtrudeEdge -constructionHistory 1 -keepFacesTogether 1 -ltz ($PolyCut_Extrude * -1) -pvx 0 -pvy 0 -pvz 0 -divisions 1 -twist 0 -taper 1 -smoothingAngle 30 ;
				polySelectConstraint -m 0 -bo false -sh false -cr false;//reset contraint selection
				//error;
			}
		}


	//delete bad cut objects
	if (`objExists "Fracture_Chunk*"`)
	{
		select "Fracture_Chunk*";
		select -d "*Shape*";
		$Test_Chunks = `ls -sl -fl`;
		for ($c = 0; $c < `size $Test_Chunks`; $c++)
		{
			select $Test_Chunks[$c];
			ConvertSelectionToFaces;
			$Faces = `ls -sl -fl`;
			if (`size $Faces` < 2)
				{
					delete $Test_Chunks[$c];
				}
    	}
	}

	select $Chunk_Array;
	return $Chunk_Array;

}//end proc

///////////////////////////////////////////////////////////////////////////////////////////////////BK_RE_Break
global proc BK_RE_Fracture()
{
	$Undo_Search = `undoInfo -q -un`;//check last undo call
	if ($Undo_Search == "Plane_Fracture Auto")
		{
			undo;
			Plane_Fracture Auto;
		}//end if

	if ($Undo_Search == "BK_RE_Fracture()")
		{
			undo;
			Plane_Fracture Auto;
		}//end if

	else
		{
			print "no fracture to undo";
		}//end else
}//end proc


global proc string[] Fracture_Spline_Cut(string $splinecount)
{
	string $Splines[] = `textScrollList -q -ai spline_list`;
	$Seperate_Chunks =`checkBox -q -v cb_Seperate_Chunks`;
	$Cut_UDivisions = `intSliderGrp   -q -v fF_SplineCutUSegments`;
	$Cut_VDivisions = `intSliderGrp   -q -v fF_SplineCutVSegments`;
	$Cut_Noise = `floatSliderGrp   -q -v fF_SplineCutNoise`;
	$Fracture_Triangulate = `checkBox  -q -v  cb_Fracture_Triangulate`;

	Clean_Spline_Preview();
	string $Selection[] = `ls -sl -fl -l`;
	select -d $Selection[0];//selection [0] is the spline
	string $Selected_Obj[] = `ls -sl -fl -l`;
	string $Chunks[] = {};
	string $Chunk_Array[] = {};
	string $Total_Pieces[] = {};
	$Total_Pieces = $Selected_Obj;


	if ($Seperate_Chunks == 1)
		{

			for ($i = 0; $i < `size $Selected_Obj`; $i++)
			{
				select -d $Selected_Obj[0];
				select $Selected_Obj[$i];
				string $New_Chunks[] = BK_Seperate_Chunks();
				appendStringArray($Total_Pieces, $New_Chunks, `size $New_Chunks`);
            }
		}//end if

	if (`size $Total_Pieces` == 0 )
		{
			appendStringArray($Total_Pieces, $Selected_Obj, 1);
    	}


	float $Obj_Bounds[] = `polyEvaluate -b $Selected_Obj`;//xmin, xmax, ymin, ymax, zmin, zmax.
	for ($c = 0; $c < `size $Total_Pieces`; $c++)
	{

		if (`objExists $Total_Pieces[$c]`)
		{
		//select $Total_Pieces[$c];
			if ($splinecount == "Single")
			{
				$Obj_Bounds = `polyEvaluate -b $Total_Pieces[$c]`;//xmin, xmax, ymin, ymax, zmin, zmax.
			}

        float $X_Bounds = ($Obj_Bounds[1] - $Obj_Bounds[0]);
		float $Y_Bounds = ($Obj_Bounds[3] - $Obj_Bounds[2]);
		float $Z_Bounds = ($Obj_Bounds[5] - $Obj_Bounds[4]);
		float $Cut_Length = $X_Bounds;

		//Find the Longest Length
		if ($X_Bounds > $Y_Bounds && $X_Bounds > $Z_Bounds)
			{
				$Cut_Length = $X_Bounds;
			}

		if ($Y_Bounds > $X_Bounds && $Y_Bounds > $Z_Bounds)
			{
				$Cut_Length = $Y_Bounds;
			}

		if ($Z_Bounds > $X_Bounds && $Z_Bounds > $Y_Bounds)
			{
				$Cut_Length = $Z_Bounds;
			}


		$Start_Spline =  $Selection[0];
		$End_Spline = `duplicate $Selection[0]`;


		makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $Total_Pieces[$c];

		float $Start_Spline_Position[];
		if ($splinecount == "Single")
			{
				//$Start_Spline_Position = `xform -q -piv -ws $Start_Spline`;// x y z x y z
				$Start_Spline_Position = `objectCenter  $Start_Spline`;//use objet center because the pivot could be at zero which causes a crash
			}

		if ($splinecount == "Multi")
			{
				$Spline_Bounds = `exactWorldBoundingBox $Splines`;//	xmin, ymin, zmin, xmax, ymax, zmax.
				//print $Spline_Bounds;
				float $CenterX = (($Spline_Bounds[0] + $Spline_Bounds [3]) /2);
				float $CenterY = (($Spline_Bounds[1] + $Spline_Bounds [4]) /2);
				float $CenterZ = (($Spline_Bounds[2] + $Spline_Bounds [5]) /2);
				$Start_Spline_Position = {$CenterX, $CenterY, $CenterZ};
			}

		if ($Start_Spline_Position[0] <= $Obj_Bounds[0] )//xmin
			{
				move -r ($Cut_Length * 2) 0 0 $End_Spline ;
			}

		if ($Start_Spline_Position[0] >= $Obj_Bounds[1] )//xmax
			{
				move -r ($Cut_Length * -2) 0 0 $End_Spline  ;
			}

		if ($Start_Spline_Position[1] <= $Obj_Bounds[2] )//ymin
			{
				move -r 0 ($Cut_Length * 2) 0 $End_Spline;
			}

		if ($Start_Spline_Position[1] >= $Obj_Bounds[3] )//ymax
			{
				move -r 0 ($Cut_Length * -2) 0 $End_Spline ;
			}

		if ($Start_Spline_Position[2] <= $Obj_Bounds[4] )//zmin
			{
				move  -r 0 0 ($Cut_Length * 2) $End_Spline;
			}

		if ($Start_Spline_Position[2] >= $Obj_Bounds[5] )//zmax
			{
				move -r 0 0 ($Cut_Length * -2) $End_Spline;
			}

		$Spline_Loft = `loft -name "Fracture_SplinePlane" -ch 1 -u 1 -c 0 -ar 1 -d 1 -ss 1 -rn 0 -po 1 -rsn true $Start_Spline $End_Spline`;

		string $modifier[] = `listHistory`;
		$total_modifiers = (`size($modifier)`);

		setAttr ($modifier[$total_modifiers - 4] + ".format") 2;
		setAttr ($modifier[$total_modifiers - 4] + ".vNumber") $Cut_VDivisions;
		setAttr ($modifier[$total_modifiers - 4] + ".uNumber") $Cut_UDivisions;

		$NoiseModifier = `polyMoveVertex -constructionHistory 1 -random 1`;
		setAttr ($NoiseModifier[0] + ".localTranslate") -type double3 0 0 $Cut_Noise;

		 if ($Fracture_Triangulate == 1)
		 {
			 polyTriangulate -ch 1 "Fracture_SplinePlane";
			 //error;
         }
		//error;
		xform -cp;
		delete -ch;
		select $Total_Pieces[$c];
		$Chunks = Plane_Fracture("Spline");
		appendStringArray($Chunk_Array, $Chunks, `size $Chunks`);
		delete $End_Spline;
		}//end if obj exists
	}//end for

	checkBox -e -v 0 cb_Preview_Spline_Cut;
return $Chunk_Array;

}//end proc


global proc Fracture_Add_Splines()
{
	textScrollList -e -ra spline_list;
	$sel =  `ls -sl -fl`;
	for ($i = 0; $i < (`size $sel`); $i++)
		{
			textScrollList -e -append $sel[$i] spline_list;
        }
}

global proc Fracture_Remove_Splines()
{
	textScrollList -e -ra spline_list;
}

global proc Fracture_Create_Radial()
{

	$Radial_CreateSplines = `checkBox -q -v cb_Radial_CreateSplines`;
	$Radial_CreateLocators = `checkBox -q -v cb_Radial_CreateLocators`;
	$Max_Radius =   `floatSliderGrp -q -v fF_Ring_Radius`;
	float $Ring_Noise =   `floatSliderGrp -q -v fF_Ring_Noise`;
	$Num_Rings =    `intSliderGrp   -q -v fF_Number_Rings`;
	$Num_Ring_Seg = `intSliderGrp   -q -v fF_Number_Rings_Seg`;
	//$Num_Radials =  `intSliderGrp   -q -v fF_Number_Radials`;

	if (`objExists "Radial_Locator_Pattern"`)
		{
			delete "Radial_Locator_Pattern";
		}

	if (`objExists "Radial_Spline_Pattern"`)
		{
			delete "Radial_Spline_Pattern";
		}

	string $Radial_Splines[] = {};
	string $Radial_Locators[] = {};
	//create Rings
	string $Locator[] ={};
	float $Radial_Dist = ($Max_Radius / $Num_Rings);
	for ($i = 1; $i < ($Num_Rings + 1); $i++)
		{

			string $Radial_Spline[] = `circle -name "Fracture_Ring" -ch on -sw 359 -o on -r ($Radial_Dist * $i)`;
			rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 2 -kcp 0 -kep 1 -kt 0 -s $Num_Ring_Seg -d 1 -tol 0 $Radial_Spline[0];
			closeCurve -ch 1 -ps 1 -rpo 1 -bb 0.5 -bki 0 -p 0.1 $Radial_Spline[0];
			float $Random_Move = `rand ($Ring_Noise * -1 ) ($Ring_Noise )`;

			for ($m = 0; $m < $Num_Ring_Seg; $m++)
			{
				move -r $Random_Move $Random_Move $Random_Move ($Radial_Spline[0] + ".ep[" + $m + "]");
				$Point_Location = `xform -q -t ($Radial_Spline[0] + ".ep[" + $m + "]")`;
				$Locator = `spaceLocator -name "Voronoi_Fracture_Locator" -p $Point_Location[0] $Point_Location[1] $Point_Location[2]`;
				xform -cp $Locator;
				stringArrayInsertAtIndex(0, $Radial_Locators, $Locator[0]);
			}//end for
			rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 2 -kcp 0 -kep 1 -kt 0 -s $Num_Ring_Seg -d 1 -tol 0 $Radial_Spline[0];
			stringArrayInsertAtIndex(0, $Radial_Splines, $Radial_Spline[0]);

    	}//end for

	//create Radials
	for ($j = 0; $j < ($Num_Ring_Seg / 2); $j++)
		{
			string $Line = `curve -name "Fracture_Radial_01" -d 1 -p ($Max_Radius * -1) ($Max_Radius * -1) 0 -p $Max_Radius $Max_Radius 0 -k 0 -k 1 `;
			rotate 0 0 ((180 / ($Num_Ring_Seg /2)) * $j ) $Line;
			rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 16 -d 1 -tol 0 $Line;
			for ($m = 0; $m < 16; $m++)
			{
				float $Random_Move = `rand ($Ring_Noise * -1) $Ring_Noise`;
				move -r $Random_Move $Random_Move $Random_Move ($Line + ".ep[" + $m + "]");
			}//end for

		stringArrayInsertAtIndex(0, $Radial_Splines, $Line);
    	}//end for

	if ($Radial_CreateSplines ==1)
	{
		group -n "Radial_Spline_Pattern" $Radial_Splines;
	}
	else
	{
		delete $Radial_Splines;
    }

	if ($Radial_CreateLocators == 1)
	{
		group -n "Radial_Locator_Pattern" $Radial_Locators;
	}

	else
	{
		delete $Radial_Locators;
	}

}

global proc Fracture_MultiSpline_Cut()
{

	string $Splines[] = `textScrollList -q -ai spline_list`;
	string $Selected_Mesh[] = `ls -sl -fl -l`;
	string $Chunk_Array[] = $Selected_Mesh;
	//print $Chunk_Array;
	$Group = `checkBox -q -v CB_Group_Chunks`;
	$Fracture_Group = `textField -q -tx TF_Fracture_Group_Name`;

	if($Group == 1)
		{
			checkBox -e -v 0 CB_Group_Chunks;
        }

	$startTime = `timerX`;
	progressBar -edit -pr 0 Fracture_progress;//reset progress bar to 0
	progressBar -edit -maxValue (`size $Splines`) Fracture_progress;

	for ($i = 0; $i < (`size $Splines`); $i++)
		{
			select -r $Splines[$i];//this is the spline
			for ($s = 0; $s < (`size $Chunk_Array`); $s++)
				{
					if (`objExists $Chunk_Array[$s]` == 1)
						{

								select -add $Chunk_Array[$s];

                        }
                }

			//error;
			string $Chunks[] = Fracture_Spline_Cut ("Multi");

			//print $Chunks;
			appendStringArray($Chunk_Array, $Chunks, `size $Chunks`);
			hide $Splines[$i];

			$totalTime = `timerX -startTime $startTime`;
			progressBar -edit -step 1 Fracture_progress;
			text -e -l ("Fracture Progress " + ($i + 1) + " out of " + `size $Splines` + "     elapsed time: " + $totalTime )progressText;
		}

	if($Group == 1)
		{
			checkBox -e -v 1 CB_Group_Chunks;
        }

}

global proc BK_Detach_Face()
{
$Original_Object = `ls -hl`;


string $faces[];
/////////////////////find faces
string $faces[];
string $obj;
	for ($obj in `ls -sl -fl`)
    	{
        	string $buf[];
            int $ntokens = `tokenize $obj "." $buf`;
            if (startsWith($buf[1], "f"))
            	{
                	$faces[`size($faces)`] = $obj;
              	}
        }
/////////////////////end find faces

InvertSelection;

/////////////////////find invert faces
		string $invertfaces[];
    	string $obj;
    	for ($obj in `ls -sl -fl`)
       {
              string $buf[];
              int $ntokens = `tokenize $obj "." $buf`;
              if (startsWith($buf[1], "f"))
              {
                     $invertfaces[`size($invertfaces)`] = $obj;
              }
       }
/////////////////////end find invert faces


////duplicate mesh
select $Original_Object[0];
duplicate;
$Copy_Mesh =`ls -sl`;


//////delete original object faces
select -cl;
string $face_numbers[];
string $deleteArray[];
for ($f = 0; $f < `size $faces`; $f++)
	{
		tokenize $faces[$f] "." $face_numbers;
		//print $face_numbers[1];
		stringArrayInsertAtIndex(1, $deleteArray,( $Original_Object[0] + "." + $face_numbers[1]));
		//select -add ( $Original_Object[0] + "." + $face_numbers[1]);
	}
delete $deleteArray;

//////delete copy faces
string $invertface_numbers[];
string $deleteinvertArray[];
for ($f = 0; $f < `size $invertfaces`; $f++)
	{
		tokenize $invertfaces[$f] "." $invertface_numbers;
		//print $face_numbers[1];
		stringArrayInsertAtIndex(1, $deleteinvertArray,( $Copy_Mesh[0] + "." + $invertface_numbers[1]));
	}
delete $deleteinvertArray;
select $Copy_Mesh[0];
}



global proc Fracture_Detach_and_Cap()
{
	$Base_Mesh = `ls -hl`;
	BK_Detach_Face();
	$Detached_Mesh = `ls -sl -sn`;
	select -r $Base_Mesh[0];
	select -add $Detached_Mesh[0];
	Fracture_Cap_Holes();
	select $Detached_Mesh[0];
	xform -cp $Detached_Mesh[0];

} //end procedure

//////////////////////////////////////////////////////////////////////////////////////// Chip Off  ///////////////////////////////////////////////////////////////////////////////////////////
//																																															//
//																																															//
//																																															//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////Create Chip






global proc string[] Create_Chip()
{
	$Chip_Size =((`floatSliderGrp -q -value fF_Chip_Size`) / 2);
	floatSliderGrp -e -maxValue ($Chip_Size /2)  -fieldMinValue ($Chip_Size /2) fF_Chip_Noise;

	float $Chip_Noise = `floatSliderGrp -q -value fF_Chip_Noise`;

	if ($Chip_Noise > ($Chip_Size /2))
		{
			$Chip_Noise = ($Chip_Size /2);
			floatSliderGrp -e -v ($Chip_Size /2) fF_Chip_Noise;
        }


	$Chip_Mesh = `polyCube -name "Fracture_PreviewChip" -ch on -o on -ax 0 0 1 -w $Chip_Size  -h $Chip_Size  -d $Chip_Size  -cuv 4` ;
	polySmooth  -mth 1 -dv 1 -c 0.5 -kb 1 -ksb 1 -khe 1 -kt 0 -kmb 0 -suv 1 -sl 1 -dpe 1 -ps 1 -ro 0 -ch 1 $Chip_Mesh;
	ConvertSelectionToVertices;
	$Selected_Verts = `ls -sl -fl`;
		for ($v = 0; $v < `size $Selected_Verts`; $v++)
			{
				$Displace = `rand 0 $Chip_Noise`;
				move -r $Displace $Displace  $Displace $Selected_Verts[$v];
			}//end for $v
	//polySmooth  -mth 1 -dv 1 -c 0.5 -kb 1 -ksb 1 -khe 1 -kt 0 -kmb 0 -suv 1 -sl 1 -dpe 1 -ps 1 -ro 2 -ch 1 $Chip_Mesh;
	xform -cp $Chip_Mesh;
	return $Chip_Mesh;
}//end Create_Chip


///////////////////////////////////////////////////////////////////////////////////////////////////Chip Off (Random or Selection)

global proc string[] Fracture_ChipOff(string $Type)
{
	Clean_Preview_Chip();
	$Keep_Chips = `checkBox -q -v cb_Keep_Chips`;
	$Number_Chips =`intSliderGrp -q -value fF_Number_Chips` ;
	$Component_Type =`radioButtonGrp -q -select  rbg_Component`;
	progressBar -edit -maxValue $Number_Chips Fracture_progress;
	progressBar -edit -pr 0 Fracture_progress;//reset progress bar to 0
	string $Selected_Obj[];
	string $Chip_Array[] = {};
	string $New_Chip_Array[] = {};
	string $Selected_Objects[] = {};
	string $Selected_Component[];

	if ($Type == "Random")
	{
		$Selected_Objects = `ls -sl -fl`;
    }//end if

	if ($Type == "Selection")
	{
		$Selected_Objects = `ls -hl`;
		$Selected_Component =`ls -sl -fl`;
		progressBar -edit -maxValue (`size $Selected_Component`) Fracture_progress;
	}//end if

	$startTime = `timerX`;


	for ($i = 0; $i < `size $Selected_Objects`; $i++)
		{
			//print $i;
			select -r $Selected_Objects[$i];
			$Selected_Obj = `ls -sl -fl`;
			$Original_Name = `ls -sl -fl`;

			if ($Type == "Random")
				{
					//set component selection
					//
					if ($Component_Type == 1)
						{
							ConvertSelectionToVertices;
						}

					if ($Component_Type == 2)
						{
							ConvertSelectionToEdges;
						}

					if ($Component_Type == 3)
						{
							ConvertSelectionToFaces;
						}

					$Selected_Component =`ls -sl -fl`;

                }

			$Total_Verts = `size $Selected_Component`;
			$Chip_Mesh = Create_Chip();
			string $Chip_Array[] = {};
			string $Random_Verts_Array[] ={};

			if ($Type == "Selection")
				{
					$Random_Verts_Array = $Selected_Component;
				}//end if


			if ($Type == "Random")
			{
				//get random verts
				//
				while (`size $Random_Verts_Array` < $Number_Chips)
				{

					int $Random_Vert = `rand 0 $Total_Verts`;
					if (stringArrayContains ($Selected_Component[$Random_Vert] , $Random_Verts_Array) != 1)
						{
							stringArrayInsertAtIndex(0, $Random_Verts_Array, $Selected_Component[$Random_Vert]); //add chips to an array
						}//end if
				}//end while

            }//end if


			//Move chip mesh to vert locations
			//
			for ($c = 0; $c < `size $Random_Verts_Array`; $c++)
				{

					$Chipper = `duplicate $Chip_Mesh[0]`;
					//add random rotation to chip
					//
					$Random_rotation = `rand -90 90`;
					rotate $Random_rotation $Random_rotation $Random_rotation $Chipper;

					stringArrayInsertAtIndex(0, $Chip_Array, $Chipper[0]); //add chips to an array
					$Vert_Location = `xform -q -ws -bb $Random_Verts_Array[$c]`;

					float $Mid_X =(($Vert_Location[3] - $Vert_Location [0]) / 2);
					float $Mid_Y =(($Vert_Location[4] - $Vert_Location [1]) / 2);
					float $Mid_Z =(($Vert_Location[5] - $Vert_Location [2]) / 2);

					move -r ($Vert_Location [0] + $Mid_X) ($Vert_Location [1] + $Mid_Y) ($Vert_Location [2] + $Mid_Z) $Chipper;
				}//end for

			//Start chipping away
			//
			for ($b = 0; $b < `size $Chip_Array`; $b++)
				{
					if ($Keep_Chips == 1)
							{
								$Chipper = `duplicate $Chip_Array[$b]`;
								$Chip_Master = `duplicate $Selected_Obj[0]`;
								$Chip_Object =`polyBoolOp -op 3 -ch 0 $Chip_Master $Chipper`;
								xform -cp $Chip_Object;//Centers pivot
								$Chip_Name = `rename $Chip_Object "Fracture_Chip"`;
								stringArrayInsertAtIndex(0, $New_Chip_Array, $Chip_Name);
							}

					$Selected_Obj = `polyBoolOp -op 2 -ch 0 $Selected_Obj[0] $Chip_Array[$b]`;
					refresh -f;
					progressBar -edit -step 1 Fracture_progress;
					$totalTime = `timerX -startTime $startTime`;
					text -e -l ("Fracture Progress " + ($b + 1) + " out of " + `size $Chip_Array` + "     elapsed time: " + $totalTime )progressText;
				}//end for

			//rename to original name
			//
			rename $Selected_Obj $Original_Name;

			//center pivot
			//
			xform -cp ;//Centers pivot

			delete $Chip_Mesh;

	}//end for i
return $New_Chip_Array;
}//end proc Fracture_ChipOff()

///////////////////////////////////////////////////////////////////////////////////////////////////BK_RE_Chip

global proc Fracture_Re_ChipOff()
{
	$Undo_Search = `undoInfo -q -un`;//check last undo call
	if ($Undo_Search == "Fracture_ChipOff Random")
		{
			undo;
			Fracture_ChipOff Random;
		}//end if

	if ($Undo_Search == "Fracture_Re_ChipOff()")
		{
			undo;
			Fracture_ChipOff Random;
		}//end if

	else
		{
			print "no chip to undo";
		}//end else
}//end proc Fracture_Re_ChipOff()


///////////////////////////////////////////////////////////////////////////////////////////////////Fracture Seperate
global proc Fracture_Seperate()
{

	int $Distance = `floatSliderGrp -q -v FF_Fracture_Seperate`;

	//get Center of broken objects
	$Selected_Objects = `ls -sl -fl`;

	group -name "temp_group";

	$Center =`objectCenter "temp_group"`;
	$Selected_Extents = `exactWorldBoundingBox`;

	ungroup "temp_group";

	float $CenterX = (($Selected_Extents[1] + $Selected_Extents[0]) /2);
	float $CenterY = (($Selected_Extents[3] + $Selected_Extents[2]) /2);
	float $CenterZ = (($Selected_Extents[5] + $Selected_Extents[4]) /2);

	float $Size_X = ($Selected_Extents[1] - $Selected_Extents[0]);
	float $Size_Y = ($Selected_Extents[3] - $Selected_Extents[2]);
	float $Size_Z = ($Selected_Extents[5] - $Selected_Extents[4]);

	$average_size = ( ($Size_X + $Size_Y + $Size_Z) /3);

	//Create Particle Emitter
	$Fracture_emitter = `emitter -n "Fracture_Emitter" -pos $Center[0] $Center[1] $Center[2] -type omni -r ($average_size * 1000) -sro 0 -nuv 0 -cye none -cyi 1 -spd ($average_size /2) -srn 0 -nsp 1 -tsp 0 -mxd 0 -mnd 0 -dx 1 -dy 0 -dz 0 -sp 0 `;
	//error;
	$Fracture_particle = `particle -n "Fracture_Particle"`;
	setAttr ($Fracture_particle[0] + ".maxCount") (`size $Selected_Objects`);
	connectDynamic -em $Fracture_emitter[0] $Fracture_particle[0];
		for ($s = 0; $s < 5; $s++ )
		{
			currentTime $s;
		}
		currentTime $Distance;

	string $objectList;
	for ( $i = 0; $i < `size $Selected_Objects` ; $i++ )
	{
		$objectList += "-object " + $Selected_Objects[$i];
	}

	//indexPP (float)
	//addAttr -ln indexPP0 -dt doubleArray ( $partName + "Shape" );
	addAttr -ln indexPP -dt doubleArray ( $Fracture_particle[1] );
	//setAttr -e -keyable true ( $partName + "Shape" + ".indexPP" );

	//eval ( "particleInstancer -addObject " + $objectList + " -cycle None -cycleStep 1 -cycleStepUnits Frames -levelOfDetail Geometry -rotationUnits Degrees -rotationOrder XYZ -position worldPosition -age age -objectIndex indexPP"  );
	//particleInstancer  -addObject -object $Selected_Objects -cycle None -cycleStep 1 -cycleStepUnits Frames -levelOfDetail Geometry -rotationUnits Degrees -rotationOrder XYZ -position worldPosition -age age particleShape1;
	//Explode the chunks outward from center
	if ($Distance > 0)
	{
		for ($s = 0; $s < `size $Selected_Objects`; $s++)
			{


 				float $Particle_Location[] = `xform -q -ws -t ($Fracture_particle[0] + ".pt[" + $s + "]")`;

 				//select $Selected_Objects[$s];
 				$Chunk_Location = `xform -q -ws -piv  $Selected_Objects[$s]`;
 				move -r ($Chunk_Location[0] * -1) ($Chunk_Location[1] * -1) ($Chunk_Location[2] * -1)  $Selected_Objects[$s];
 				makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 -jointOrient  $Selected_Objects[$s];
 				move -r $Particle_Location[0] $Particle_Location[1] $Particle_Location[2]  $Selected_Objects[$s];
			}
	}

	//Move Z Back to min Z start
	select $Selected_Objects;
	$Seperated_Extents = `polyEvaluate -b $Selected_Objects`;
	move -r 0 0 ($Seperated_Extents[4] * - 1);


	//delete $Fracture_emitter;
	//delete $Fracture_particle;

}

global proc Fracture_RE_Seperate()
{

	int $Distance = `floatSliderGrp -q -v FF_Fracture_Seperate`;


	for ($s = 0; $s < 3; $s++ )
		{
			currentTime $s;
		}
	currentTime $Distance;
	$Selected_Objects = `ls -sl -fl`;
	for ($s = 0; $s < `size $Selected_Objects`; $s++)
			{


 				float $Particle_Location[] = `xform -q -ws -t ("Fracture_Particle" + ".pt[" + $s + "]")`;

 				//select $Selected_Objects[$s];
 				$Chunk_Location = `xform -q -ws -piv  $Selected_Objects[$s]`;
 				move -r ($Chunk_Location[0] * -1) ($Chunk_Location[1] * -1) ($Chunk_Location[2] * -1)  $Selected_Objects[$s];
 				makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 -jointOrient  $Selected_Objects[$s];
 				move -r $Particle_Location[0] $Particle_Location[1] $Particle_Location[2]  $Selected_Objects[$s];
			}
		refresh -f;
	/*
	$Undo_Search = `undoInfo -q -un`;//check last undo call
	if ($Undo_Search == "Fracture_Seperate()")
		{
			undo;
			Fracture_Seperate();
		}
	if ($Undo_Search == "Fracture_RE_Seperate()")
		{
			undo;
			Fracture_Seperate();
		}
	*/
}
///////////////////////////////////////////////////////////////////////////////////////////////////Fracture Explode
global proc Adjust_Explode()
{
	$Radial_Magnitude = `floatSliderGrp -q -v fF_Radial_Magnitude`;
	$Radial_Radius = `floatSliderGrp -q -v fF_Radial_Radius`;

	if (`objExists "Fracture_Radial"` == 1)
	{
		setAttr "Fracture_Radial.magnitude" $Radial_Magnitude;
		setAttr "Fracture_Radial.maxDistance" $Radial_Radius;
    }
}

global proc Fracture_Explode()
{

	$Radial_Magnitude = `floatSliderGrp -q -v fF_Radial_Magnitude`;
	$Radial_Radius = `floatSliderGrp -q -v fF_Radial_Radius`;

	$Scene_Scale = `currentUnit -q`;
//Setup Simulation to collide with floor
	string $UP = `upAxis -q -axis`;
	$PhysChunks = `ls -sl -fl`;

	deleteSelectRigidBodies;

	$Explode_Extents = `exactWorldBoundingBox`;//	xmin, ymin, zmin, xmax, ymax, zmax.
	$Explode_Extents_SizeX = ($Explode_Extents[3] - $Explode_Extents[0]);
	$Explode_Extents_SizeY = ($Explode_Extents[4] - $Explode_Extents[1]);
	$Explode_Extents_SizeZ = ($Explode_Extents[5] - $Explode_Extents[2]);

	$Explode_CenterX = (($Explode_Extents[3] + $Explode_Extents[0]) / 2);
	$Explode_CenterY = (($Explode_Extents[4] + $Explode_Extents[1]) / 2);
	$Explode_CenterZ = (($Explode_Extents[5] + $Explode_Extents[2]) / 2);

	string $Fracture_Gravity[];
	string $Fracture_Radial[];

	if ($UP == "z")
		{
			$Fracture_Gravity = `gravity -name "Fracture_Gravity" -pos 0 0 0 -m 9.8 -att 0 -dx 0 -dy 0 -dz -1  -mxd -1  -vsh none -vex 0 -vof 0 0 0 -vsw 360 -tsr 0.5` ;
			$Fracture_Radial = `radial  -name "Fracture_Radial"  -pos $Explode_CenterX $Explode_CenterY $Explode_CenterZ -m $Radial_Magnitude -att 1 -typ 0  -mxd $Radial_Radius  -vsh none -vex 0 -vof 0 0 0 -vsw 360 -tsr 0.5 `;
		}
	if ($UP == "y")
		{
			$Fracture_Gravity = `gravity -name "Fracture_Gravity" -pos 0 0 0 -m 9.8 -att 0 -dx 0 -dy -1 -dz 0  -mxd -1  -vsh none -vex 0 -vof 0 0 0 -vsw 360 -tsr 0.5` ;
			$Fracture_Radial = `radial -name "Fracture_Radial" -pos $Explode_CenterX $Explode_CenterY $Explode_CenterZ -m $Radial_Magnitude -att 1 -typ 0  -mxd $Radial_Radius  -vsh none -vex 0 -vof 0 0 0 -vsw 360 -tsr 0.5 `;
		}

	if ($Scene_Scale == "cm")
	{
		setAttr "Fracture_Gravity.magnitude" 980;
    }

	if ($Scene_Scale == "m")
	{
		setAttr "Fracture_Gravity.magnitude" 9.8;
    }

	for ($o = 0; $o < `size $PhysChunks`; $o++)
		{
			$Object_Area =`polyEvaluate -a $PhysChunks[$o]`;
			//print $Object_Area;
			$Object_Mass = ($Object_Area[0] / 100);
			rigidBody -active -m $Object_Mass -afa 0 -dp 0 -sf 0.2 -df 0.2 -b 0.5 -l 0 -tf 200 -iv 0 0 0 -iav 0 0 0 -c 0 -pc 0 -i 0 0 0 -imp 0 0 0 -si 0 0 0 -sio none $PhysChunks[$o];
		}

	connectDynamic -f $Fracture_Gravity $PhysChunks;
	connectDynamic -f $Fracture_Radial $PhysChunks;
	//error;

	//Create Collision Ground
	$Adjusted_Extents = `polyEvaluate -b $PhysChunks`;

	if ($UP == "z")
			{
				polyPlane -name "Fracture_Collision_Ground" -ax 0 0 1 -ch on -o on -w  ($Explode_Extents_SizeX * 10) -h ($Explode_Extents_SizeY * 10) -sw 1 -sh 1 -cuv 2 ;
				move -rpr $Explode_CenterX $Explode_CenterY $Explode_Extents[2];
			}
	if ($UP == "y")

			{
				polyPlane -name "Fracture_Collision_Ground" -ax 0 1 0 -ch on -o on -w 1000  -h 1000 -sw 1 -sh 1 -cuv 2 ;
				move -rpr 0 $Explode_Extents[1] 0;
			}

	rigidBody -passive  -m 1 -dp 0 -sf 0.2 -df 0.2 -b 0 -l 0 -tf 200 -iv 0 0 0 -iav 0 0 0 -c 0 -pc 0 -i 0 0 0 -imp 0 0 0 -si 0 0 0  ;
	playbackOptions -max 600;

}

global proc Fracture_RE_Crumble()
{
	$Undo_Search = `undoInfo -q -un`;//check last undo call
	if ($Undo_Search == "Fracture_Crumble()")
		{
			undo;
			Fracture_Crumble();
		}
	if ($Undo_Search == "Fracture_RE_Crumble()")
		{
			undo;
			Fracture_Crumble();
		}
}


///////////////////////////////////////////////////////////////////////////////////////////////////Fracture Settle

global proc Fracture_Settle()
{
	string $UP = `upAxis -q -axis`;
//Setup Simulation to collide with floor
	currentTime 0;

	//Fracture_Crumble();
	$PhysChunks = `ls -sl -fl`;
	deleteSelectRigidBodies;

	float $Explode_Extents[] = `polyEvaluate -b $PhysChunks `;//((xmin,xmax), (ymin,ymax), (zmin,zmax))
	$Explode_Extents_SizeX = ($Explode_Extents[1] - $Explode_Extents[0]);
	$Explode_Extents_SizeY = ($Explode_Extents[3] - $Explode_Extents[2]);
	$Explode_Extents_SizeZ = ($Explode_Extents[5] - $Explode_Extents[4]);

	string $Fracture_Gravity[];

	string $RigidBoday_Array = `rigidBody -active -cl true -m 1 -dp 0 -sf 0.2 -df 0.2 -b 0 -l 0 -tf 200 -iv 0 0 0 -iav 0 0 0 -c 0 -pc 0 -i 0 0 0 -imp 0 0 0 -si 0 0 0 -sio none`;
	if ($UP == "z")
		{
			$Fracture_Gravity = `gravity -name "Fracture_Gravity" -pos 0 0 0 -m 980 -att 0 -dx 0 -dy 0 -dz -1  -mxd -1  -vsh none -vex 0 -vof 0 0 0 -vsw 360 -tsr 0.5` ;
		}
	else
		{
			$Fracture_Gravity = `gravity -name "Fracture_Gravity" -pos 0 0 0 -m 980 -att 0 -dx 0 -dy -1 -dz 0  -mxd -1  -vsh none -vex 0 -vof 0 0 0 -vsw 360 -tsr 0.5` ;
		}
	connectDynamic -f $Fracture_Gravity $PhysChunks;

	//Create Collision Ground

	string $CollisionPlane[] =`polyPlane -name "Fracture_Collision_Ground" -ch on -o on -w 10000  -h 10000 -sw 1 -sh 1 -cuv 2 `;

		if ($UP == "z")
			{
				move -rpr 0 ($Explode_Extents[4] ) 0 $CollisionPlane[0];
			}
		else
			{
				move -rpr 0 ($Explode_Extents[2] ) 0 $CollisionPlane[0];
			}
	//error;
	rigidBody -passive  -m 1 -dp 0 -sf 0.2 -df 0.2 -b 0 -l 0 -tf 200 -iv 0 0 0 -iav 0 0 0 -c 0 -pc 0 -i 0 0 0 -imp 0 0 0 -si 0 0 0 ;

	playbackOptions -max 600;
	currentTime 1;
	currentTime 0;
	currentTime 300;


	//Move Z Back to min Z start
	select $PhysChunks;

	//$Seperated_Extents = `polyEvaluate -b`;
	//move -r 0 0 ($Seperated_Extents[4] * - 1);

	//Clean up
	deleteSelectRigidBodies;
	delete "Fracture_Gravity";
	delete "Fracture_Collision_Ground";

}

//global proc Fracture_Explode()
//{
//Fracture_Seperate();
//Fracture_Crumble();
//Fracture_Settle();
//}



////////////////////////////////////////////////////////////////////////////////////////////////////Open Help
global proc Open_Fracture_Help()
{
	system ("load http://www.bk3d.com/Scripts/Mel/Fracture/Fracture.htm") ;

}//end proc

////////////////////////////////////////////////////////////////////////////////////////////////////Enable_Group checkbox
global proc Fracture_Enable_Group()
{
textField -e -en true TF_Fracture_Group_Name;
}

////////////////////////////////////////////////////////////////////////////////////////////////////Disable_Group checkbox
global proc Fracture_Disable_Group()
{
textField -e -en false TF_Fracture_Group_Name;
}

global proc Fracture_Set_Meters()
{
	intSliderGrp   -e -v 2 FF_Cuts;
	floatSliderGrp -e -v 1 FF_Face_Size;
	floatSliderGrp -e -minValue .001 -maxValue .1 -v .001  Locator_Scale ;
	floatSliderGrp -e -v .05   fF_PathOffsetAmount;
	floatSliderGrp -e -v .01  FF_PathNoise;
	intSliderGrp   -e -v 1 fF_Number_Chips;
	floatSliderGrp -e -v 1 fF_Chip_Size;

	floatSliderGrp -e  -maxValue 900   -value 100  -fieldMaxValue 900 fF_Radial_Magnitude;
	floatSliderGrp -e  -maxValue 100   -value 20   -fieldMaxValue 100 fF_Radial_Radius;

}

global proc Fracture_Set_Centimeters()
{
	intSliderGrp   -e -v 2 FF_Cuts;
	floatSliderGrp -e -v 40 FF_Face_Size;
	intSliderGrp  -e -v 50 Bias_percent;
	intSliderGrp   -e -v 1 fF_Number_Chips;
	floatSliderGrp -e -v 100 fF_Chip_Size;
	floatSliderGrp -e -minValue 1 -maxValue 1000.00 -value 40 -fieldMinValue 1 -fieldMaxValue 10000 FF_Face_Size;

	floatSliderGrp -e  -maxValue 90000   -value 10000  -fieldMaxValue 90000 fF_Radial_Magnitude;
	floatSliderGrp -e  -maxValue 10000   -value 2000   -fieldMaxValue 10000 fF_Radial_Radius;
}

global proc Fracture_Set_Presets()
{
int $M = (`currentUnit -q -l` == "m");//check if meters
int $CM = (`currentUnit -q -l` == "cm");//check if Centimeters

if ($M == 1)
	{
		Fracture_Set_Meters();
	}

if ($CM == 1)
	{
		Fracture_Set_Centimeters();
	}

}//end proc

global proc Fracture_Enable_Bias()
{

	intSliderGrp  -e -en true  Bias_percent;
	radioButtonGrp -e -en 1 Bias_Direction;
	checkBox -e -v 1 cb_Fracture_Plane;
	Preview_FracturePlane();
	Fracture_Adjust_Bias();

}

global proc Fracture_Disable_Bias()
{
	global string $Preview_Plane[];
	intSliderGrp  -e -en false  Bias_percent;
	radioButtonGrp -e -en 0 Bias_Direction;
	checkBox -e -v 0 cb_Fracture_Plane;
	delete $Preview_Plane;
}

global proc Fracture_Adjust_Bias()
{
		global string $Preview_Plane[];
		$UP = `upAxis -q -axis`;
		$Bias_Direction = `radioButtonGrp -q -sl Bias_Direction`;
		$Bias_percent = `intSliderGrp -q -v Bias_percent`;

		$Selected_Obj = `ls -sl -fl`;
		float $Obj_Center[] = `objectCenter $Selected_Obj`;
		float $Obj_Bounds[] = `polyEvaluate -b $Selected_Obj`;
		float $X_Bounds = ($Obj_Bounds[1] - $Obj_Bounds[0]);
		float $Y_Bounds = ($Obj_Bounds[3] - $Obj_Bounds[2]);
		float $Z_Bounds = ($Obj_Bounds[5] - $Obj_Bounds[4]);
		float $Adjusted_X = ($Obj_Bounds[0] + ($X_Bounds * (.01 * $Bias_percent)));
		float $Adjusted_Y = ($Obj_Bounds[2] + ($Y_Bounds * (.01 * $Bias_percent)));
		float $Adjusted_Z = ($Obj_Bounds[4] + ($Z_Bounds * (.01 * $Bias_percent)));
		//$Obj_Center = {$Adjusted_X , $Adjusted_Y, $Adjusted_Z};

		if ($Bias_Direction == 1 )//x
			{
				if ($UP == "z")
					{

						move -rpr -ws $Adjusted_X $Obj_Center[1] $Obj_Center[2] $Preview_Plane;
						rotate 0 0 90 $Preview_Plane;
					}//end if y up



			}//end if
		if ($Bias_Direction == 2 )//y
			{
				if ($UP == "z")
					{
						move -rpr -ws $Obj_Center[0] $Adjusted_Y $Obj_Center[2] $Preview_Plane;
						rotate 0 0 0 $Preview_Plane;
					}

			}
		if ($Bias_Direction == 3 )//z
			{
				if ($UP == "z")
					{
						move -rpr -ws $Obj_Center[0] $Obj_Center[1] $Adjusted_Z $Preview_Plane;
						rotate 90 0 0 $Preview_Plane;
					}
			}

}

global proc Change_CutMethod()
{
	$Cut_Method = `radioButtonGrp -q -sl Fracture_CutMethod`;
	if ($Cut_Method == 1)
	{
		floatSliderGrp -e -en 1 FF_Face_Size;
		floatSliderGrp -e -en 1 FF_Noise;
    }

	if ($Cut_Method == 2)
	{
		floatSliderGrp -e -en 0 FF_Face_Size;
		floatSliderGrp -e -en 0 FF_Noise;
    }
}

////////////////////////////////////////////////////////////////////////////////////////  UI  ////////////////////////////////////////////////////////////////////////////////////////////////
//																																															//
//																																															//
//																																															//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc Build_Fracture_UI()
{
	$UI_Width = 270;
		//Fracture Menu
		//
		menuBarLayout;
			menu -label "Help" -helpMenu true;
       			menuItem -label "Open Help Page" -c ("Open_Fracture_Help()");
				menuItem -label "Seperate Unsperated Chunks" -c ("BK_Seperate_Chunks()");
				menuItem -label "Cap Holes" -c ("Fracture_Cap_Holes()");
				menuItem -label "Union Selected" -c ("Fracture_Union()");

			menu -label "Presets";
       			menuItem -label "Meters" -c ("Fracture_Set_Meters()");
       			menuItem -label "Centimeters" -c ("Fracture_Set_Centimeters()");

			menu -label "Test";
       			menuItem -label "Test mesh for errors" -c ("Test_Fracture_Mesh()");
				menuItem -label "Test Locators" -c ("Test_Overlapping_Locators()");

			menu -label "Preview";
				menuItem -label "Preview Voronoi Cuts" -c ("Preview_Voronoi_CutPlanes()");

//scrollLayout;//Main Scroll Layout
columnLayout;//Main Column Layout
	text -l "Fracture Progress " progressText;
	progressBar -height 10 -width $UI_Width -bgc 1 0 0 Fracture_progress;
	separator -height 10 -width $UI_Width;
	string $Fracture_tabs = `tabLayout -bgc 0.55 0.55 0.55 -scrollable 0 -innerMarginWidth 0 -innerMarginHeight 0`;

		//Fracture Tab
		//
    	string $Tab_Fracture = `columnLayout`;
			separator -height 10 -width $UI_Width;


			//Naming UI
			frameLayout -label "Nameing / Grouping" -width 275 -borderStyle "etchedIn"  -cl true -cll true FL_Fracture_Nameing;
				columnLayout;
					text -l "Chunks Name";
						textField -w $UI_Width -tx "Fracture_Chunk_01" TF_Fracture_Chunk_Name;

					separator -height 10 -width $UI_Width;
						checkBox   -l "Create in New Group" -v 0 -onc ("Fracture_Enable_Group()") -ofc ("Fracture_Disable_Group()") CB_Group_Chunks;
						text -l "Group Name";
						textField -en false -w $UI_Width -tx "Fracture_Group_01" TF_Fracture_Group_Name;
						separator -height 10 -width $UI_Width;
				setParent..;
			setParent..;

			//Options UI
			//
			frameLayout -label "Options" -width 275 -borderStyle "etchedIn"  -cl false -cll true FL_Fracture_Options;
				columnLayout;
				separator -height 10 -width $UI_Width;
					radioButtonGrp -numberOfRadioButtons 2  -select 2 -label "Cut Method" -labelArray2 "Boolean"  "Polycut" -columnWidth3 75 100 100 -cc("Change_CutMethod()") Fracture_CutMethod;
				separator -height 10 -width $UI_Width;
					floatSliderGrp -cal 1 "left" -cw3 95 60 115 -l "Poly Cut Extrude"  -pre 2 -minValue 0 -maxValue 1000.00 -value 0 -fieldMinValue 0 -fieldMaxValue 10000 -ss 1 -field true -adjustableColumn3 3 FF_PolyCut_Extrude;
				separator -height 10 -width $UI_Width;

						intSliderGrp   -cal 1 "left" -cw3 95 60 115 -l "Iterations "  -minValue 2   -maxValue 100     -value 2  -fieldMinValue 2   -fieldMaxValue 10000 -field true -adjustableColumn3 3   -cc ("Preview_Voronoi_Particles()") FF_Cuts;
						floatSliderGrp -cal 1 "left" -cw3 95 60 115 -l "Face Size" 	-en 0 -pre 2    -minValue .01 -maxValue 1000.00 -value 40 -fieldMinValue .01 -fieldMaxValue 10000 -ss 1 -field true -adjustableColumn3 3 -dc ("Adjust_PreviewPlane()") -cc ("Adjust_PreviewPlane()") FF_Face_Size;
						floatSliderGrp -cal 1 "left" -cw3 95 60 115 -l "Random Noise" -en 0 -pre 2 -minValue 0   -maxValue 1000    -value 0 -fieldMinValue 0 -fieldMaxValue 10000 -ss 1 -field true -adjustableColumn3 3 -dc ("Adjust_PreviewPlane()") -cc ("Adjust_PreviewPlane()") FF_Noise;
						intSliderGrp   -cal 1 "left" -cw3 95 60 115 -l "Random Rotation"     -minValue 0   -maxValue 180     -value 180 -fieldMinValue 0   -fieldMaxValue 180   -field true -adjustableColumn3 3   -cc ("") FF_Rot;

				separator -height 10 -width $UI_Width;

						checkBox   -l "Auto Fill Holes (Recommended)" -v 1 cb_Fill_Holes;
						checkBox   -l "Seperate unseperated Chunks (Recommended)" -v 1 cb_Seperate_Chunks;
						checkBox   -l "Triangulate(Cleaner Cuts when using noise)" -v 0 cb_Fracture_Triangulate;

						rowColumnLayout -nc 3 -cw 1 150  -cw 2 30 -cw 3 100;
							checkBox   -l "Delete chunks smaller than" -v 0 cb_Delete_Slivers;
							intField -v 5 sliver_size;
							text -l "% of object";
						setParent..;

						checkBox   -l "Assign Fracture Shader to Cuts" -v 0 cb_Fracture_AssignShader;

				separator -height 10 -width $UI_Width;
				setParent..;
			setParent..;

			//Fracture UI
			//
			frameLayout -label "Plane Fracture" -width 275 -borderStyle etchedIn -cl false -cll true FL_Fracture;
				columnLayout;
					separator -height 10 -width $UI_Width;
						rowColumnLayout -nc 2 -cw 1 130  -cw 2 140 ;
							checkBox -l "Preview cutting Plane" -onc ("Preview_FracturePlane()") -ofc ("Preview_FracturePlane()") cb_Fracture_Plane;
							checkBox -l "Force cutting Plane"  -en 0 cb_Fracture_ForcePlane;
						setParent..;

						checkBox -l "Fracture Area Bias" -onc ("Fracture_Enable_Bias()") -ofc ("Fracture_Disable_Bias()") cb_Crop_Fracture;
						radioButtonGrp -en 0 -w $UI_Width -numberOfRadioButtons 3 -labelArray3 "X" "Y" "Z" -cw3 ($UI_Width / 3) ($UI_Width / 3) ($UI_Width / 3) -sl 1  -onc ("Fracture_Adjust_Bias()") Bias_Direction;
						intSliderGrp  -en false -cal 1 "left" -cw3 50 30 170 -l " Bias %" -minValue 0 -maxValue 100 -v 50  -field true -adjustableColumn3 3  -dc ("Fracture_Adjust_Bias()") -cc ("Fracture_Adjust_Bias()") Bias_percent ;
						//intSliderGrp  -en false -cal 1 "left" -cw3 40 40 170 -l " Y%" -minValue 0 -maxValue 100 -v 50  -field true -adjustableColumn3 3  -dc ("Fracture_Adjust_Bias()") -cc ("Fracture_Adjust_Bias()") Y_percent;
						//intSliderGrp  -en false -cal 1 "left" -cw3 40 40 170 -l " Z%" -minValue 0 -maxValue 100 -v 50  -field true -adjustableColumn3 3  -dc ("Fracture_Adjust_Bias()") -cc ("Fracture_Adjust_Bias()") Z_percent;
					separator -height 10 -width $UI_Width;
						button -label "Plane Fracture" -bgc .75 .75 .75  -h 30 -w $UI_Width -c ("Plane_Fracture Auto");
						button -label "Try Again" -bgc .75 .75 .75  -h 30 -w $UI_Width -c ("BK_RE_Fracture()");
					separator -height 10 -width $UI_Width;
				setParent.. ;//parent columnLayout
			setParent.. ;//parent framelayout

			// Voronoi Fracture UI
			frameLayout -label "Voronoi Fracture" -width 275 -borderStyle etchedIn -cl false -cll true FL_Voronoi_Fracture;
				columnLayout;
					separator -height 10 -width $UI_Width;
						rowColumnLayout -nc 2 -cw 1 130  -cw 2 140 ;
							checkBox   -l "preview locators" -v 0 -onc ("Preview_Voronoi_Particles()") -ofc ("Clean_Voronoi_Particles()") cb_Generate_Particles;
							checkBox -l "Force Locators"  -en 1 cb_Fracture_ForceLocators;
						setParent..;//parent rowColumnLayout
						floatSliderGrp  -en 1 -cal 1 "left" -cw3 95 60 115 -l "Locator Scale" -pre 3 -minValue .1 -maxValue 100 -v 1  -field true  -adjustableColumn3 3  -cc ("Preview_Voronoi_Particles()") Locator_Scale ;
						intSliderGrp    -en 1 -cal 1 "left" -cw3 95 60 115 -l "Locator position"   -minValue 2 -maxValue 1000 -v 5  -field true -adjustableColumn3 3  -cc ("Preview_Voronoi_Particles()") Stop_Frame ;
					separator -height 10 -width $UI_Width;
						rowColumnLayout -nc 2 -cw 1 ($UI_Width /2)  -cw 2 ($UI_Width/2) ;
							checkBox   -l "no face size" -v 1  cb_No_Divisions;
							checkBox   -l "no noise" -v 1  cb_No_Noise;
						setParent..;
					separator -height 10 -width $UI_Width;
						intSliderGrp  -en 1 -cal 1 "left" -cw3 95 60 115 -l "distance check" -minValue 0 -maxValue 100 -v 100  -field true  -adjustableColumn3 3   Distance_Scale ;
						button -label "Voronoi Fracture" -bgc .75 .75 .75  -h 30 -w $UI_Width -c ("Voronoi_Fracture()");
						//button -label "Voronoi Speed Fracture" -bgc .75 .75 .75  -h 30 -w $UI_Width -c ("Voronoi_SpeedFracture()");
				setParent.. ;//parent columnLayout
			setParent.. ;//parent framelayout

		setParent.. ;//parent Tab_Fracture

		//Chip Off Tab UI
		//
		string $Tab_Chip = `columnLayout`;
			frameLayout -label "Chip Off" -width 275 -borderStyle etchedIn -cl false -cll true FL_Chip;
				columnLayout;
					separator -height 10 -width $UI_Width;
						//progressBar -height 10 -width $UI_Width -bgc 1 0 0 Chip_progress;
						checkBox -l "Preview Chip" -v 0 -onc ("Preview_Chip()") -ofc ("Clean_Preview_Chip()") cb_preview_Chips;
						intSliderGrp   -cal 1 "left" -cw3 100 50 100 -l "# chips"                  -minValue 1    -maxValue 100     -value 1   -fieldMinValue 1   -fieldMaxValue 10000 -field true -adjustableColumn3 3    fF_Number_Chips;
						floatSliderGrp -cal 1 "left" -cw3 100 50 100 -l "Chip size(radius)" -pre 2 -minValue .01  -maxValue 1000.00 -value 100 -fieldMinValue .01 -fieldMaxValue 10000 -field true -adjustableColumn3 3   -cc ("Preview_Chip()")fF_Chip_Size;
						floatSliderGrp -cal 1 "left" -cw3 100 50 100 -l "Chip Noise" -pre 2 -minValue 0  -maxValue 1000 -value 0 -fieldMinValue 0 -fieldMaxValue 10000 -field true -adjustableColumn3 3   -cc ("Preview_Chip()")fF_Chip_Noise;
						radioButtonGrp -columnWidth4 50 50 50 50 -numberOfRadioButtons 3 -label "center" -labelArray3 "verts" "edges" "faces" -select 1 rbg_Component;
					separator -height 10 -width $UI_Width;
						checkBox -l "Keep Chips" -v 1 cb_Keep_Chips;
						button -label "Remove random Chips" -bgc .75 .75 .75  -h 30 -w $UI_Width -c ("Fracture_ChipOff Random");
						button -label "Try Again" -bgc .75 .75 .75  -h 30 -w $UI_Width -c ("Fracture_Re_ChipOff()");
					separator -height 10 -width $UI_Width;
						button -label "Remove Chips at selected component" -bgc .75 .75 .75  -h 30 -w $UI_Width -c ("Fracture_ChipOff Selection");
					separator -height 10 -width $UI_Width;
				setParent.. ;//parent columnLayout
			setParent.. ;//parent framelayout

			frameLayout -label "Detach Chunk" -width 275 -borderStyle etchedIn -cl false -cll true FL_DetachChunk;
				columnLayout;
				separator -height 10 -width $UI_Width;
					text -l "Detach Chunk (Select faces to detach)";
					button -label "Detach Chunk" -bgc .75 .75 .75  -h 30 -w $UI_Width -c ("Fracture_Detach_and_Cap()");
				separator -height 10 -width $UI_Width;
					//floatSliderGrp -cal 1 "left" -cw3 100 50 100 -l "Face Size" -pre 2    -minValue .01 -maxValue 1000.00 -value 40 -fieldMinValue .01 -fieldMaxValue 10000 -ss 1 -field true -adjustableColumn3 3 -dc ("Adjust_PreviewPlane()") -cc ("Adjust_PreviewPlane()") FF_SplineFace_Size;
				setParent.. ;//parent columnLayout
			setParent.. ;//parent framelayout
		setParent.. ;//parent Chip Tab

		//Spline Tab
		//
		string $Tab_CustomFracture = `columnLayout`;

			frameLayout -label "Cutting Plane Options" -width 275 -borderStyle etchedIn -cl false -cll true FL_Spline_Options;
				columnLayout;
				separator -height 10 -width $UI_Width;
					intSliderGrp   -cal 1 "left" -cw3 100 50 100 -l "U segments"  -minValue 1    -maxValue 100     -value 1   -fieldMinValue 1   -fieldMaxValue 100 -field true -adjustableColumn3 3  -cc ("Adjust_Spline_Cut()") fF_SplineCutUSegments;
					intSliderGrp   -cal 1 "left" -cw3 100 50 100 -l "V segments"  -minValue 1    -maxValue 100     -value 2   -fieldMinValue 1   -fieldMaxValue 100 -field true -adjustableColumn3 3  -cc ("Adjust_Spline_Cut()") fF_SplineCutVSegments;
					floatSliderGrp   -cal 1 "left" -cw3 100 50 100 -l "Cut Noise"  -minValue 0    -maxValue 100     -value 0   -fieldMinValue 0   -fieldMaxValue 100 -field true -adjustableColumn3 3   -cc ("Adjust_Spline_Cut()") fF_SplineCutNoise;
				separator -height 10 -width $UI_Width;
				setParent.. ;//parent columnLayout
			setParent.. ;//parent framelayout

			frameLayout -label "Spline Cut" -width 275 -borderStyle etchedIn -cl false -cll true FL_Spline;
				columnLayout;
				separator -height 10 -width $UI_Width;
					text -l "Select Spline First then Objects";
					text -l "Spline must be outside the mesh";
				separator -height 10 -width $UI_Width;
					checkBox   -l "preview Spline Cut" -v 0 -onc ("Preview_Spline_Cut") -ofc ("Clean_Spline_Preview()") cb_Preview_Spline_Cut;
				separator -height 10 -width $UI_Width;
					button -label "Single Spline Cut" -bgc .75 .75 .75  -h 30 -w $UI_Width -c ("Fracture_Spline_Cut Single");
				separator -height 10 -width $UI_Width;
					text -l "Multi Spline Fracture";
				separator -height 10 -width $UI_Width;
					textScrollList -width $UI_Width -numberOfRows 8 -allowMultiSelection true spline_list;
					rowColumnLayout -nc 2 -cw 1 ($UI_Width /2)  -cw 2 ($UI_Width/2) ;
						button -label "Add Splines"  -bgc .75 .75 .75  -h 20 -w ($UI_Width / 2) -c ("Fracture_Add_Splines()");
						button -label "Clear Splines"  -bgc .75 .75 .75  -h 20 -w ($UI_Width / 2) -c ("Fracture_Remove_Splines()");
					setParent.. ;
				separator -height 10 -width $UI_Width;
					button -label "Multi Spline Fracture"  -bgc .75 .75 .75  -h 30 -w $UI_Width -c ("Fracture_MultiSpline_Cut()");
				separator -height 10 -width $UI_Width;
				setParent.. ;//parent columnLayout
			setParent.. ;//parent framelayout

			//Path Fracture
			frameLayout -label "Path Fracture" -width 275 -borderStyle etchedIn -cl false -cll true FL_PathFracture;
				columnLayout;
					separator -height 10 -width $UI_Width;
						text -l "Select Spline First then Object";
					separator -height 10 -width $UI_Width;
						rowColumnLayout -nc 2 -cw 1 130  -cw 2 150 ;
							checkBox -l "Preview Path" -onc ("Preview_FracturePath()") -ofc ("Clean_PreviewPath()") cb_Preview_FracturePath;
							//checkBox -l "Force Plath"  -en 0 cb_Fracture_ForcePath;
						setParent..;
					separator -height 10 -width $UI_Width;
						intSliderGrp   -cal 1 "left" -cw3 100 50 100 -l "number of segments"  -minValue 1    -maxValue 100     -value 16   -fieldMinValue 1   -fieldMaxValue 100 -field true -adjustableColumn3 3  -cc ("Preview_FracturePath()") fF_PathSegments;
						intSliderGrp   -cal 1 "left" -cw3 100 50 100 -l "number of offsets"  -minValue 0    -maxValue 10     -value 4   -fieldMinValue 0   -fieldMaxValue 10 -field true -adjustableColumn3 3   -cc ("Preview_FracturePath()") fF_PathOffsets;
						floatSliderGrp -cal 1 "left" -cw3 100 50 100 -l  "Offset Amount" -pre 2 -minValue 0   -maxValue 1000    -value 5 -fieldMinValue 0 -fieldMaxValue 10000 -ss 1 -field true -adjustableColumn3 3   -cc ("Preview_FracturePath()") fF_PathOffsetAmount;
						floatSliderGrp -cal 1 "left" -cw3 100 50 100 -l  "Random Noise" -pre 2 -minValue 0   -maxValue 1000    -value 0 -fieldMinValue 0 -fieldMaxValue 10000 -ss 1 -field true -adjustableColumn3 3   -cc ("Preview_FracturePath()") FF_PathNoise;
						button -label "Path Fracture"  -bgc .75 .75 .75  -h 30 -w $UI_Width -c ("Path_Fracture()");
					separator -height 10 -width $UI_Width;
				setParent.. ;//parent columnLayout
			setParent.. ;//parent framelayout

		setParent.. ;//parent Chip Tab

		//Pattern Tab
		//
		string $Tab_FracturePattern = `columnLayout`;
			frameLayout -label "Radial" -width 275 -borderStyle etchedIn -cl false -cll true FL_Chip;
				columnLayout;
					separator -height 10 -width $UI_Width;
					floatSliderGrp   -cal 1 "left" -cw3 100 50 100 -l "Max Radius"  -pre 2 -minValue 1    -maxValue 100     -value 10   -fieldMinValue 1   -fieldMaxValue 100 -field true -adjustableColumn3 3   -cc ("Fracture_Create_Radial()") fF_Ring_Radius;
					floatSliderGrp   -cal 1 "left" -cw3 100 50 100 -l "ring noise"  -pre 2 -minValue 0    -maxValue 10     -value 0   -fieldMinValue 0   -fieldMaxValue 10 -field true -adjustableColumn3 3  -cc ("Fracture_Create_Radial()")  fF_Ring_Noise;
					intSliderGrp   -cal 1 "left" -cw3 100 50 100 -l "number of rings"  -minValue 1    -maxValue 100     -value 6   -fieldMinValue 1   -fieldMaxValue 100 -field true -adjustableColumn3 3   -cc ("Fracture_Create_Radial()") fF_Number_Rings;
					intSliderGrp   -cal 1 "left" -cw3 100 50 100 -l "rings segments"  -minValue 1    -maxValue 100     -value 16   -fieldMinValue 1   -fieldMaxValue 100 -field true -adjustableColumn3 3  -cc ("Fracture_Create_Radial()")  fF_Number_Rings_Seg;
					separator -height 10 -width $UI_Width;
					rowColumnLayout -nc 2 -cw 1 ($UI_Width /2)  -cw 2 ($UI_Width/2) ;
						checkBox -l "Create Splines" -v 1 -cc ("Fracture_Create_Radial()") cb_Radial_CreateSplines;
						checkBox -l "Create Locators" -v 1 -cc ("Fracture_Create_Radial()") cb_Radial_CreateLocators;
					setParent.. ;
					separator -height 10 -width $UI_Width;
						button -label "Create Radial"  -bgc .75 .75 .75  -h 30 -w $UI_Width -c ("Fracture_Create_Radial()");
					separator -height 10 -width $UI_Width;
					setParent.. ;//parent columnLayout
			setParent.. ;//parent framelayout
		setParent.. ;//parent Pattern Tab

		//Dynamics UI
		//
		string $Tab_Explode = `columnLayout`;
			frameLayout -label "Explode" -width 275 -borderStyle etchedIn -cl false -cll true FL_Explode;
				columnLayout;
				//separator -height 10 -width $UI_Width;
					//button -label "Seperate Chunks" -bgc .75 .75 .75  -h 30 -w $UI_Width -c ("Fracture_Seperate()");
					//floatSliderGrp -cal 1 "left" -cw3 100 50 100 -l "Seperate Amount" -pre 2    -minValue 0 -maxValue 200000 -value 1000 -fieldMinValue 0 -fieldMaxValue 200000 -ss 1 -field true -adjustableColumn3 3  -cc ("Fracture_RE_Seperate()") FF_Fracture_Seperate;
				separator -height 10 -width $UI_Width;

					floatSliderGrp   -cal 1 "left" -cw3 100 50 100 -l "Explode Amount"  -minValue 1    -maxValue 10000     -value 100   -fieldMinValue 1   -fieldMaxValue 10000 -field true -adjustableColumn3 3 -cc("Adjust_Explode()") fF_Radial_Magnitude;
					floatSliderGrp   -cal 1 "left" -cw3 100 50 100 -l "Explode Radius"  -minValue 1    -maxValue 10000     -value 100   -fieldMinValue 1   -fieldMaxValue 10000 -field true -adjustableColumn3 3 -cc("Adjust_Explode()") fF_Radial_Radius;
					button -label "Explode" -bgc .75 .75 .75  -h 30 -w $UI_Width -c ("Fracture_Explode()");
					//floatSliderGrp -cal 1 "left" -cw3 100 50 100 -l "Crumble Amount" -pre 2    -minValue 0 -maxValue 1 -value .5 -fieldMinValue 0 -fieldMaxValue 100 -ss 1 -field true -adjustableColumn3 3   -cc ("Fracture_RE_Crumble()") FF_Crumble;
				separator -height 10 -width $UI_Width;
					//button -label "Settle" -bgc .75 .75 .75  -h 30 -w $UI_Width -c ("Fracture_Settle()");
					//button -label "Explode" -bgc .75 .75 .75  -h 30 -w $UI_Width -c ("Fracture_Explode()");
				setParent.. ;//parent columnLayout
			setParent.. ;//parent framelayout
		setParent.. ;//parent Explode Tab

setParent..;//parent tablayout
tabLayout -edit  -tabLabel $Tab_Fracture "Fracture"  -tabLabel $Tab_Chip "Chip Off" -tabLabel $Tab_CustomFracture "Spline Cut" -tabLabel $Tab_FracturePattern "Pattern" -tabLabel $Tab_Explode "Dynamics"   $Fracture_tabs;

setParent..;//Parent Main ColumnLayout
setParent..;//Parent Main scrollLayout
Fracture_Set_Presets();

Create_Fracture_Shader();
}//end proc


global proc Fracture()
{

	$UI_Width = 250;
	if ((`window -ex  Fracture_UI`) == true) deleteUI Fracture_UI;
	$Fracture_Window = `window -title "Fracture V 4.6" -w $UI_Width Fracture_UI`;
	Build_Fracture_UI();

	showWindow Fracture_UI;
}

global proc Fracture_UI()
{

	$UI_Width = 250;
	if ((`window -ex Fracture_UI`) == true) deleteUI Fracture_UI;
	$Fracture_Window = `window -title "Fracture V 4.6" -w $UI_Width Fracture_UI`;
	Build_Fracture_UI();

	showWindow Fracture_UI;
}