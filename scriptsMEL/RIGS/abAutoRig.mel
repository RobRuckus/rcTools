/*
abAutoRig.mel Standard 6.03
brendan ross 04.14.2007
www.supercrumbly.com

use:

A simple skeleton builder and autorigger.

directions:

See website for now

updates:

v. 1.1 -- HeelLocs axes, and therefore foot Ik control curves, are now properly aligned.
v. 1.2 -- Went back to my previous way of doing stretch on arms and legs that I think is more flexible.  Fk stretch is no longer limited by the ik maxStretch attribute.  Exposed stretch value on arms and legs.
v. 1.21 -- Exposed stretch value for spine on cog ctrl.
v. 1.22 -- Ikhandle fix.
v. 1.23 -- Fk to Ik snap now fully implemented on legs.  Stretch value now displays the correct value when used on an arm or leg with split joints.
v. 1.3 -- Added optional ik fingers to hand rig.  Space switching on mirrored controls now works properly (leg and arm IK, hand).  PV controls will now follow their ik curves when their space is set as such.  Updated Fk to Ik snap to work when a character's rig group has been regrouped or moved in the scene hierarchy.  Fk/ik snap also now supports references via the namespace optionMenu and works with previously built characters.
v. 1.4 -- Split joints now work properly.  Master control can be rotated without any problems.  Added split joint rotation ratios to rigSettings ctrl (the visibility of which is now located on the root ctrl).  Fixed the way scale is determined so pv control wires will now mirror properly.  Added popup to select target object when wire mirroring encounters multiple mirror objects.
v. 1.4.1 -- Made a small change to the way finger IK ctrls are scaled.
v. 1.5 -- Weight spine joints now rotate correctly with rootCon rotations.  Thanks to Josh Yoder for finding this.
v. 1.6 -- Under "Tools" menu added "Save Wires to Shelf" (with its own icon) and "Rig Remover", both of which should make for easier updates.  IK and PV controls are now aligned along the world axes.  Improved default rotation order on control curves.  Script will now attempt to repopulate UI fields (hidden and non) automatically, which, among other things, means that parts of the rig can be added after the UI has been closed and opened again without a problem.  Added scale slider and four new shapes (tweaked others) to ReplaceWire UI.  Improved error handling (the script now checks for an existing rig upon creation).  Slight improvements to the default skeleton.  Killed a few bugs.
v. 1.7 -- Fixed the hand IK rotation problem by adding "Align Hand IK to World Axes" checkbox to the Arm tab.  Leaving the checkbox blank will align the IK control to the wrist joint and allow it to rotate the hand.  Enabling it will freeze the control's transforms and lock and hide the rotation channels.  Modified default LRA alignment on arm, wrist and hand joints to make IK control a bit more intuitive.  IK finger rig now blends properly between FK and IK.  Added curl attributes for each finger as well as midCurlAmt and tipCurlAmt, which determine how much the respective joints will rotate relative to the base joint when using masterFist and fingerCurl attributes.  Added masterSpread to hands and individual finger spreadAmount attributes to spineCtrlCrv to specify the amount each finger is affected by masterSpread.  Wire replacer should now work more reliably overall.  Adjusted the object centers of curves which should eliminate drifting when replacing wires.  Replaced wire scale slider with a float field, which can be control-LMB MMB or RMB dragged on to interactively scale the selected wire.  Creating wires along the -z axis now works as expected.  UI field auto fill is now more comprehensive (be aware that it fills mirrorable object fields (upArm, upLeg, the hand fields etc) with the left objects by default).  Added the ability to rig mirror limbs at the same time (The options menu finally has a child).  Lot's of other small stuff.
v. 1.7.5 -- Added ability to select hand joint rotation axes under Options > Hand Options
v. 1.8 -- Added "Stretchy Spline From Curve" to tools menu to make quick and dirty IK spline joint chains.  The knees once again stretch as they should (oops).  UI field auto fill now includes the number of split joints.
v. 1.8.1 -- Added individual up and low limb stretch attributes to legs and arms (works with limbStretch on foot and wrist controls).
v. 1.8.2 -- Added rigScale to the stretchy spine.
v. 1.8.3 -- Less flipping when sliding IK/FK blend on leg and arm joints.  They'll still flip occassionally when the root ctrl has lots of rotations, but only when the IK and FK limbs are in matching positions and the ikFkBlend is between 0 and 1.  It shouldn't be a problem.
v. 1.9 -- Rig is now scaleable.  Added true IK to spine controls (enable "useRootSpace" attribute on the control curve).  Added translate control to the head, which can also be used in IK mode (enable "ikCtrlVis" on head ctrl to see the control).  Added utility to match ctrl positions across space switches ("Space Switch Matcher" in tools menu).  Added snapIKtoFK and hugely improved SnapFKtoIk (both can be found in the character shelf button).  Unfortunately, older snapFKtoIK buttons won't work anymore, which is not a huge problem because it wasn't really working that well anyway.  FK controls with align attribute now auto align with the root ctrl (<- this is awesome for those of us who love the align att).  Rig Remover will now work with multiple characters in a scene.  Improved stretchy splines (made with "makeStretchySpline") scaling.  Removed World space from space switch options as it was pointless.  Disabling all of the spaces does the same thing.  Fixed spine stretch value.
v. 1.9.1 -- Very small fix.  IK/FK snap button now works when rig_grp position has changed in the rig hierarchy (placed in a new group).  To fix a button made with 1.9, just copy the button command into a text editor and replace ">|" with ">" and "&|" with "&".  Replace your current command (of the IK/FK snapping shelf button) with the modified version and you should be good to go.
v. 1.9.3 -- Weight Spine joints are now created in the skeleton grp.  They won't be deleted when you remove the rig, so you won't have to reattach and weight them when you update the rig.  Added "Reset Character to Default Pose" (which can be also be called with "abRTResetCharPose(1)") and "Reset Selected Control Curves to Default" (call with "abRTResetCharPose(0)") to Tools menu.  Added ability to lock proxy controls to prevent troublesome translations and rotations.  Added a warning when building the skeleton about snap to PV not working under certain conditions.
v. 1.9.4 -- The script now supports feet that have been rotated out of the YZ plane.  When building your skeleton, match the foot locators (ankle, ball, and toe) to your mesh by moving them in their local YZ planes (no X) and rotating the "lf_foot_grpLoc" in Y.  If you want to use an existing skeleton you'll have to orient the ankle and ball joints first.  To do so, select left and right ankle and ball joints and run "joint -e -orientJoint xyz -sao ydown;" in the command line.
v. 1.9.5 -- Skeletons on layers can now be rigged.  IK and FK joints won't be colored, though, so you're better off keeping it off of a layer until the rig has been created.  Added a spine_end group control to the proxy skeleton.
v. 2.0 -- The skeleton created by skeleton builder is now mirrored in behavior instead of orientation (except for the eyes and, optionally, the legs).  I had to update hand rigging (among other things) to accomodate the change, so I've added a new a menu item (Options > Hand Options > Reverse Right Curl) which should be enabled when rigging skeletons created with earlier (pre 2.0) versions of the script.  Added "Mirror Leg Behavior" menu item to the skeletonMaker UI (enabled by default).  Disable it to mirror the leg joints by orientation.
v. 2.0.1 -- Arm IK controls are aligned properly (again).  Changed the way "Align Hand IK to World Axes" works.
v. 2.0.2 -- The UI autofill feature was missing some important hidden fields which kept certain spaces (like handCtrl for finger IK controls) from being created.  Now that it's fixed, the finger IK curves travel with the hand as they should (they're constrained to handCtrl space by default).  I also add the option to skeletonMaker to specify the number of fingers on the proxy.  Note that if you recall a saved skeleton from a shelf button, it will respect the current finger num value if the skeletonMaker UI is open.  Neck and head joints are now aligned so their control curves rotate the same way as the spine curves.
v. 2.1 -- Proxies saved to the shelf now have local transforms preserved (including scale on the rootLoc).  Feet rotated out of Z should now rig correctly when there are Y rotations on the leg_grpLoc.
v. 2.1.1 -- Fixed a bug with weightSpineGrp that prevented multiple character spines from being created in the same scene.
v. 2.2 -- Added Joint Orient Rotation Tool to Tools menu.
v. 2.2.1 -- Improved skeletonBuilder's orientation of joints in legs and feet when the limb has been rotated in Z.
v. 2.2.2 -- Added tool to add weight joints to a skeleton (useful for the lower leg), Tools > Add Weight Joint Tool.  Removed snap to PV warning for legs (they work when rotated -- the arms still don't).
v. 2.2.3 -- Leg split joints now rotate properly when the knee is brought above the waist.
v. 2.2.4 -- Fixed rt_thumb_grpLoc default skeleton proxy positioning.
v. 2.2.5 -- Added djx's fix to GroupFreeze procs.  Character name must now be unique before a proxy can be skeletonized.
v. 2.3 -- Changed min value on armStretch and legStretch attributes to -9.9 (arms and legs can now stretch negatively).  Improved default finger joint LRA orientation.
v. 2.4 -- Added "Align Control Curves to Spine" button on the Spine tab.  If enabled the mid and high spine controls will align to their respective joints; otherwise they'll lie on the XZ plane (the previous default).
v. 2.5 -- rt_thumb_a_loc is now properly parented in proxy (to rt_thumb_grpLoc).  Added "Quick Create Character Set" to tools menu.  Select a control curve on your rig and then run it.
v. 2.6 -- Added "Change Rotation Order Tool" to tools menu.  It will change the rotation order on the selected curves and maintain their orientation.  It won't work on transforms with incoming connections on any of the rotation channels.
v. 2.7 -- Simplified the spine.  It should be a lot less flippy now.  Note that although the spineRot control curve no longer holds spine twist attributes, it's still used as an attribute holder for the arm, leg and hand setups (so don't delete it).
v. 2.7.1 -- Fixed an issue with IK/FK arm snapping.
v. 2.7.2 -- Soft selection is now disabled before creating a rig.  It can cause an issue on 2009 and up (thanks bm jo).
v. 2.8 -- Fixed issue with limbs flipping when sliding IKFKBlend attribute values (finally!!)
v. 2.9 -- Big enhancements to the twist joint setup in this version.  There are now two types of split joints: inline, the previous type which are parented one to another, and branched, which are all parented to the up joint.  Use inline for upArm and upLeg joints (where twist is read from the upJnt) and branched for foreArm and knee (new!) split joints (twist is read from downJnt).  The forearm and knee twist is read from an aim constraint, which avoids a lot of gimbal lock problems with the wrist.  The idea is Adam Mechtley's (you can find his excellent videos at http://www.6ixsetstudios.com/tutorials/rigging/), so a huge thanks to him for spreading the wealth.  I've also added the "Add Split Joint" tool to the Tools menu, "Refresh UI" to the Options menu, and COG space to the hand IK controls.  The joints in the legs and arms are now checked to make sure that they're zeroed out before rigging.  Note: If you have issues with a knee or elbow shifting slightly after it's rigged, check to make sure that the preferred angle on your joints is 0 0 0.
v. 2.9.1 -- Adjusted proxy skeleton finger joints so that they're now aligned with their parent grpLocs.
v. 2.9.2 -- Arm IK/FK snap should now work with referenced characters.
v. 2.9.3 -- Added more softmod warnings.
v. 2.9.5 -- UpLeg and upLeg split joints now rotate as they should when the knee is brought above the waist (forgot to remove an old fix -- that's why this one reappeared).  Improved stretchy spline maker; control curves can now be parented to a root transform or to the curve below them in the hierarchy; spline IK now rotates properly in a rig setting; added the ability to select the spline's parent object in the UI (leave it empty and a new control curve will be created at the base of the curve).
v. 3.0 -- Added "Weight Joint Selector" to "Tools" Menu.  Use it to quickly select joints for weighting.  Hold the shift and control keys when clicking to add or subtract from the current selection.  Also added "Make abxPicker Character Sheet" which will create a character UI node for use with abxPicker.mel (http://www.highend3d.com/maya/downloads/mel_scripts/animation/4216.html).  Please, someone, make a better UI and send it to me -- I'll incorporate it into the script.
v. 3.0.1 -- Improved abxPicker UI.
v. 3.0.2 -- Fixed issues with non-mirroring pinky and ring cup joints.  Added "Make IK/FK Snap UI Shelf Button" to the "Tools" menu (create a snap IK/FK shelf button for existing characters) and "Auto Build IK/FK Snap UI Button" to "Options" (uncheck it if you get the error "Object Not Found: Toolbutton 1" on rigging arms or legs).
v. 3.0.3 -- Improved "Make IK/FK Snap UI Shelf Button".
v. 3.0.5 -- Added "toeRaise", "ballRaise", and "heelTwist" attributes to the foot setup
v. 3.0.6 -- Fixed issue with "Make IK/FK Snap UI Shelf Button".
v. 3.1 -- Check Character names for and remove "lf" and "rt" strings (can cause issues).  Added popup menu to charName field to quickly select existing characters.  Fixed issue with mirrorObj function and objects with shared names.  Improved heelLoc positioning method (esp. when ball and toe don't share the same Y translation), and foot IK control positioning when there are rotations on the proxy skeleton's foot_grpLoc.
v. 3.11 -- Added abRTWireReplaceUI fix for Maya 2011 from Highend user cutjules1 (thanks Julien!).
v. 3.2 -- Shelf will be now enabled if off.  Adjusted UI sizes for 2011 and up.  Added "Mirror From To" to Wire Replace UI (select a source curve then a destination curve and click).
v. 3.3 -- Removed redundant function "abRTGetCtrlCrvs" (replaced instances with "abRTGetRigGrpCtrlCurves").  "Save Wires To Shelf" now works on rigs other than the just the original they were saved from.  Hold the Control key when clicking a wire restore shelf button to replace only the selected curves.
v. 3.4 -- Fixed issue with hand not snapping from IK->FK and FK->IK using IK/FK snap UI.
v. 3.5 -- Changed hand setup so that it makes more sense.  "fkAlign" attribute on hand_ctrl became "align" on the fk_hand_ctrl and It now blends smoothly between IK and FK.  Added "Select All Character Controls" and "Reset Character To Proxy Pose" to "Tools" menu.  Characters can now be rigged in non T-Poses: arms can be at the side, knees and feet can be rotated in Y -- stuff you couldn't do before.  Skeletons will be created in T-Pose, but once the character is rigged, you can use the "Reset Character To Proxy Pose" option to recall the proxy pose and bind your mesh.  Note that the skeleton still needs to be rigged in the T-Pose, so always return to the default pose before removing or rebuilding part of the rig.
v. 3.6 -- Lots of new hand controls.  Added Fk Controls to fingers (enable with "fkFingerCtrlVis" on "handCtrl") and finger curl controls (enable with "fingerMasterCtrlVis" on "handCtrl").  "Wire Replace UI" now works on multiple object selections (where appropriate).  Removed "Auto Build IK/FK Snap UI Button" (threw errors in 2012 service pack 1) and added "Show IK/FK Snap UI" to "Tools".
v. 3.7 -- Skeletons recalled from shelf button saves no longer respect settings in skeletonMakerUI (fingerNum), which is the way it should be.
v. 3.8 -- Option for up to three neck joints, and up to 8 spine control curves.  Spines of more than three joints can be created with or without a spineShaper control.  Added neckMasterCtrl to move multiple joints at once.  Spine (and now neck) controls' "useRootSpace" attribute is now a float value instead of a boolean (and so can be blended).  Got rid of Head IK control and moved its functions to the head control curve.  If you hold the Control key and click on a Proxy Save shelf button, the proxy will be created with the fingerNum, spineNum, and neckNum specified in the skeletonBuilder UI.  Otherwise it's rebuilt as it was saved, regardless of the settings in the UI.  Shelf buttons should now work when the script hasn't been sourced.  Main UI checkboxes now remember their settings.
v. 3.9 -- Added "Wire Color Control" tool to "Tools" menu.  Select a control curve on your rig and run it.  Colors are updated as you adjust the sliders.  "Save Wires To Shelf" tool now saves control color in addition to curve information.  Hold Shift when clicking a Wire Save shelf button to restore only the control colors (not shape info) to the selected rig.  Remember, you can also hold Control when clicking a Wire Save button to restrict the restore to only the selected control curves.
v. 3.9.2 -- Rig build options (number of weightSpineJnts, fingerIK, etc.) are saved in the skeleton and loaded in the UI when a character is selected.  RigRemover will no longer remove parts of the rig out of order.  Rearranged "Tools" menu.
v. 3.9.3 -- Added masterSpine_ctrl.  Can be used like masterNeck_ctrl to rotate and move all of the spine controls above the COG.  The influence of the master over each control can be specified in "Spine Master Control" section of attributes on the "rigSettings_ctrl".
v. 3.9.4 -- Added "Space Switcher" Tool to "Tools" menu.  Switch spaces on a selected control while maintaining its position in worldSpace.
v. 4.0 -- Added ability to rotate wires to "Wire Replacer".  Changed some of the default control curve types (finger FK is now a flattened circle instead of a sphere).  Improved control curve quality.  Sharp corners and curves living happily together on the same curve.  Lots of wire related bug fixes.
v. 4.1 -- Changed rotationOrder on FK limb controls.  Added "Mirror Pose" tool to "Tools" menu.
v. 4.2 -- IK/FK snap should now work with new hand setup.  
v. 4.3 -- Added "Master Spine Ctrl" to hand and finger spaces.  Improved hand setup and IK/FK snapping.  Renamed "spineSplitRot_ctrl" "rigSettings_ctrl".
v. 4.4 -- FK align attributes are now float values (that can be blended) instead of simple on/off attributes.  Added a manual inline split control to foreArms and knees.  Set "foreArmTwistCtrl" and "lowLegTwistCtrl" (on hand and foot control curves respectively) to 1 for full manual control, and a value between 0 and 1 to blend with the auto twist.  Added four new shapes to wireReplacer -- gear_1, gear_2, twister_1, and twister_2.  Further improved stability of hand setup.  
v. 4.4.1 -- Fixed some skeleton proxy bugs.  Adjusting "Spine Num:" and "Neck Num:" values in skeletonBuilder will change the number of each for the active proxy skeleton.
v. 4.4.2 -- Locked all but active rotation axis on elbow fk control.
v 4.5 -- Implemented no-flip shoulder, and it works beautifully.  But it requires a new layered limb and split joint system -- existing skeletons will have to be reweighted to the new weight joints.
v. 4.6 -- Arm, Leg and Spine weight joints are now created when a skeleton is built (no more having to build a rig to create weight joints).  Removed Insert Split Joints tool.
v. 4.7 -- Added "Head/Neck" to Weight Joint Selector.  Added "Skeleton Updater" to the advanced version of the script.
v. 4.8 -- Added character Marking Menu to advanced version of the script.  Use "Install Character Marking Menu" option in the "Tools" menu to assign it to a hotkey.
v. 4.8.1 -- Updated skeletons use correct charName even if not set in UI.  Fixed neck joint selection issue in weight joint selector.
v. 4.8.2 -- Weight joints are no longer all deleted when the up or down number of splits changes.
v. 4.8.5 -- Legs stretch again.  More robust workflow for skeleton updating.  Added ability to bake masterSpine and masterNeck rotations to influenced controls.
v. 4.9 -- Finger master controls can now be moved up and down to adjust mid and tip curl relative to base curl.  Curl amount for .ty movement can be set with the "midCurlCtrlSpeed" and "tipCurlCtrlSpeed" attributes on the rigSettings ctrl.
v. 4.9.5 -- Added the ability to bake masterFinger controls to either the FK finger controls or the finger attributes on the hand_ctrl.  In IK mode SpineCtrl curves are now parented to the cogCtrl.  Switched "useRootSpace" attribute on spine curves to "useCogSpace".  
v. 5.0 -- Not really a feature, but there are now two versions of abAutoRig: standard and premium.
v. 5.1 -- Improved align functionality on multiple neck controls (can now rotate rootCtrl without causing issues); added useRootSpace attribute to mid neck controls;  Fixed naming issue (certain rig components were missing part of their names);  Completely split premium and standard into two separate scripts instead of piggybacking one on the other (reduces a bunch of sourcing complexity).
v. 5.11 -- Fixed issue where script wasn't properly inited when called only from the marking menu.  Use the "Install Marking Menu" tool to remove and reinstall the marking menu to update.
v. 5.13 -- Proxies can now optionally be built in the proxy pose (though you should still build in the T-Pose).
v. 5.2 -- Added choice to omit spineShaper when creating a character with three spine controls (Premium).  Fixed issues with marking menu installer (Premium).  Added two new color categories for left and right finger controls (Premium).  Clavicle and Finger control curves are now colored like their respective arm controls.
v. 5.21 -- Improved robustness of upleg and knee orientation on skeleton creation, which should prevent bad rotation issues on upleg split joints reported by Droo.
v. 5.3 -- Added option to create rubberhose limbs (Premium).  Hooray!!  Added "useAimTwist" attribute to hand and foot ctrl curves.  Enabled (set to one) it will use the previous aim constraint method of reading twist from wrist and ankle joints, set to zero it will use a ikHandle based reader, which is less prone to flipping.  Note that there is now no distinction in the way the upper and lower limb split joint twist values on the rigSettings_ctrl are interpreted.  Each value is now specified as the percentage (0 to 1) of the limb section's total twist that the split joint should inherit.  
v. 5.4 -- Added a set of jaw joints, which get rigged along with the head.  Delete them before rigging if you don't need a jaw.
v. 5.5 -- Added ribbon spine with squash and stretch (S&S).  Arms and legs now support S&S (Premium), as well.  For each S&S system, there is a set of attributes created on the cogCtrl, footCtrl, or handCtrl curves (based on the part of the rig being created with S&S) and another set added to the rigSettings curve.  The limb ctrl curve (cog, foot, or hand)  will hold two new S&S attributes: "autoSquashStretch" (enable for stretch to be calculated automatically), and "squashStretch" (if autoSquashStretch is disabled, you can use this attribute to manually adjust the amount of S&S).  The rigSettings ctrl will receive the following S&S attributes: "limbMaxStretchAmt" (the minimum value that the joints will not scale below when the limb is stretched), "limbStretchSpeed" (how quickly the limb S&S value will reach its maxStretchAmt scale when stretched), "limbMaxSquashAmt" (the maximum value that the joints will not scale above when the limb is squashed), "limbSquashSpeed" (how quickly the limb S&S value will reach its maxSquashAmt scale when squashed), and a series of "limb_n_SsScale" attributes (a zero to one value which determines how much a given joint will scale in relation to the total amount of S&S specified for the limb).  Added option for adding lattice based S&S to the head (Premium), which can be applied any time after the head rig has been built.  Added eyes and jaw to Weight Joint Selector.  UpLimb joints now have attribute to specify twist inherit on the rigSettingsCtrl curve.  Fixed bugs with the rubberhose arms that caused the wrist to be flippy (Premium).  Fixed issue with rubberhose UI not updating correctly.  Note that scaling joints (as the rig does to create Squash and Stretch) can cause issues when working with Dual Quaternion skinned meshes.  I'm not sure why, but it doesn't happen when the "Classic Linear" skinning method is selected in the skinCluster node.
v. 5.6 -- New features for the "Make Stretchy Spline" tool.  Added the ability to specify the pivot orientation and size of the FK control curves (Standard and Premium).  Added the option to "Add Dynamics" which creates a dynamically driven ikSpline that can be blended with the standard FK spline (Premium).  Great for stuff like antennas.  Added "HeadSqStrLatticeVis" attribute to the rigSettingsCtrlCrv when the Head Squash and Stretch Rig is applied (Premium).
v. 5.61 -- Added option to rotate a joint's local rotation axes (LRAs) by a custom amount in the "Joint Orient Rotation Tool".  Fixed issue with split joints not appearing when the upper or lower number of splits is set to zero.
v. 5.7 -- Fixed issue with wrist joint not following the arm (Standard and Premium).  Don't know how I missed it, but it was introduced in one of the last updates.  Fixed bad wrist rotation values (too high) causing over rotation (Standard and Premium).  Added translateable hip and shoulder controls (with visibility controls on the foot and hand control curves) (Premium).  Added rubberhose controls for knees and elbows to move them independently of the limb joint chain (Premium).  Adjusted default S+S values.
v. 5.71 -- Added "localAlign" to controls with "align" attribute (Standard and Premium).  If enabled, FK controls with "align" set to 1 will only align to compensate for the shoulder (arms) or hip (legs) controls.  Any control or joint rotations in the hierarchy above those will not be compensated for.  Hard to explain.  Play around with it and you'll get it.  Also added "Space Switch Matcher" to the Marking Menu.
v. 5.72 -- Fixed issue that threw an error when attempting to apply S+S to the head for the first time.
v. 5.73 -- Fixed issues with functions that relied on curve selection (to specify a character) not working with referenced or multiple characters in a scene (spaceSwitcher, IK/FK snap, Save Wires to Shelf, etc).  Fixed overlapping varName issue that could occur when scaling control curves with wireReplaceUI.
v. 5.74 -- Added the option for the foot IK control curve to rotate about the ankle instead of the heel.
v. 5.75 -- ikFkSnapUI now switches the ikFklend attribute on the affected limb to display the "matched" limb (IK or FK).  Added option of a more advanced abxPicker character sheet (thanks Rey!).
v. 5.76 -- Removed old IK/FK Snap UI and replaced it with a more universal UI based on the Marking Menu version.  No more selecting namespaces: select a control related to the limb (the recognized controls have been expanded to the finger, shoulder and hip controls) and click a button to switch.  Replaced Snap UI entries in the "Tools" menu with "Show IK/FK Snap UI" and "Show IK/FK Toggle UI."  Hold ctrl(command)+shift and click one of the Snap UI "Tool" menu items to create a shelf button.
v. 5.77 -- "Recall Proxy Pose" now recalls wrist rotation (Premium).  MasterFingerControls align to the fingers correctly when hand is built with X rotation (no longer aligns to world axes).  Added features to abxPicker "Advanced" template.  Added missing "Select All Character Controls" function to Standard version.
v. 5.78 -- MasterSpineCtrl now affects the low spine control curve in addition to the others.  Arm and leg weight joints can now be created in a hierarchy instead of free floating (which may help with skinning issues).  Set by clicking the "Create Hierarchical Limb Weight Joints" checkbox in Skeleton Maker.  Added "Apply All Rotations To Mirror Joint" to Joint Orient Tool.  Improved finger IK: tip rotation is now bound to the finger IK control with an ikHandle instead of an orientConstraint.  As a result the finger tips rotate more realistically when the finger IK is stretched.  Added "Unstickify IK Limb" to the "Tools" menu.  Use it if an IK limb isn't solving correctly (select a control curve on the affected limb and click "Unstickify IK Limb").  Added abAutoRigAnimatorTools to Premium.  It allows animators who don't need any of abAutoRig's rigging tools access to its animation tools, like the marking menu, IK/FK snapping, space switching, etc.  You are welcome to use it with any number of animators working on a project with at least one registered copy of abAutoRig Premium.  However, because the tools overlap some of those in Premium, you are not allowed to redistribute it.   Please do not include it with any characters rigged with abAutoRig that you release to the public.  Doing so would be severely uncool.
v. 5.781 -- Ok, so "new improved IK fingers" not so much.  Sorry about that.  Back to how it was.
v. 5.79 -- This update is all about the wires:  Wire saves are restored in object space which allows applying wire schemes from other characters (thanks leonsooi!).  Lots of improvements to the Wire Replace UI.  Wire rotation, axis and scale are now saved inside the curves.  Wires now adjustable in place (they won't snap back to their parent origin).  Improved several wire shapes.  Added "Center On Pivot" which will center the selected wires on their pivots (good for reseting PV controls after applying wires saved from a different character).  Added "Center On Object" which will center a selected wire on a selected object.  Split the copy function into "Copy From To (Absolute)" and "Copy From To (Relative)."  Use the second to copy from one to many.  Improved the way in which wires are rotated.
v. 5.791 -- Added terms of use.  Eyes no longer roll when character rootCon is rotated (thanks Arron!).  Fixed issue with incorrect upLimb split joint rotation when shoulder or hip controls were translated (thanks Szabolcs!).  Compatibility fixes for Maya 2010.
v. 5.792 -- UpLimb joints and splits should rotate correctly once again (Standard and Premium).
v. 5.793 -- Fixed issue rigging arms and legs on characters with no split joints.
v. 5.8 -- (All fixes Premium only) Hugely improved wrist joint rotation with rubberHose (RH) limbs.  It's now much less flippy.  RH wrist joint also now responds correctly to manual twist control inputs.  Changed RH so now, when there is more than one lower limb split joint, the last one is point constrained to the ribbon follicle instead of parentConstraint in order to eliminate over rotation.  Added secondary FK controls to the upLeg, ankle, upArm, and wrist FK controls (which are hidden by default).  Moved discreet FK and IK switch menu items to "FK/IK Switch" sub menu and added "Toggle FK/IK" to the "E" position on the character marking menu.
v. 5.81 -- (All fixes Premium only) Changed abRTMakeSplitJointTargetLoc function so upLimb aimLocs are parented to a dummy joint which is connected the the twisting upJnt via connectAttr (t, r, and s).  The upshot of this is that rubberHose limbs (mostly the left one) should no longer lock after having been stretched (sssuming the "stretchyLimb" attribute is enabled).  Thanks to Ozgur for all the help in troubleshooting this and other esoteric issues.  Knee and elbow sharpnesses now default to three; "Add Elbow RH Control" is now enabled by default.  Weight joints are now attached to rootCtrl "skeletonVis" attribute when created.
v. 5.9 -- (All fixes Premium only) Moved Reset Pose functions to new script menu, "Reset Pose" and added three new menu items: "Set Current Pose As Default" -- group freezes (or moves previously created zeroFreezeGroups of) all the controls of the currently selected character so that the current pose will become the character's default pose (in this way, you can set your proxy pose as your default), "Restore Build Pose As Default" -- Adds (or moves existing) zeroFreezeGroups with no offset so that the build pose will become the character's default pose, and "Remove Zero Pose Freeze Groups" -- remove all zeroFreezeGroups from the selected character so that the build pose will become the character's default pose.  To allow poses to be frozen, PV controls are positioned in such a way that they no longer need to have their transforms frozen.  Added knee and elbow softness attributes to foot and hand controls, respectively, which replace the knee and elbow sharpness sliders in the UI.  Rigs are no longer limited to a single knee or elbow sharpness; it's now adjustable (and called "softness").  Added Master and subMaster controls (hidden by default), accesable via visibility attributes on the rootCtrl.  "skeletonVis" attribute on rootCtrl now toggles display override of the skeleton group (connecting it to visibility was causing issues with sticky IK limbs for some reason).  Several controls that previously had their transforms frozen are now just groupFrozen (to accommodate the "Set Default Pose" feature).  Added translation attributes to clavicle controls; changed clavicle control suffix to "_ctrl" from "_fk_ctrl".  abRTGetMirrorObj() now attempts to match by name first, so it should be much faster.  Added some controls that were being skipped to MirrorPose.
v. 5.91 -- (All fixes Premium only) Fixed shoulder flipping issue.  Moved clavicle translation attributes to clavicleTrans_ctrl, visibility of which is toggled from clavicle control.  Restored previous clavicle_ctrl rotation orientation.  Minor fixes to "Mirror Pose" and "Set Current Pose As Default".
v. 5.92 -- (All fixes Premium only) Fixed slightly off rotations of the last split joint(s) on rubberHose limbs.
v. 5.93 -- (All fixes Premium only) Hand controls (both IK and FK) will now rotate to match the orientation of the hand joint.  Skeletons are built with identically oriented hand and wrist joints, so if you don't adjust the hand joints' orientations, the controls will be oriented as they have been.  However, if you're planning to bind your skeleton in its proxy pose (some pose other than a T), the hand controls as rigged in the T-pose might not match your preferred orientation.  Now, you can rotate either hand joint before you rig (the easiest way is to use the "Joint Orient Rotation Tool" in the "Tools" menu, which will automatically mirror your adjustments), and the controls will be built to match it.  Removed even more flipiness from upper shoulder.  Added optional rotationOrder att to rigSettings Ctrl when $locVis is true in abRTMakeSplitJointTargetLoc (not really important to anyone but me).
v. 6.0 -- Lots of Improvements to split joint weighting.  Added "Split Joint Weighter" to "Tools" menu.  It's a UI to help quickly set the twist contributions of multiple upLimb split joints by specifying the first and last joint twist amounts (I recommend beginning with a start value of .4).  Added "Set Split Joint Weight Defaults" and "Revert To Default Split Weight Settings" to the "Options" menu.  Note that split joint weight settings are saved inside the skeleton of a rig, so when you load a character that has previously been rigged into the UI, its default split weight settings will overwrite the previous default settings.  Use "Revert To Default Split Weight Settings" to get back to the default settings.  Added buttons to adjust the split joint settings to the "Leg" and "Arm" tabs of the UI.  Elbows and knees are now rotatable in both Z and Y.  Rotating them in their secondary axis will contribute to the upLimb twist.  You can disable this twist contribution by setting the "midJntUpLimbTwistScalar" attribute (found on the hand and foot control curves) to zero.  Note that switching limbs with non-zero secondary rotations from FK to IK will sometimes display twist discrepancies (yes dear reader, the very same twist discrepancy issue first elucidated upon by the esteemed F. S. Scrimmenhour in the year 1843).  The default elbow FK control rotationOrder is now "xzy", and the default knee FK control rotationOrder is "xyz".   Added "upLimbAutoTwist", "upLimbTwist", "upLimbTwistScalar", and "midJntUpLimbTwistScalar" (mentioned above) attributes to the hand and foot control curves.  If "upLimbAutoTwist" is 1, the upLimb will rotate as it always has and the "upLimbTwist" can be used to modify the twist amount.  If "upLimbAutoTwist" is 0, the upLimb will only rotate based on the value of "upLimbTwist".  "upLimbTwistScalar" allow you to adjust how much of the actual twist reader's rotation is fed to the twist joints.  E"midJntUpLimbTwistScalar" allows you to disable the off axis ro  Changed mid RH control joint frzGroup (charName_lf_elbowRubberHose_ctrl_frzGrp) constraint type to "average" from "no-flip" to prevent RH elbow flip at full extension in earlier versions of Maya.  Added shoulder and hip controls that were being missed to mirrorPoseUI.  UpCtrlParentSplitJnt is now reverse rotated to offset upArmJnt rotation when setting up non-RH limbs with split joints.  Exposed rotate attributes on PV controls to allow spaceSwitching to match rotation.
v. 6.03 -- Updated "abRTDuplicateJointHierarchy" function to correct for crash when rigging legs in Maya 2014.

*/



global proc abRTInit(){
	// inits globals
	
	global int $abRTInit;
	
	if (!$abRTInit){
		abRTGlobals();
		$abRTInit = true;
	}
}


global proc string[] abRTGetHierarchy(string $startJnt, string $endJnt, int $retEmptyOnFork){
	/*
	returns all joints in direct hierarchy (including startJnt and endJnt)
	leave $endJnt as "" to crawl return jnts all the way to the bottom of the hierarchy
	if there are downward facing forks or if the joints aren't connected, an empty array will be returned, unless $retEmptyOnFork is false.
	*/
	
	$startJnt = longNameOf($startJnt);
	$endJnt = longNameOf($endJnt);
	
	string $aAllRel[] = `listRelatives -ad -type joint -fullPath $startJnt`;
	string $aRel[], $aRet[], $jnt, $aStr[];
	int $i;
	
	$jnt = $startJnt;
	$aRet = {$jnt};
	
	for ($i=0;$i<size($aAllRel);$i++){
		$aRel = `listRelatives -c -type joint -fullPath $jnt`;
		if (size($aRel) == 1){
			$jnt = $aRel[0];
			$aRet[size($aRet)] = $jnt;
			if ($endJnt != "" && $jnt == $endJnt){
				// we found our joint
				break;
			}else{
				continue;
			}
		}else if (size($aRel) > 1){
			// downward fork
			if ($retEmptyOnFork) clear $aRet;
			break;
		}else{
			// no children -- we made it to the end
			break;
		}
	}
	
	return $aRet;
}


global proc abRTQuickGroupFreeze(){
	// select target object followed by object to snap to -- no constraints will be created
	
	string $obj;
	string $aSel[] = `ls -sl -type transform`;
	for ($obj in $aSel) abRTGroupFreeze($obj, 1);
	
}


global proc abRTPointConnect(string $target, string $follower, int $type){
	/*
	creates something like a point constraint by connecting translation attribtutes of $follower to $target
	$type is x=1 y=2 z=4 -- add them together to specify which atts you want connected xy would be 3, zx would be 5, etc
	*/
	
	if (($type % 2) == 1 && !(`isConnected ($target+".tx") ($follower+".tx")`)) connectAttr ($target+".tx") ($follower+".tx");
	if ($type != 4 && $type != 5 && $type != 1 && !(`isConnected ($target+".ty") ($follower+".ty")`)) connectAttr ($target+".ty") ($follower+".ty");
	if ($type >= 4 && !(`isConnected ($target+".tz") ($follower+".tz")`)) connectAttr ($target+".tz") ($follower+".tz");
}


global proc abRTOrientConnect(string $target, string $follower, int $type){
	/*
	creates something like an orient constraint by connecting translation attribtutes of $follower to $target
	$type is x=1 y=2 z=4 -- add them together to specify which atts you want connected xy would be 3, zx would be 5, etc
	*/
	
	if (($type % 2) == 1 && !(`isConnected ($target+".rx") ($follower+".rx")`)) connectAttr ($target+".rx") ($follower+".rx");
	if ($type != 4 && $type != 5 && $type != 1 && !(`isConnected ($target+".ry") ($follower+".ry")`)) connectAttr ($target+".ry") ($follower+".ry");
	if ($type >= 4 && !(`isConnected ($target+".rz") ($follower+".rz")`)) connectAttr ($target+".rz") ($follower+".rz");
}


global proc abRTQuickLine(){
	// select two transforms, call this proc, and a line is created from the first selected to the second
	
	string $aSel[] = `ls -sl -type transform`;
	if (size($aSel) == 2) abRTConnectWithLine($aSel[0], $aSel[1]);
	
}


global proc string abRTGroupFreeze(string $obj, int $delete){
	/*
	parents $obj under a group snapped and oriented to its position to zero out transforms
	delete: 0 -- keep created constraints
	delete: 1 -- delete both constraints
	delete: 2 -- keep point constraint
	delete: 3 -- keep orient constraint
	returns name of created null
	*/
	
	string $gpName = "|"+(`group -em -name (abRTStripPath($obj)+"_frzGrp")`);
	select -r $obj $gpName;
	abRTPointOrient($delete);
	select -clear;
	string $aRel[] = `listRelatives -p -fullPath -type transform $obj`;
	if (size($aRel) > 0) $gpName = abRTParent($gpName, $aRel[0]);
	parent $obj $gpName;
	
	return $gpName;
}


global proc string abRTGroupFreezeReturnObj(string $obj, int $delete){
	/*
	same function as above, but returns new obj path
	*/
	
	string $gpName = "|"+(`group -em -name (abRTStripPath($obj)+"_frzGrp")`);
	select -r $obj $gpName;
	abRTPointOrient($delete);
	select -clear;
	string $aRel[] = `listRelatives -p -fullPath -type transform $obj`;
	if (size($aRel) > 0) $gpName = abRTParent($gpName, $aRel[0]);
	$obj = abRTParent($obj, $gpName);
	
	return $obj;
}


global proc abRTPointOrient(int $delete){
	/*
	delete: 0 -- keep created constraints
	delete: 1 -- delete both constraints
	delete: 2 -- keep point constraint
	delete: 3 -- keep orient constraint
	*/
	
	string $aPointCons[], $aOrientCons[], $pointCons, $orientCons;
	
	$aPointCons = `pointConstraint -offset 0 0 0 -weight 1`;
	if ($delete == 1 || $delete == 3) for ($pointCons in $aPointCons) delete $pointCons;
	$aOrientCons = `orientConstraint -offset 0 0 0 -weight 1`;
	if ($delete || $delete == 2) for ($orientCons in $aOrientCons) delete $orientCons;
}


global proc abRTSnapToPosition(string $sourceObj, string $targObj){
	// snaps targObj to sourceObj position
	
	select -r $sourceObj $targObj;
	abRTPointOrient(1);
	select -clear;
}


global proc abRTConnectMirrorTrans(string $obj1, string $obj2, int $axis){
	// connects $obj1 and $obj2 translation on $axis axis to mirror across the origin ($axis: 0,1,2 = x,y,z)
	
	string $aAxisStr[] = {"x", "y", "z"};
	string $axisStr = ".t"+$aAxisStr[$axis];
	
	string $revNode = `createNode plusMinusAverage -n "abRTMirrorTransPlsMns"`;
	setAttr ($revNode+".operation") 2;
	setAttr ($revNode+".input1D[0]") 0;
	connectAttr -f ($obj1+$axisStr) ($revNode+".input1D[1]");
	connectAttr -f ($revNode+".output1D") ($obj2+$axisStr);
	
}


global proc abRTConnectMirrorRot(string $obj1, string $obj2, int $axis){
	// connects $obj1 and $obj2 translation on $axis axis to mirror across the origin ($axis: 0,1,2 = x,y,z)
	
	string $aAxisStr[] = {"x", "y", "z"};
	string $axisStr = ".r"+$aAxisStr[$axis];
	
	string $revNode = `createNode plusMinusAverage -n "abRTMirrorRotPlsMns"`;
	setAttr ($revNode+".operation") 2;
	setAttr ($revNode+".input1D[0]") 0;
	connectAttr -f ($obj1+$axisStr) ($revNode+".input1D[1]");
	connectAttr -f ($revNode+".output1D") ($obj2+$axisStr);
	
}


global proc string abRTStripPath(string $obj){
	// returns basename of a transform without path
	
	string $aName[], $name;
	$aName = stringToStringArray($obj, "|");
	return ($aName[size($aName)-1]);
}


global proc string abRTStripRoot(string $obj){
	// returns basename of a transform without initial "|"
	
	if (startsWith($obj, "|")) $obj = `substring $obj 2 (size($obj))`;
	return $obj;
}


global proc string abRTConnectWithLine(string $obj1, string $obj2){
	// connects two transforms with a line
	
	// unparent children
	string $aObj2Children[], $aObj2UpChildren[], $lineShape, $aStr[], $aRel[], $obj2Parent, $origName, $origPath, $tObjPath, $taChildrenPath[], $tGrp, $tGrp2;
	$aObj2Children = `listRelatives -children -type transform -fullPath $obj2`;
	if (size($aObj2Children) > 0) $aObj2UpChildren = `parent -w $aObj2Children`;
	// done
	
	string $lineName;
	float $xForm[], $aCenter1[];
	
	string $annLoc = abRTMakeLocator(((abRTStripPath($obj2))+"_annLoc"));
	pointConstraint $obj2 $annLoc;
	setAttr ($annLoc+".v") 0;
	$lineShape = `annotate -tx "" $annLoc`;
	parent $annLoc $obj2;
	
	$aStr = `listRelatives -p -type transform $lineShape`;
	if (size($aStr) == 1) $lineName = $aStr[0];
	
	// problem when obj2 has been frozen
	
	parent $lineName $obj1;
	abRTSnapToPosition($obj1, $lineName);
	
	setAttr ($lineShape+".overrideEnabled") 1;
	setAttr ($lineShape+".overrideDisplayType") 2;
	
	// reparent children
	if (size($aObj2Children) > 0){
		int $i;
		$aObj2UpChildren = `parent $aObj2UpChildren $obj2`;
		
		for ($i=0;$i<size($aObj2UpChildren);$i++){
			$origName = abRTStripPath($aObj2Children[$i]);
			if ($aObj2UpChildren[$i] != $origName) rename $aObj2UpChildren[$i] $origName;
		}
	}
	// done
	
	select -clear;
	
	$lineName = `rename $lineName ("abRTLine_"+abRTStripPath($obj1))`;
	return $lineName;
}


global proc abRTOutputLocStructure(string $rootLoc){
	
	string $aLoc[] = abRTEncodeLocStructure($rootLoc);
	string $locStr = stringArrayToString($aLoc, "\",\"");
	$locStr = "{\""+$locStr+"\"}";
	
	print $locStr;
	
}


global proc string[] abRTEncodeLocStructure(string $rootLoc){
	/*
	given the root loc of a proxy rig (under which all others are parented) this will arrange the locs in an array that can be used to 
	rebuild the hierarchy.
	return string form is {locator1Name, locator1Parent, locator2Name, locator2Parent} -- if parent is $rootLoc, locatorParent will be represented with "*"
	string will be returned in order so that parents of locators are created before their children, so, if you create locs starting with the 
	beginning of the array, you'll never parent a loc to a nonexistent node
	returns (locName, locParent, locTransString("tx|ty|tz&rx|ry|rz&sx|sy|sz"), frozen(bool))
	as of v 2.1 of the script, the return string also includes the current offsets tacked on to the end of the locTransString, so it now looks like "tx|ty|tz&rx|ry|rz&sx|sy|sz|cbTx|cbTy|cbTz&cbRx|cbRy|cbRz&cbSx|cbSy|cbSz" where "cb" prefix stands for the channelBox value of an attribute (not the ws value)
	*/
	
	string $aRet[];
	
	if (`objExists $rootLoc`){
		
		string $aChildren[], $aParents[], $aRel[], $objPath, $objName, $parent, $baseName;
		string $aTempSort[]; // used to sort locs by the depth of their path
		
		string $aSel[] = `listRelatives -allDescendents -fullPath -type transform $rootLoc`;
		
		for ($objPath in $aSel){
			if (endsWith($objPath, "_loc") || endsWith($objPath, "_grpLoc")){
				$baseName = abRTStripPath($objPath);
				if (!startsWith($baseName, "abRTLine_")) $aChildren[size($aChildren)] = $objPath;
			}
		}
		
		// sort locs by the depth of their path
		for ($objPath in $aChildren){
			// ignore line related transforms
			$objName = abRTStripPath($objPath);
			
			// size of $aParents will never be smaller than 2
			$aParents = stringToStringArray($objPath, "|");
			$parent = $aParents[size($aParents)-2];
			if ($parent == $rootLoc) $parent = "*";
			
			$aTempSort[size($aTempSort)] = $objPath;
			$aTempSort[size($aTempSort)] = $objName;
			$aTempSort[size($aTempSort)] = $parent;
			$aTempSort[size($aTempSort)] = size($aParents) - 2;
		}
		
		string $aTemp[], $locTransStr, $locColorIndex, $aRel[], $shape, $varType, $aRestoreTransTable[], $aLockedAtts[], $aConnectedAtts[], $att, $objAttStr, $attSfd;
		int $i, $depth, $cDepth;
		int $aOverride[];
		float $aTrans[], $aRot[], $aScale[], $aCbTrans[], $aCbRot[], $aCbScale[];
		string $aLockCheckAtts[] = {"tx","ty","tz","rx","ry","rz","sx","sy","sz"};
		string $aConnectedCheckAtts[] = {"tx","ty","tz","rx","ry","rz","s"};
		$cDepth = 0;
		
		// save rootLoc transform atts
		float $aRootLocScale[] = `getAttr ($rootLoc+".s")`;
		setAttr ($rootLoc+".s") 1 1 1;
		
		$aRet[size($aRet)] = $rootLoc;
		$aRet[size($aRet)] = "0";
		$aRet[size($aRet)] = "0|0|0&0|0|0&1|1|1&0|0|0&0|0|0&"+$aRootLocScale[0]+"|"+$aRootLocScale[1]+"|"+$aRootLocScale[2];
		$aRet[size($aRet)] = "1";
		
		// have to disconnect all connected objs first, otherwise resetting the positive x t, r, and s attributes will similarly affect the connected objs
		for ($i=0;$i<size($aTempSort);$i+=4){
			
			$objPath = $aTempSort[$i];
			
			// disconnect conected atts and save them to reconnect when save is complete
			for ($att in $aConnectedCheckAtts){
				$objAttStr = $objPath+"."+$att;
				
				// check for connected attributes
				$attSfd = `connectionInfo -sourceFromDestination $objAttStr`;
				if ($attSfd != ""){
					$aConnectedAtts[size($aConnectedAtts)] = $attSfd+">"+$objAttStr;
					disconnectAttr $attSfd $objAttStr;
				}
			}
		}
		// done
		
		string $tLoc = abRTMakeLocator("abRTEncodeStructureLoc");
		
		while (size($aTempSort) > 0){
			
			clear($aTemp);
			
			for ($i=0;$i<size($aTempSort);$i+=4){
				
				$objPath = $aTempSort[$i];
				$objName = $aTempSort[$i+1];
				$parent = $aTempSort[$i+2];
				$depth = $aTempSort[$i+3];
				
				if ($depth == $cDepth){
					
					$aRel = `listRelatives -type shape $objPath`;
					$shape = (size($aRel) > 0) ? $aRel[0] : "";
					
					// set the $obj channelBox trans, rot, and scale atts back to 0 and save those values as offsets (so when skeleton is recalled its local t, r, and s values are preserved)
					$aCbTrans = `getAttr ($objPath+".t")`;
					$aCbRot = `getAttr ($objPath+".r")`;
					$aCbScale = `getAttr ($objPath+".s")`;
					
					// save cb atts to restore once proxy has been saved ("objPath&tx|ty|tz&rx|ry|rz&sx|sy|sz"
					$aRestoreTransTable[size($aRestoreTransTable)] = $objPath+"&"+$aCbTrans[0]+"|"+$aCbTrans[1]+"|"+$aCbTrans[2]+"&"+$aCbRot[0]+"|"+$aCbRot[1]+"|"+$aCbRot[2]+"&"+$aCbScale[0]+"|"+$aCbScale[1]+"|"+$aCbScale[2];
					
					// unlock locked attributes and save them to lock again once save is complete
					for ($att in $aLockCheckAtts){
						$objAttStr = $objPath+"."+$att;
						
						// check for locked attributes
						if (`getAttr -lock $objAttStr`){
							$aLockedAtts[size($aLockedAtts)] = $objAttStr;
							setAttr -lock false $objAttStr;
						}
					}
					
					// set atts to default
					setAttr ($objPath+".t") 0 0 0;
					setAttr ($objPath+".r") 0 0 0;
					setAttr ($objPath+".s") 1 1 1;
					
					// make loc trans string
					abRTSnapToPosition($objPath, $tLoc);
					
					// now get the absolute values
					$aTrans = `xform -q -ws -t $tLoc`;
					$aRot = `xform -q -os -ro $tLoc`;
					$aScale = `xform -q -r -s $objPath`;
					
					$locTransStr = $aTrans[0]+"|"+$aTrans[1]+"|"+$aTrans[2]+"&"+$aRot[0]+"|"+$aRot[1]+"|"+$aRot[2]+"&"+$aScale[0]+"|"+$aScale[1]+"|"+$aScale[2]+"&"+$aCbTrans[0]+"|"+$aCbTrans[1]+"|"+$aCbTrans[2]+"&"+$aCbRot[0]+"|"+$aCbRot[1]+"|"+$aCbRot[2]+"&"+$aCbScale[0]+"|"+$aCbScale[1]+"|"+$aCbScale[2];
					
					$aRet[size($aRet)] = $objName;
					$aRet[size($aRet)] = $parent;
					$aRet[size($aRet)] = $locTransStr;
					$aRet[size($aRet)] = "1";
					
				}else{
					$aTemp[size($aTemp)] = $objPath;
					$aTemp[size($aTemp)] = $objName;
					$aTemp[size($aTemp)] = $parent;
					$aTemp[size($aTemp)] = $depth;
				}
			}
			$aTempSort = $aTemp;
			$cDepth++;
		}
		
		delete $tLoc;
		
		// restore channelBox attribute values		
		string $data, $aData[], $aTransData[], $aRotData[], $aScaleData[];
		for ($data in $aRestoreTransTable){
			
			$aData = stringToStringArray($data, "&");
			
			$objPath = $aData[0];
			
			// retrieve cb values
			$aTransData = stringToStringArray($aData[1], "|");
			$aRotData = stringToStringArray($aData[2], "|");
			$aScaleData = stringToStringArray($aData[3], "|");
			
			// restore cb values
			setAttr ($objPath+".t") (float($aTransData[0])) (float($aTransData[1])) (float($aTransData[2]));
			setAttr ($objPath+".r") (float($aRotData[0])) (float($aRotData[1])) (float($aRotData[2]));
			setAttr ($objPath+".s") (float($aScaleData[0])) (float($aScaleData[1])) (float($aScaleData[2]));
			
		}
		
		// relock previously locked atts
		for ($att in $aLockedAtts) setAttr -lock true $att;
		
		// reconnected previously connected atts
		for ($data in $aConnectedAtts){
			$aData = stringToStringArray($data, ">");
			connectAttr $aData[0] $aData[1];
		}
		
		// reset rootLoc scale att
		setAttr ($rootLoc+".s") $aRootLocScale[0] $aRootLocScale[1] $aRootLocScale[2];
		
	}
	
	return $aRet;
	
}


global proc float[] abRTGetProxyLocLocation(string $proxyLocName, string $aData[]){
	// returns ws translate, rotation, and scale info for a given proxy loc from the dataString $aData, or an empty array on failure.
	// form of {tx, ty, tz, rx, ry, rz, sx, sy, sz}
	
	string $aSubData[], $transStr[], $rotStr[], $scaleStr[];
	int $i;
	float $aRet[];
	
	for ($i=0;$i<size($aData);$i+=4){
		//{"skeleton_proxy_grpLoc","0","0|0|0&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","hip_loc","*"
		
		if ($aData[$i] == $proxyLocName){
			// only need first three sub arrays (don't need channelBox offsets)
			$aSubData = stringToStringArray($aData[$i+2], "&");
			$transStr = stringToStringArray($aSubData[0], "|");
			$rotStr = stringToStringArray($aSubData[1], "|");
			$scaleStr = stringToStringArray($aSubData[2], "|");
			
			// trans
			$aRet[0] = float($transStr[0]);
			$aRet[1] = float($transStr[1]);
			$aRet[2] = float($transStr[2]);
			// rot
			$aRet[3] = float($rotStr[0]);
			$aRet[4] = float($rotStr[1]);
			$aRet[5] = float($rotStr[2]);
			// scale
			$aRet[6] = float($scaleStr[0]);
			$aRet[7] = float($scaleStr[1]);
			$aRet[8] = float($scaleStr[2]);
			
			break;
		}
	}
	
	return $aRet;
}


global proc string abRTGetProxyLocParent(string $proxyLocName, string $aData[]){
	// returns parent of given proxy loc or nothing on failure
	
	int $i;
	string $ret;
	
	for ($i=0;$i<size($aData);$i+=4){
		
		if ($aData[$i] == $proxyLocName){
			$ret = $aData[$i+1];
			break;
		}
	}
	
	return $ret;
}


global proc string[] abRTRemoveProxyLocFromDataStr(string $proxyLocName, string $aData[]){
	// returns aData without entry for $proxyLocName
	
	int $i;
	string $aRetData[], $proxyParent;
	
	$proxyParent = abRTGetProxyLocParent($proxyLocName, $aData);
	
	for ($i=0;$i<size($aData);$i+=4){
		
		if ($aData[$i] != $proxyLocName){
			
			$aRetData[size($aRetData)] = $aData[$i];
			$aRetData[size($aRetData)] = ($aData[$i+1] == $proxyLocName) ? $proxyParent : $aData[$i+1];
			$aRetData[size($aRetData)] = $aData[$i+2];
			$aRetData[size($aRetData)] = $aData[$i+3];
		}
	}
	
	return $aRetData;
}


global proc string[] abRTRenameProxyLocInDataStr(string $proxyLocName, string $newName, string $aData[]){
	// renames all instances of proxyLocName to newName in $aData, returns modified aData
	
	int $i;
	int $ret = false;
	
	for ($i=0;$i<size($aData);$i+=4){
		
		if ($aData[$i] == $proxyLocName)
			$aData[$i] = $newName;
		
		if ($aData[$i+3] == $proxyLocName)
			$aData[$i+3] = $newName;
	}
	
	return $aData;
}


global proc string[] abRTObjExistInProxyDataStr(string $aObj[], string $aData[]){
	// returns objects in $aObj that exist in $aData
	
	string $aRet[];
	int $i;
	
	for ($i=0;$i<size($aData);$i+=4){
		if (abRTGetPosInStrArray($aData[$i], $aObj) != -1)
			$aRet[size($aRet)] = $aData[$i];
	}
	
	return $aRet;
}


global proc string abRTRecallLocStructure(string $aData[]){
	// recalls a given loc structure ($aData which is created by abRTEncodeLocStructure)
	// called from old version saved skeleton shelf buttons
	// kept to maintain compatibility
	
	string $rootLoc = abRTRecallLocStructureV2($aData, false);
	return $rootLoc;
}


global proc string abRTRecallLocStructureV2(string $aData[], int $useUIParams){
	// recalls a given loc structure ($aData which is created by abRTEncodeLocStructure)
	// if $useUIParams, it respects the values in the skeletonMaker UI (usually only when building a skeleton for the first time, not when recalling one).
	// returns rootLoc
	
	string $objName, $parent, $locTransStr, $locColorIndex, $aStr[], $aSubStr[], $loc, $aRel[], $ret, $baseName, $aRestoreAttTable[], $restoreAttData;
	float $aTrans[], $aRot[], $aScale[];
	int $i, $frozen, $colorInd;
	
	int $rootLocColorInd = 13;
	int $grpLocColorInd = 13;
	int $locColorInd = 15;
	
	// useUIParams if ctrl key is pressed
	int $mods = `getModifiers`;
	if ($mods / 4 % 2)
		$useUIParams = true;
	
	// need to offset scale for wire controller proc -- which bases size relative to global scale
	float $so;
	float $gScale = float(abRTGetGlobal("globalScale"));
	if ($gScale == 0) $so = 1;
	else $so = 1/$gScale;
	
	string $rootLocName = "skeleton_proxy_grpLoc";
	
	if (`objExists $rootLocName`) delete $rootLocName;
	string $rootLoc = abRTMakeLocator($rootLocName);
	
	abRTHideAttr($rootLoc, {"tx","ty","tz","rx","ry","rz","v"});
	
	$aRel = `listRelatives -type shape $rootLoc`;
	
	setAttr ($aRel[0]+".overrideEnabled") true;
	setAttr ($aRel[0]+".overrideColor") $rootLocColorInd;
	
	string $aXAxisUpCircleJnts[] = {"lf_clavicle_loc","lf_upArm_loc","lf_elbow_loc","lf_wrist_loc","rt_clavicle_loc","rt_upArm_loc","rt_elbow_loc","rt_wrist_loc"};
	float $aXAxisLocSize[] = {3,6,5,4,3,6,5,4};
	string $aYAxisUpCircleJnts[] = {"hip_loc","spine_low_loc","spine_mid_loc","spine_hi_loc","lf_upLeg_loc","lf_knee_loc","lf_ankle_loc","rt_upLeg_loc","rt_knee_loc","rt_ankle_loc","neck_loc","head_a_loc"};
	float $aYAxisLocSize[] = {14,16,17,18,10,7,6,10,7,6,8,12};
	string $aZAxisUpCircleJnts[] = {"lf_ball_loc","rt_ball_loc"};
	float $aZAxisLocSize[] = {4,4};
	int $axisUpIndex;
	float $wireScale, $aRootLocScale[];
	float $locScale = float(abRTGetGlobal("proxyLocScale"));
	
	int $neckCtrlSize = 8;
	int $midSpineCtrlSize = 17;
	
	int $fingerNum, $midSpineJntNum, $neckJntNum;
	int $aDataFingerNum, $aDataMidSpineJntNum, $aDataNeckJntNum;
	
	// following two vars are used with UIParams == true and recalling a proxy with the same number of joints as specified in the UI.  In that case just use the existing structure specified in aData for the spine or neck.
	int $spineAlreadySpecified = false;
	int $neckAlreadySpecified = false;
	
	// get fingerNum, spineNum, and neckNum values from aData
	$fingerNum = 2; // always at least two fingers
	$midSpineJntNum = $neckJntNum = 0;
	
	for ($i=0;$i<size($aData);$i+=4){
		
		if (`match "spine_mid[0-9_]+loc" $aData[$i]` == $aData[$i]){
			$aDataMidSpineJntNum++;
			
			// make sure curves get built
			$aYAxisUpCircleJnts[size($aYAxisUpCircleJnts)] = $aData[$i];
			$aYAxisLocSize[size($aYAxisLocSize)] = $midSpineCtrlSize;
		}
		
		if ($aData[$i] == "lf_thumb_a_loc" || $aData[$i] == "lf_index_a_loc" || $aData[$i] == "lf_middle_a_loc" || $aData[$i] == "lf_ring_a_loc" || $aData[$i] == "lf_pinky_a_loc")
			$aDataFingerNum++;
		
		if (`match "neck[0-9_]+loc" $aData[$i]` == $aData[$i]){
			$aDataNeckJntNum++;
			
			// make sure curves get built
			$aYAxisUpCircleJnts[size($aYAxisUpCircleJnts)] = $aData[$i];
			$aYAxisLocSize[size($aYAxisLocSize)] = $neckCtrlSize;
		}
	}
	// done
	
	
	if (`window -q -exists abRTSklMkrWin`){
		if ($useUIParams){
			
			$fingerNum = (`window -q -exists abRTSklMkrWin` && $useUIParams) ? `intSliderGrp -q -v abRTSklMkrFingerNumIntSldrGrp` : 5;
			
			$midSpineJntNum = 1;
			if (`intSliderGrp -q -ex abRTSklMkrMidSpineNumIntSldrGrp`){
				if (`window -q -exists abRTSklMkrWin` && $useUIParams)
					$midSpineJntNum = (`intSliderGrp -q -v abRTSklMkrMidSpineNumIntSldrGrp`) - 2;
			}
			
			$neckJntNum = 1;
			if (`intSliderGrp -q -ex abRTSklMkrNeckNumIntSldrGrp`){
				if (`window -q -exists abRTSklMkrWin` && $useUIParams)
					$neckJntNum = `intSliderGrp -q -v abRTSklMkrNeckNumIntSldrGrp`;
			}
			
			if ($neckJntNum != $aDataNeckJntNum){
				
				string $aExistingNeckJnts[] = abRTObjExistInProxyDataStr({"neck_loc","neck_1_loc","neck_2_loc","neck_3_loc","neck_4_loc"}, $aData);
				
				if (size($aExistingNeckJnts) > 1){
					
					// multiple neck joints in aData, rename neck_1_loc to neck_loc and delete others
					$aData = abRTRenameProxyLocInDataStr($aExistingNeckJnts[0], "neck_loc", $aData);
					
					for ($i=1;$i<size($aExistingNeckJnts);$i++)
						$aData = abRTRemoveProxyLocFromDataStr($aExistingNeckJnts[$i], $aData);
				}
				
			}else{
				$neckAlreadySpecified = true;
			}
			
			if ($midSpineJntNum != $aDataMidSpineJntNum){
				
				string $aExistingMidSpineJnts[] = abRTObjExistInProxyDataStr({"spine_mid_loc","spine_mid_1_loc","spine_mid_2_loc","spine_mid_3_loc","spine_mid_4_loc","spine_mid_5_loc","spine_mid_6_loc","spine_mid_7_loc","spine_mid_8_loc","spine_mid_9_loc"}, $aData);
				
				if (size($aExistingMidSpineJnts) > 1){
					
					// multiple midSpine joints in aData, rename spine_mid_1_loc to spine_mid_loc and delete others
					$aData = abRTRenameProxyLocInDataStr($aExistingMidSpineJnts[0], "spine_mid_loc", $aData);
					
					for ($i=1;$i<size($aExistingMidSpineJnts);$i++)
						$aData = abRTRemoveProxyLocFromDataStr($aExistingMidSpineJnts[$i], $aData);
				}
				
			}else{
				$spineAlreadySpecified = true;
			}
			
		}else{
			
			$fingerNum = $aDataFingerNum;
			$midSpineJntNum = $aDataMidSpineJntNum;
			$neckJntNum = $aDataNeckJntNum;
			
			// update sliders with current proxy values
			intSliderGrp -e -v $fingerNum abRTSklMkrFingerNumIntSldrGrp;
			
			if (`intSliderGrp -q -ex abRTSklMkrMidSpineNumIntSldrGrp`)
				intSliderGrp -e -v ($midSpineJntNum+2) abRTSklMkrMidSpineNumIntSldrGrp;
			
			if (`intSliderGrp -q -ex abRTSklMkrNeckNumIntSldrGrp`)
				intSliderGrp -e -v $neckJntNum abRTSklMkrNeckNumIntSldrGrp;
			
		}
	}else{
		warning "Unable to continue.  Open the skeletonMaker UI and try again.";
		return "";
	}


	int $delRingCup = false;
	int $delPinkyCup = false;
	string $aFingersToDelete[];
	switch ($fingerNum){
		case 2: $aFingersToDelete = {"middle", "ring", "pinky"}; $delRingCup = $delPinkyCup = true; break;
		case 3: $aFingersToDelete = {"middle", "ring"}; $delRingCup = true; break;
		case 4: $aFingersToDelete = {"ring"}; $delRingCup = true; break;
	}
	
	string $aMidSpineLocs[], $aMidSpineLocNames[], $aExtraDataStr[], $tempLocGrp;
	string $aNeckLocs[], $aNeckLocNames[];
	
	// neck joints
	if ($neckJntNum == 1){
		// nothing
	}else if ($neckJntNum > 1 && !$neckAlreadySpecified){
		
		string $confirm = `confirmDialog -messageAlign center -title "Shameless Shill" -message "The standard version of abAutoRig supports only one neck joint.\n\nUpgrade to Premium to use up to three neck joints." -button "OK"`;
		evalDeferred("undo");
		return "";
	}
	
	// now do spine joints (number of mid joints are variable from 1 to 5)
	if ($midSpineJntNum == 1){
		// nothing
	}else if ($midSpineJntNum > 1 && !$spineAlreadySpecified){
		
		string $confirm = `confirmDialog -messageAlign center -title "Shameless Shill" -message "The standard version of abAutoRig supports only one mid spine joint.\n\nUpgrade to Premium to use up to eight mid spine joints." -button "OK"`;
		evalDeferred("undo");
		return "";
	}
	
	// check first four items in $aData contain info about rootLoc scale (only in saves made with versions 2.1 and up) -- if it does it needs to be removed from $aData
	if (size($aData) > 4){
		if ($aData[1] == "0"){
			
			// yep, this is a post 2.1 save -- get the scale info and remove these first four items from $aData
			$aStr = stringToStringArray($aData[2], "&");
			$aSubStr = stringToStringArray($aStr[5], "|");
			$aRootLocScale = {float($aSubStr[0]), float($aSubStr[1]), float($aSubStr[2])};
			
			// now remove first four items (rootLoc info) from $aData
			clear($aStr);
			for ($i=0;$i<size($aData);$i+=4){
				if ($i > 0){
					$aStr[size($aStr)] = $aData[$i];
					$aStr[size($aStr)] = $aData[$i+1];
					$aStr[size($aStr)] = $aData[$i+2];
					$aStr[size($aStr)] = $aData[$i+3];
				}
			}
			
			$aData = $aStr;
		}
	}
	
	
	for ($i=0;$i<size($aData);$i+=4){
		
		$objName = $aData[$i];
		$parent = $aData[$i+1];
		$locTransStr = $aData[$i+2];
		$frozen = int($aData[$i+3]);
		
		// get baseName
		$aStr = stringToStringArray($objName, "_");
		if (size($aStr) == 3) $baseName = $aStr[1];
		else $baseName = "";
		
		if ($parent == "*") $parent = $rootLoc;
		
		if (!objExists($parent)) continue;
		
		if ($delRingCup && $baseName == "ringCup") continue;
		if ($delPinkyCup && $baseName == "pinkyCup") continue;
		
		if (endsWith($objName, "_grpLoc")){
			
			// need to compare baseName of current obj with items in $aFingersToDelete -- if this finger is in $aFingersToDelete then skip it
			if (size($aFingersToDelete) > 0)
				if (abRTGetPosInStrArray($baseName, $aFingersToDelete) != -1)
				continue;
			
			$loc = abRTMakeWireController("sphere", 1, {}, 1.5*$so);
			$aStr = abRTRename($loc, $objName);
			$loc = $aStr[1];
			
		}else if (abRTGetPosInStrArray($objName, $aYAxisUpCircleJnts) != -1){
			
			$axisUpIndex = abRTGetPosInStrArray($objName, $aYAxisUpCircleJnts);
			$wireScale = $aYAxisLocSize[$axisUpIndex];
			$loc = abRTMakeWireController("circle", 1, {}, $wireScale*$so);
			$aStr = abRTRename($loc, $objName);
			$loc = $aStr[1];
			
		}else if (abRTGetPosInStrArray($objName, $aXAxisUpCircleJnts) != -1){
			
			$axisUpIndex = abRTGetPosInStrArray($objName, $aXAxisUpCircleJnts);
			$wireScale = $aXAxisLocSize[$axisUpIndex];
			$loc = abRTMakeWireController("circle", 0, {}, $wireScale*$so);
			$aStr = abRTRename($loc, $objName);
			$loc = $aStr[1];
			
		}else if (abRTGetPosInStrArray($objName, $aZAxisUpCircleJnts) != -1){
			
			$axisUpIndex = abRTGetPosInStrArray($objName, $aZAxisUpCircleJnts);
			$wireScale = $aZAxisLocSize[$axisUpIndex];
			$loc = abRTMakeWireController("circle", 2, {}, $wireScale*$so);
			$aStr = abRTRename($loc, $objName);
			$loc = $aStr[1];
			
		}else{
			
			$loc = abRTMakeLocator($objName);
			$aStr = `listRelatives -type shape $loc`;
			if (size($aStr) == 1) setAttr ($aStr[0]+".localScale") $locScale $locScale $locScale;
		}
		
		// recall locTransStr
		$aStr = stringToStringArray($locTransStr, "&");
		
		// trans
		$aSubStr = stringToStringArray($aStr[0], "|");
		setAttr ($loc+".t") (float($aSubStr[0])) (float($aSubStr[1])) (float($aSubStr[2]));
		
		// rot
		$aSubStr = stringToStringArray($aStr[1], "|");
		setAttr ($loc+".r") (float($aSubStr[0])) (float($aSubStr[1])) (float($aSubStr[2]));
		
		// scale
		$aSubStr = stringToStringArray($aStr[2], "|");
		setAttr ($loc+".s") (float($aSubStr[0])) (float($aSubStr[1])) (float($aSubStr[2]));
		
		$loc = abRTParent($loc, $parent);
		
		if ($frozen) makeIdentity -apply true -t 1 -r 1 -s 1 $loc;
		
		// save the control attributes values (if any) to restore once the loc structure has been completely recreated
		if (size($aStr) >= 6) $aRestoreAttTable[size($aRestoreAttTable)] = $objName+"&"+$aStr[3]+"&"+$aStr[4]+"&"+$aStr[5];
		
		// color the controls
		$aRel = `listRelatives -type shape $loc`;
		if (size($aRel) == 1){
			if (endsWith($objName, "_grpLoc")) $colorInd = $grpLocColorInd;
			else $colorInd = $locColorInd;
			
			setAttr ($aRel[0]+".overrideEnabled") true;
			setAttr ($aRel[0]+".overrideColor") $colorInd;
		}
	}
	
	// can now restore control attributes values (if any)
	for ($restoreAttData in $aRestoreAttTable){
		$aStr = stringToStringArray($restoreAttData, "&");
		$objName = $aStr[0];
		
		// trans
		$aSubStr = stringToStringArray($aStr[1], "|");
		setAttr ($objName+".t") (float($aSubStr[0])) (float($aSubStr[1])) (float($aSubStr[2]));
		
		// rot
		$aSubStr = stringToStringArray($aStr[2], "|");
		setAttr ($objName+".r") (float($aSubStr[0])) (float($aSubStr[1])) (float($aSubStr[2]));
		
		// scale
		$aSubStr = stringToStringArray($aStr[3], "|");
		setAttr ($objName+".s") (float($aSubStr[0])) (float($aSubStr[1])) (float($aSubStr[2]));
		
	}
	
	if (size($aRootLocScale) > 0) setAttr ($rootLoc+".s") $aRootLocScale[0] $aRootLocScale[1] $aRootLocScale[2];
	
	return $rootLoc;
	
}


global proc string[] abRTGetJointConnectionsArray(int $lfSideOnly){
	// returns array of loc connections (used in connectLocStructures and skeletonizeProxy)
	// if $lfSideOnly == false, returns both connections for lf and rt
	
	string $aSub[], $aLocConnections[], $aStr[];
	int $i;
	
	$aLocConnections = {
		"hip_loc>spine_low_loc>spine_mid_loc>spine_mid_1_loc>spine_mid_2_loc>spine_mid_3_loc>spine_mid_4_loc>spine_mid_5_loc>spine_mid_6_loc>spine_mid_7_loc>spine_mid_8_loc>spine_mid_9_loc>spine_hi_loc>spine_end_loc>neck_loc>neck_1_loc>neck_2_loc>neck_3_loc>neck_4_loc>head_a_loc>head_b_loc",
		"head_a_loc>lf_eye_loc",
		"head_a_loc>jaw_a_loc>jaw_b_loc>jaw_c_loc",
		
		"spine_end_loc>lf_clavicle_loc>lf_upArm_loc>lf_elbow_loc>lf_wrist_loc>lf_hand_loc",
		"lf_hand_loc>lf_thumb_a_loc>lf_thumb_b_loc>lf_thumb_c_loc>lf_thumb_d_loc",
		"lf_hand_loc>lf_index_a_loc>lf_index_b_loc>lf_index_c_loc>lf_index_d_loc",
		"lf_hand_loc>lf_middle_a_loc>lf_middle_b_loc>lf_middle_c_loc>lf_middle_d_loc",
		"lf_hand_loc>lf_ringCup_loc>lf_ring_a_loc>lf_ring_b_loc>lf_ring_c_loc>lf_ring_d_loc",
		"lf_hand_loc>lf_pinkyCup_loc>lf_pinky_a_loc>lf_pinky_b_loc>lf_pinky_c_loc>lf_pinky_d_loc",
		
		"hip_loc>lf_upLeg_loc>lf_knee_loc>lf_ankle_loc>lf_ball_loc>lf_toe_loc"
	};
	
	// update $aLineConnections[0] with existing spine joints
	$aSub = stringToStringArray($aLocConnections[0], ">");
	
	for ($i=0;$i<size($aSub);$i++){
		if (`objExists $aSub[$i]`)
			$aStr[size($aStr)] = $aSub[$i];
	}
	
	$aLocConnections[0] = stringArrayToString($aStr, ">");
	
	// add rt side if required
	if (!$lfSideOnly){
		
		clear($aStr);
		
		for ($i=1;$i<size($aLocConnections);$i++)
			$aStr[size($aStr)] = abRTSubstituteAll("lf_", $aLocConnections[$i], "rt_");
		
		$aLocConnections = stringArrayCatenate($aLocConnections, $aStr);
	}
	
	return $aLocConnections;
}


global proc abRTConnectLocStructure(string $rootLoc){
	// if $rootLoc exists, this proc will make the connections and draw the lines to make it a real true proxy skeleton
	
	if (`objExists $rootLoc`){
		
		string $data, $obj, $aSub[], $startLoc, $endLoc, $aStr[];
		int $i;
		int $lockAxes = int(abRTGetGlobal("lockProxyCtlAxes"));
		
		// draw lines
		string $aLineConnections[] = abRTGetJointConnectionsArray(false);
		
		for ($data in $aLineConnections){
			
			// need to replace "hand_loc" with "wrist_loc" (hand locs haven't been created yet)
			$data = substituteAllString($data, "_hand_loc", "_wrist_loc");
			
			$aSub = stringToStringArray($data, ">");
			for ($i=0;$i<(size($aSub)-1);$i++){
				// connect locs with lines
				
				$startLoc = $aSub[$i];
				$endLoc = $aSub[$i+1];
				if (objExists($startLoc) && objExists($endLoc)) abRTConnectWithLine($startLoc, $endLoc);
			}
		}
		
		string $aMirrorObj[] = {"lf_arm_grpLoc", "lf_hand_grpLoc", "lf_pinkyCup_loc", "lf_ringCup_loc", "lf_pinky_grpLoc", "lf_pinky_d_loc", "lf_pinky_c_loc", "lf_pinky_a_loc", "lf_pinky_b_loc", "lf_ring_grpLoc", "lf_ring_d_loc", "lf_ring_c_loc", "lf_ring_b_loc", "lf_ring_a_loc", "lf_middle_grpLoc", "lf_middle_d_loc", "lf_middle_c_loc", "lf_middle_b_loc", "lf_middle_a_loc", "lf_index_grpLoc", "lf_index_a_loc", "lf_index_b_loc", "lf_index_c_loc", "lf_index_d_loc", "lf_thumb_grpLoc", "lf_thumb_b_loc", "lf_thumb_c_loc", "lf_thumb_d_loc", "lf_thumb_a_loc", "lf_cup_loc", "lf_wrist_loc", "lf_elbow_loc", "lf_upArm_loc", "lf_clavicle_loc", "lf_eye_loc", "lf_leg_grpLoc", "lf_foot_grpLoc", "lf_toe_loc", "lf_ball_loc", "lf_ankle_loc", "lf_knee_loc", "lf_upLeg_loc"};
		
		string $mObj;
		for ($obj in $aMirrorObj){
			$mObj = `substitute "lf_" $obj "rt_"`;
			if (`objExists $mObj`){
				abRTConnectMirrorTrans($obj, $mObj, 0);
				abRTPointConnect($obj, $mObj, 6);
				
				abRTConnectMirrorRot($obj, $mObj, 1);
				abRTConnectMirrorRot($obj, $mObj, 2);
				abRTOrientConnect($obj, $mObj, 1);
				
				if (endsWith($obj, "_grpLoc")){
					// connect grpLoc scale with mirror
					connectAttr ($obj+".s") ($mObj+".s");
				}
			}
		}
		
		string $aOriginObj[] = {"head_grpLoc","head_b_loc","spine_grpLoc","spine_end_grpLoc","head_a_loc","neck_loc","neck_1_loc","neck_2_loc","neck_3_loc","neck_4_loc","hip_loc","spine_low_loc","spine_mid_loc","spine_mid_1_loc","spine_mid_2_loc","spine_mid_3_loc","spine_mid_4_loc","spine_mid_5_loc","spine_mid_6_loc","spine_mid_7_loc","spine_mid_8_loc","spine_mid_9_loc","spine_hi_loc","spine_end_loc","jaw_a_loc","jaw_b_loc","jaw_c_loc"};
		
		for ($obj in $aOriginObj){
			// lock off tx
			if (objExists($obj)) setAttr -lock true ($obj+".tx");
		}
		
		if ($lockAxes){
			string $aLockTX[] = {"lf_foot_grpLoc","lf_index_a_loc","lf_upLeg_loc","lf_knee_loc","lf_ankle_loc","lf_ball_loc","lf_toe_loc"};
			string $aLockTY[] = {"lf_hand_grpLoc","lf_upArm_loc","lf_elbow_loc","lf_wrist_loc"};
			string $aLockTZ[] = {"lf_index_a_loc","lf_index_b_loc","lf_index_c_loc","lf_index_d_loc","lf_index_b_loc","lf_index_c_loc","lf_index_d_loc","lf_middle_a_loc","lf_middle_b_loc","lf_middle_c_loc","lf_middle_d_loc","lf_ring_a_loc","lf_ring_b_loc","lf_ring_c_loc","lf_ring_d_loc","lf_pinky_a_loc","lf_pinky_b_loc","lf_pinky_c_loc","lf_pinky_d_loc"};
			
			for ($obj in $aLockTX) if (objExists($obj)) setAttr -lock true ($obj+".tx");
			for ($obj in $aLockTY) if (objExists($obj)) setAttr -lock true ($obj+".ty");
			for ($obj in $aLockTZ) if (objExists($obj)) setAttr -lock true ($obj+".tz");
			
			string $aLockRX[] = {"spine_grpLoc","lf_arm_grpLoc","spine_end_grpLoc"};
			string $aLockRY[] = {"spine_grpLoc","spine_end_grpLoc","head_grpLoc"};
			string $aLockRZ[] = {"spine_grpLoc","spine_end_grpLoc","head_grpLoc","lf_leg_grpLoc","lf_foot_grpLoc"};
			
			for ($obj in $aLockRX) if (objExists($obj)) setAttr -lock true ($obj+".rx");
			for ($obj in $aLockRY) if (objExists($obj)) setAttr -lock true ($obj+".ry");
			for ($obj in $aLockRZ) if (objExists($obj)) setAttr -lock true ($obj+".rz");
			
		}
	}
}


global proc string[] abRTMakeSpineJntsFromCurve(string $curve, string $aJntNames[], string $grp, int $makeLocsInsteadOfJnts){
	// makes size($aJntNames) joints (or locs if $makeLocsInsteadOfJnts) following $curve and places them in $grp (if it exists)
	// returns new joint paths
	
	int $numJnts = size($aJntNames);
	string $aRet[];
	
	if (size($aJntNames) >= 2){
		
		select -clear;
		
		string $aJnts[], $jnt;
		float $aTrans[], $aParam[];
		
		int $i;
		
		for ($i=0;$i<($numJnts-1);$i++){
			if ($i == 0) $aParam[$i] = 0;
			else $aParam[$i] = float($i)/($numJnts-1);
		}
		
		$aParam[size($aParam)] = 1;
		
		// rebuild curve
		
		string $jntPath;
		for ($i=0;$i<size($aParam);$i++){
			
			$param = $aParam[$i];
			$aTrans = `pointOnCurve -turnOnPercentage true -parameter $param -position $curve`;
			
			if ($makeLocsInsteadOfJnts){
				$jnt = abRTStripRoot(abRTMakeLocator($aJntNames[$i]));
				move -absolute $aTrans[0] $aTrans[1] $aTrans[2] $jnt;
			}else{
				$jnt = `joint -p $aTrans[0] $aTrans[1] $aTrans[2] -n $aJntNames[$i]`;
			}
			
			if (($i == 0 || $makeLocsInsteadOfJnts) && $grp != "" && `objExists $grp`)
				$jnt = abRTParent($jnt, $grp);
			else if (!$makeLocsInsteadOfJnts)
				$jnt = $jntPath+"|"+$jnt;
			
			$aJnts[size($aJnts)] = $jnt;
			$aRet[size($aRet)] = $jnt;
			
			$jntPath = $jnt;
		}
		
		$aRet = $aJnts;
		
	}
	
	return $aRet;
	
}


global proc abRTOrientJoints(string $aJnts[], string $orient, string $sao){
	// orients joints.  $orient is value of joint -orientJoint ("xyz") and $sao is value of joint -sao ("zdown")
	
	string $jnt, $aRel[];
	for ($jnt in $aJnts){
		$aRel = `listRelatives -c -type joint $jnt`;
		if (size($aRel) > 0){
			xform -ro 0 0 0 $jnt;
			joint -e -orientJoint $orient -sao $sao $jnt;
		}
	}
}


global proc abRTSkeletonMaker(){
	// ui to build a skeleton
	
	if (`window -exists abRTSklMkrWin`){
		deleteUI -window abRTSklMkrWin;
	}
	
	window -t "abSkeletonMaker" -w 284 -h 328 -menuBar true -minimizeButton false -maximizeButton false abRTSklMkrWin;
	
	int $lmargin = 3;
	int $rmargin = 3;
	int $cbmargin = 50;
	
	menu -label "Options";
 	menuItem -label "Lock Proxy Control Axes" -checkBox (int(abRTGetGlobal("lockProxyCtlAxes"))) -c ("abRTSetGlobal(\"lockProxyCtlAxes\", (string(`menuItem -q -checkBox abRTSklMkrLckPrxyCtlAxMnIt`)));") abRTSklMkrLckPrxyCtlAxMnIt;
	menuItem -label "Autosave Skeleton on Build" -checkBox (int(abRTGetGlobal("autoSaveSkeleton"))) -c ("abRTSetGlobal(\"autoSaveSkeleton\", (string(`menuItem -q -checkBox abRTSklMkrAutoSaveMnIt`)));") abRTSklMkrAutoSaveMnIt;
	menuItem -label "Mirror Leg Behavior" -checkBox (int(abRTGetGlobal("legMirrorBehavior"))) -c ("abRTSetGlobal(\"legMirrorBehavior\", (string(`menuItem -q -checkBox abRTSklMkrMirLegBehaviorMnIt`)));") abRTSklMkrMirLegBehaviorMnIt;
	
	formLayout -numberOfDivisions 100 abRTSklMkrForm;
	
	string $updateProxyCmd = "string $gStr = \"skeleton_proxy_grpLoc\"; if (objExists($gStr)){int $gInt = `intSliderGrp -q -v abRTSklMkrFingerNumIntSldrGrp`; intSliderGrp -e -v 5 abRTSklMkrFingerNumIntSldrGrp; abRTRecallLocStructureV2(abRTEncodeLocStructure($gStr), true); abRTConnectLocStructure($gStr); intSliderGrp -e -v $gInt abRTSklMkrFingerNumIntSldrGrp;}";
	
	intSliderGrp -label "Finger Num:" -min 2 -max 5 -v 5 -field true -columnWidth3 80 30 100 -adjustableColumn3 3 abRTSklMkrFingerNumIntSldrGrp;
	
	button -l "Make Proxy Skeleton" -h 28 -c "abRTMakeProxySkeleton();" abRTSklMkrPrxyBn;
	separator abRTSklMkrSep1;
	button -l "Save Proxy to Shelf" -c "abRTSaveProxySkeleton();" abRTSklMkrSavePrxyBn;
	separator abRTSklMkrSep2;
	                                                                                                         
	intSliderGrp -label "Spine Joints:" -min 4 -max 18 -v (int(abRTGetGlobal("spineJntNum"))) -cc "abRTSetGlobal(\"spineJntNum\", `intSliderGrp -q -v abRTSklMkrSpineJntsSldrGrp`);" -field true -columnWidth3 80 30 100 -adjustableColumn3 3 abRTSklMkrSpineJntsSldrGrp;
	intSliderGrp -label "UpArm Split:" -min 0 -max 6 -v (int(abRTGetGlobal("upArmSplitNum"))) -cc "abRTSetGlobal(\"upArmSplitNum\", `intSliderGrp -q -v abRTSklMkrUpArmSpltIntSldrGrp`);" -field true -columnWidth3 80 30 100 -adjustableColumn3 3 abRTSklMkrUpArmSpltIntSldrGrp;
	intSliderGrp -label "ForeArm Split:" -min 0 -max 6 -v (int(abRTGetGlobal("foreArmSplitNum"))) -cc "abRTSetGlobal(\"foreArmSplitNum\", `intSliderGrp -q -v abRTSklMkrForeArmSpltIntSldrGrp`);" -field true -columnWidth3 80 30 100 -adjustableColumn3 3 abRTSklMkrForeArmSpltIntSldrGrp;
	intSliderGrp -label "UpLeg Split:" -min 0 -max 6 -v (int(abRTGetGlobal("upLegSplitNum"))) -cc "abRTSetGlobal(\"upLegSplitNum\", `intSliderGrp -q -v abRTSklMkrUpLegSpltIntSldrGrp`);" -field true -columnWidth3 80 30 100 -adjustableColumn3 3 abRTSklMkrUpLegSpltIntSldrGrp;
	intSliderGrp -label "Knee Split:" -min 0 -max 6 -v (int(abRTGetGlobal("lowLegSplitNum"))) -cc "abRTSetGlobal(\"lowLegSplitNum\", `intSliderGrp -q -v abRTSklMkrKneeSpltIntSldrGrp`);" -field true -columnWidth3 80 30 100 -adjustableColumn3 3 abRTSklMkrKneeSpltIntSldrGrp;
	
	checkBox -l "Create Hierarchical Limb Weight Joints" -v (int(abRTGetGlobal("createLimbWtJntsInHierarchy"))) -cc "abRTSetGlobal(\"createLimbWtJntsInHierarchy\", (int(`checkBox -q -v abRTSklMkrHierarchicalWtJntsChkBx`)));" -ann "Enable to create arm and leg joints in a hierarchy (which may have skinning benefits).  Otherwise they will be free floating." abRTSklMkrHierarchicalWtJntsChkBx;
	
	button -l "Build Skeleton" -h 28 -c "abRTSkeletonizeProxy();" abRTSklMkrBldBn;
	
	formLayout -e
	
	-af abRTSklMkrPrxyBn "top" 6
	-af abRTSklMkrPrxyBn "left" $lmargin
	-af abRTSklMkrPrxyBn "right" $rmargin
	
	-ac abRTSklMkrFingerNumIntSldrGrp "top" 5 abRTSklMkrPrxyBn
	-af abRTSklMkrFingerNumIntSldrGrp "left" $lmargin
	-af abRTSklMkrFingerNumIntSldrGrp "right" $rmargin
	
	-ac abRTSklMkrSep1 "top" 4 abRTSklMkrFingerNumIntSldrGrp
	-af abRTSklMkrSep1 "left" $lmargin
	-af abRTSklMkrSep1 "right" $rmargin
	
	-ac abRTSklMkrSavePrxyBn "top" 5 abRTSklMkrSep1
	-af abRTSklMkrSavePrxyBn "left" $lmargin
	-af abRTSklMkrSavePrxyBn "right" $rmargin
	
	-ac abRTSklMkrSep2 "top" 4 abRTSklMkrSavePrxyBn
	-af abRTSklMkrSep2 "left" $lmargin
	-af abRTSklMkrSep2 "right" $rmargin
	
	-ac abRTSklMkrSpineJntsSldrGrp "top" 5 abRTSklMkrSep2
	-af abRTSklMkrSpineJntsSldrGrp "left" $lmargin
	-af abRTSklMkrSpineJntsSldrGrp "right" $rmargin  
	
	-ac abRTSklMkrUpArmSpltIntSldrGrp "top" 5 abRTSklMkrSpineJntsSldrGrp
	-af abRTSklMkrUpArmSpltIntSldrGrp "left" $lmargin
	-af abRTSklMkrUpArmSpltIntSldrGrp "right" $rmargin
	
	-ac abRTSklMkrForeArmSpltIntSldrGrp "top" 5 abRTSklMkrUpArmSpltIntSldrGrp
	-af abRTSklMkrForeArmSpltIntSldrGrp "left" $lmargin
	-af abRTSklMkrForeArmSpltIntSldrGrp "right" $rmargin
	
	-ac abRTSklMkrUpLegSpltIntSldrGrp "top" 5 abRTSklMkrForeArmSpltIntSldrGrp
	-af abRTSklMkrUpLegSpltIntSldrGrp "left" $lmargin
	-af abRTSklMkrUpLegSpltIntSldrGrp "right" $rmargin
	
	-ac abRTSklMkrKneeSpltIntSldrGrp "top" 5 abRTSklMkrUpLegSpltIntSldrGrp
	-af abRTSklMkrKneeSpltIntSldrGrp "left" $lmargin
	-af abRTSklMkrKneeSpltIntSldrGrp "right" $rmargin
	
	-ac abRTSklMkrHierarchicalWtJntsChkBx "top" 5 abRTSklMkrKneeSpltIntSldrGrp
	-af abRTSklMkrHierarchicalWtJntsChkBx "left" ($lmargin+$cbmargin)
	-af abRTSklMkrHierarchicalWtJntsChkBx "right" $rmargin
	
	-ac abRTSklMkrBldBn "top" 16 abRTSklMkrHierarchicalWtJntsChkBx
	-af abRTSklMkrBldBn "left" $lmargin
	-af abRTSklMkrBldBn "right" $rmargin
	
	abRTSklMkrForm;
	
	
	showWindow abRTSklMkrWin;
	
}


global proc abRTMakeProxySkeleton(){
	// makes a proxy skeleton
	
	abRTCheckSoftMod(true);
	
	string $aData[] = {"skeleton_proxy_grpLoc","0","0|0|0&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","hip_loc","*","0|28.78353936|-0.03793848382&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","spine_grpLoc","*","0|31.15716066|-0.04843504669&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_leg_grpLoc","*","3.013497598|27.54369647|-0.07347699371&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_leg_grpLoc","*","-3.013326526|27.54369647|-0.07347699371&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","spine_low_loc","spine_grpLoc","0|31.15716066|-0.04843504669&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","spine_mid_loc","spine_grpLoc","0|35.13522079|-0.295672241&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","spine_hi_loc","spine_grpLoc","0|40.30690808|-0.5424012602&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","spine_end_grpLoc","spine_grpLoc","0|43.19712444|-0.5424012602&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_knee_loc","lf_leg_grpLoc","3.013497598|14.85122758|0.336829834&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_upLeg_loc","lf_leg_grpLoc","3.013497598|27.54369647|-0.07347699371&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_foot_grpLoc","lf_leg_grpLoc","3.013497598|2.032517305|-0.09561233996&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_knee_loc","rt_leg_grpLoc","-3.013326526|14.85122758|0.336829834&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_upLeg_loc","rt_leg_grpLoc","-3.013497598|27.54369647|-0.07347699371&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_foot_grpLoc","rt_leg_grpLoc","-3.013497598|2.032517305|-0.09561233996&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","spine_end_loc","spine_end_grpLoc","0|43.19712444|-0.5424012602&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_arm_grpLoc","spine_end_grpLoc","6.034036297|44.76636291|-0.1956620128&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_clavicle_loc","spine_end_grpLoc","2.576254409|44.09779615|-0.5424012602&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_clavicle_loc","spine_end_grpLoc","-2.576254368|44.09779615|-0.5424012602&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_arm_grpLoc","spine_end_grpLoc","-6.033693755|44.76636291|-0.1956620128&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","neck_loc","spine_end_grpLoc","0|45.81468835|-0.08889763514&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","head_grpLoc","spine_end_grpLoc","0|49.64237862|0.4188537574&0|0|0&1|1|1&0|-0.3068560494|0.1337106106&0|0|0&1|1|1","1","lf_toe_loc","lf_foot_grpLoc","3.013497598|0.3777597796|9.104148301&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_ball_loc","lf_foot_grpLoc","3.013497598|0.4743170541|5.743069406&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_ankle_loc","lf_foot_grpLoc","3.013497598|2.032517305|-0.09561233996&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_ankle_loc","rt_foot_grpLoc","-3.013326526|2.032517305|-0.09561233996&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_ball_loc","rt_foot_grpLoc","-3.013326526|0.4743170541|5.743069406&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_toe_loc","rt_foot_grpLoc","-3.013326526|0.3777597796|9.104148301&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_hand_grpLoc","lf_arm_grpLoc","18.2687344|44.75524492|-0.0747203956&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_elbow_loc","lf_arm_grpLoc","12.64889295|44.75524492|-0.3871783966&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_upArm_loc","lf_arm_grpLoc","6.034036297|44.75524492|-0.1956620128&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_hand_grpLoc","rt_arm_grpLoc","-18.2687344|44.75524492|-0.0747203956&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_elbow_loc","rt_arm_grpLoc","-12.64889295|44.75524492|-0.3871783966&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_upArm_loc","rt_arm_grpLoc","-6.034036297|44.75524492|-0.1956620128&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_eye_loc","head_grpLoc","-1.736123706|51.70815386|3.848839017&0|0|0&1|1|1&0.3362222612|-0.4802132997|-1.09940342&0|0|0&1|1|1","1","lf_eye_loc","head_grpLoc","1.736222268|51.70815386|3.848839017&0|0|0&1|1|1&-0.336222268|-0.4802132997|-1.09940342&0|-0|0&1|1|1","1","head_b_loc","head_grpLoc","0|55.38444037|1.660166238&0|0|0&1|1|1&0|0.3068557973|-0.5485840692&0|-0|0&1|1|1","1","head_a_loc","head_grpLoc","0|49.64237862|0.4188537574&0|0|0&1|1|1&0|0|5.551115123e-017&0|-0|0&1|1|1","1","jaw_a_loc","head_grpLoc","0|0|0&0|0|0&1|1|1&0|50.53556795|0.8609392899&0|-0|0&1|1|1","1","jaw_b_loc","head_grpLoc","0|0|0&0|0|0&1|1|1&0|48.1503377|0.7383101907&0|-0|0&1|1|1","1","jaw_c_loc","head_grpLoc","0|0|0&0|0|0&1|1|1&0|46.75473497|3.702296992&0|-0|0&1|1|1","1","lf_pinky_grpLoc","lf_hand_grpLoc","21.52003688|44.73346199|-1.893816526&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_ring_grpLoc","lf_hand_grpLoc","21.76014178|45.09340754|-0.8076245475&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_middle_grpLoc","lf_hand_grpLoc","21.96855005|45.20015917|0.2817956095&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_index_grpLoc","lf_hand_grpLoc","21.80772721|44.95734133|1.502138942&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_thumb_grpLoc","lf_hand_grpLoc","19.45185783|44.18055371|1.157473975&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_pinkyCup_loc","lf_hand_grpLoc","19.3014657|44.733462|-1.532765356&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_ringCup_loc","lf_hand_grpLoc","19.28052447|44.943256|-0.6885645133&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_wrist_loc","lf_hand_grpLoc","18.2687344|44.75524492|-0.0747203956&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_pinky_grpLoc","rt_hand_grpLoc","-21.51886348|44.73346199|-1.893890243&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_ring_grpLoc","rt_hand_grpLoc","-21.75895369|45.09340754|-0.807699187&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_middle_grpLoc","rt_hand_grpLoc","-21.96735674|45.20015917|0.2817206422&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_index_grpLoc","rt_hand_grpLoc","-21.80653866|44.95734133|1.502064273&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_thumb_grpLoc","rt_hand_grpLoc","-19.45185783|44.18055371|1.157473975&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_pinkyCup_loc","rt_hand_grpLoc","-19.3014657|44.733462|-1.532765356&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_ringCup_loc","rt_hand_grpLoc","-19.28052447|44.943256|-0.6885645133&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_wrist_loc","rt_hand_grpLoc","-18.26775156|44.75524492|-0.07478214142&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_pinky_d_loc","lf_pinky_grpLoc","25.02529979|44.69431483|-1.893816526&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_pinky_c_loc","lf_pinky_grpLoc","23.75070357|44.77365816|-1.893816526&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_pinky_a_loc","lf_pinky_grpLoc","21.52003688|44.73346199|-1.893816526&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_pinky_b_loc","lf_pinky_grpLoc","22.64430958|44.84741279|-1.893816526&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_ring_d_loc","lf_ring_grpLoc","26.29234302|45.01729861|-0.8076245475&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_ring_c_loc","lf_ring_grpLoc","24.86857543|45.0968095|-0.8076245475&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_ring_b_loc","lf_ring_grpLoc","23.27618811|45.1723294|-0.8076245475&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_ring_a_loc","lf_ring_grpLoc","21.76014178|45.09340754|-0.8076245475&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_middle_d_loc","lf_middle_grpLoc","26.63216727|45.11943681|0.2817956095&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_middle_c_loc","lf_middle_grpLoc","25.16365461|45.19873565|0.2817956095&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_middle_b_loc","lf_middle_grpLoc","23.76832148|45.29663976|0.2817956095&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_middle_a_loc","lf_middle_grpLoc","21.96855005|45.20015917|0.2817956095&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_index_a_loc","lf_index_grpLoc","21.80772721|44.95734133|1.502138942&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_index_b_loc","lf_index_grpLoc","23.49126975|45.06165807|1.502138942&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_index_c_loc","lf_index_grpLoc","24.88645214|44.95647455|1.502138942&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_index_d_loc","lf_index_grpLoc","26.14595354|44.87742857|1.502138942&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_thumb_b_loc","lf_thumb_grpLoc","20.28999093|43.60887316|2.621890191&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_thumb_c_loc","lf_thumb_grpLoc","21.53770845|43.17885332|3.373828551&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_thumb_d_loc","lf_thumb_grpLoc","22.99811726|42.54857357|3.761570831&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","lf_thumb_a_loc","lf_thumb_grpLoc","19.45185783|44.18055371|1.157473975&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_pinky_d_loc","rt_pinky_grpLoc","-25.02393697|44.69431483|-1.893890243&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_pinky_c_loc","rt_pinky_grpLoc","-23.74940126|44.77365816|-1.893890243&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_pinky_a_loc","rt_pinky_grpLoc","-21.51886348|44.73346199|-1.893890243&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_pinky_b_loc","rt_pinky_grpLoc","-22.64307236|44.84741279|-1.893890243&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_ring_d_loc","rt_ring_grpLoc","-26.29095591|45.01729861|-0.807699187&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_ring_c_loc","rt_ring_grpLoc","-24.86724902|45.0968095|-0.807699187&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_ring_b_loc","rt_ring_grpLoc","-23.27492696|45.1723294|-0.807699187&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_ring_a_loc","rt_ring_grpLoc","-21.75895369|45.09340754|-0.807699187&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_middle_d_loc","rt_middle_grpLoc","-26.63074355|45.11943681|0.2817206422&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_middle_c_loc","rt_middle_grpLoc","-25.16229159|45.19873565|0.2817206422&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_middle_b_loc","rt_middle_grpLoc","-23.76702376|45.29663976|0.2817206422&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_middle_a_loc","rt_middle_grpLoc","-21.96735674|45.20015917|0.2817206422&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_index_a_loc","rt_index_grpLoc","-21.80653866|44.95734133|1.502064273&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_index_b_loc","rt_index_grpLoc","-23.48998563|45.06165807|1.502064273&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_index_c_loc","rt_index_grpLoc","-24.88510295|44.95647455|1.502064273&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_index_d_loc","rt_index_grpLoc","-26.14454389|44.87742857|1.502064273&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_thumb_a_loc","rt_thumb_grpLoc","-19.45080372|44.18055371|1.157407751&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_thumb_b_loc","rt_thumb_grpLoc","-20.28887489|43.60887316|2.621820078&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_thumb_c_loc","rt_thumb_grpLoc","-21.53652678|43.17885332|3.373754315&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1","rt_thumb_d_loc","rt_thumb_grpLoc","-22.9968509|42.54857357|3.761491275&0|0|0&1|1|1&0|0|0&0|0|0&1|1|1","1"};
	
	string $rootLoc = abRTRecallLocStructureV2($aData, true);
	abRTConnectLocStructure($rootLoc);
	
}


global proc abRTSaveProxySkeleton(){
	// save current proxy skeleton to a shelf button
	
	abRTCheckSoftMod(true);
	
	string $aLoc[] = abRTEncodeLocStructure("skeleton_proxy_grpLoc");
	if (size($aLoc) != 0){
		string $aData = stringArrayToString($aLoc, "\",\"");
		$aData = "{\""+$aData+"\"}";
		
		string $cmd = "if (!`exists abAutoRig`) source abAutoRig.mel;\n";
		$cmd += "abRTInit();\n";
		$cmd += "if (!`window -q -exists abRTSklMkrWin`) abRTSkeletonMaker();\n";
		$cmd += "string $gStr = abRTRecallLocStructureV2(\n"+$aData+"\n, false);\n";
		$cmd += "abRTConnectLocStructure($gStr);\n";
		
		textToShelf("Skel", $cmd);
	}
}


global proc abRTSkeletonizeProxy(){
	// creates a skeleton from a skeleton proxy
	
	abRTCheckSoftMod(true);
	
	if (!(`objExists "skeleton_proxy_grpLoc"`)){
		warning "You need to create a proxy skeleton first.";
		return;
	}
	
	// save the proxy
	if (int(abRTGetGlobal("autoSaveSkeleton")))
		abRTSaveProxySkeleton();
	
	string $aJntConnections[] = abRTGetJointConnectionsArray(true);
	
	string $subStr, $aSub[], $aNames[], $loc, $tGrp, $obj, $aJnts[], $jnt, $aStr[], $rootJnt, $hipJnt, $baseName, $prefix, $aJntsToMirror[], $elbow, $clavicle, $eye, $upArm, $upLeg, $knee, $wrist, $ankle, $ball, $aHeadNeck[], $aFingers[], $aFingerJnts[], $aMidSpineJnts[], $spineHi, $spineEnd;
	string $cJntName, $aJaw[];
	int $i, $k, $end, $nonExistantLoc, $int, $ind;
	
	// throw warning if pv snap att won't work
	string $lfRotInfoStr, $rtRotInfoStr, $tLimbName;
	float $aTrans[], $aTransLast[];
	float $pvCheckTol = .001;
	int $showWarning = false;
	int $saveArmProxyInfo = false;
	int $saveLegProxyInfo = false;
	int $buildInProxyPose = false;
	
	$aFingerJnts = {"lf_index_a_loc","lf_index_b_loc","lf_index_c_loc","lf_index_d_loc","lf_middle_a_loc","lf_middle_b_loc","lf_middle_c_loc","lf_middle_d_loc","lf_ringCup_loc","lf_ring_a_loc","lf_ring_b_loc","lf_ring_c_loc","lf_ring_d_loc","lf_pinkyCup_loc","lf_pinky_a_loc","lf_pinky_b_loc","lf_pinky_c_loc","lf_pinky_d_loc"};
	
	string $aPvLocCheck[] = {"1&arm&lf_upArm_loc&lf_elbow_loc&lf_wrist_loc","0&leg&lf_upLeg_loc&lf_knee_loc&lf_ankle_loc&lf_ball_loc&lf_toe_loc"}; // form of "axisThatItemsMustShare&limbName&item1&item2&item3&etc"
	for ($i=0;$i<size($aPvLocCheck);$i++){
		$aStr = stringToStringArray($aPvLocCheck[$i], "&");
		if (size($aStr) <= 1) continue;
		
		$ind = int($aStr[0]); // index to compare loc translations upon -- 0 = x, 1 = y, 2 = z
		$tLimbName = $aStr[1]; // "leg" or "arm"
		
		for ($k=3;$k<size($aStr);$k++){
			
			$aTrans = `xform -q -ws -rp $aStr[$k]`;
			$aTransLast = `xform -q -ws -rp $aStr[$k-1]`;
			
			if (abs($aTrans[$ind] - $aTransLast[$ind]) > $pvCheckTol){
				
				$showWarning = true;
				
				if ($tLimbName == "arm")
					$saveArmProxyInfo = true;
				else if ($tLimbName == "leg")
					$saveLegProxyInfo = true;
				
				break;
			}
		}
	}
	
	if (!$showWarning){
		
		// check for rotations on hand_grpLoc -- need to showWarning (and save proxy data) if there are any
		$aTrans = `getAttr "lf_hand_grpLoc.r"`;
		
		for ($flt in $aTrans){
			if ($flt != 0){
				$showWarning = true;
				$saveArmProxyInfo = true;
				break;
			}
		}
	}
	
	float $aLfWristTrans[], $aRtWristTrans[], $aLfWristRot[], $aRtWristRot[], $aLfWristPvTrans[], $aRtWristPvTrans[];
	float $aLfAnkleTrans[], $aRtAnkleTrans[], $aLfAnkleRot[], $aRtAnkleRot[], $aLfAnklePvTrans[], $aRtAnklePvTrans[];
	
	if ($showWarning){
		
		string $confirm = `confirmDialog -messageAlign center -title "Confirm" -message "The skeleton must be created in a standard T-Pose for all of the rig features\nto work (including IK/FK matching).  However, once the character has been\nrigged, the proxy pose can be recalled using the \"Reset Character To Proxy\nPose\" item in the \"Tools\" menu.\n\nThis version of the script (abAutoRig Standard) will save the pose data, but\n\"Reset Character To Proxy Pose\" is an abAutoRig Premium-only feature.\n\nWould you prefer to build the skeleton in the T-Pose (highly recommended)\nor in the current proxy pose?" -button "T-Pose" -button "Proxy Pose" -button "Cancel" -defaultButton "T-Pose" -cancelButton "Cancel" -dismissString "Cancel"`;
		
		if ($confirm == "Cancel")
			return;
		else if ($confirm == "Proxy Pose")
			$buildInProxyPose = true;
		
		
		
		// capture info (wrist trans and rot, and potentional pv loc) to write into joints later
		// need to follow angle of the wrist joint which will be slightly different than the wrist loc, depending on where the elbow is.
		
		
		if ($saveArmProxyInfo){
			
			string $tJntGrp = `group -em -w -name "|tempProxyJointChain"`;
			
			// first, get arm pvPositions (while arm is still rotated)
			$aLfWristPvTrans = abRTCalculatePVPosition({"lf_upArm_loc","lf_elbow_loc","lf_wrist_loc"});
			$aRtWristPvTrans = abRTCalculatePVPosition({"rt_upArm_loc","rt_elbow_loc","rt_wrist_loc"});
			
			// now make targetLocs at the current grpLoc wrist position
			string $tLfWristTargetLoc = abRTMakeLocatorV2("lf_TempWristTarget_loc", "lf_hand_grpLoc", "");
			string $tRtWristTargetLoc = abRTMakeLocatorV2("rt_TempWristTarget_loc", "rt_hand_grpLoc", "");
			
			abRTSnapToPosition("lf_hand_grpLoc", $tLfWristTargetLoc);
			abRTSnapToPosition("rt_hand_grpLoc", $tRtWristTargetLoc);
			
			// save uparm rotation and zero out grpLocs z and y rot
			float $lf_tUparmRot[] = `getAttr "lf_arm_grpLoc.r"`;
			float $rt_tUparmRot[] = `getAttr "rt_arm_grpLoc.r"`;
			setAttr "lf_arm_grpLoc.rz" 0;
			setAttr "lf_arm_grpLoc.ry" 0;
			
			// make locs at upArms with frozen rots
			string $tLfWristLoc = abRTMakeLocator("lf_TempWrist_loc");
			string $tRtWristLoc = abRTMakeLocator("rt_TempWrist_loc");
			
			string $lf_tUpArmLoc = abRTMakeLocator("lf_TempUpArm_loc");
			string $rt_tUpArmLoc = abRTMakeLocator("lf_TempUpArm_loc");
			string $lf_tUpArmLocFrzGrp, $rt_tUpArmLocFrzGrp;
			
			abRTSnapToPosition("lf_upArm_loc", $lf_tUpArmLoc);
			abRTSnapToPosition("rt_upArm_loc", $rt_tUpArmLoc);
			
			$lf_tUpArmLoc = abRTGroupFreezeReturnObj($lf_tUpArmLoc, 1);
			$lf_tUpArmLocFrzGrp = firstParentOf($lf_tUpArmLoc);
			
			$rt_tUpArmLoc = abRTGroupFreezeReturnObj($rt_tUpArmLoc, 1);
			$rt_tUpArmLocFrzGrp = firstParentOf($rt_tUpArmLoc);
			
			// take care of wrist offset
			// first, zero out the wrist rot (want to get the offset between the wrist joint and the grpLoc)
			float $lf_tWristRot[] = `getAttr "lf_hand_grpLoc.r"`;
			setAttr "lf_hand_grpLoc.r" 0 0 0;
			
			// and snap wrist locs to zeroed grpLoc
			abRTSnapToPosition("lf_hand_grpLoc", $tLfWristLoc);
			abRTSnapToPosition("rt_hand_grpLoc", $tRtWristLoc);
			
			// ok, now make joints
			$aJnts = abRTDuplicateJointHierarchy({"spine_end_loc","lf_upArm_loc","lf_elbow_loc","lf_wrist_loc"}, {"tSpineEnd_jnt","lf_tUpArm_jnt","lf_tElbow_jnt","lf_tWrist_jnt"}, $tJntGrp);
			$aStr = `duplicate -name "lf_hand_jnt" $aJnts[3]`;
			$aStr[0] = abRTParent($aStr[0], $aJnts[3]);
			$aJnts[size($aJnts)] = $aStr[0];
			
			// orient wrist, then other upArm and elbow (different orientations)
			abRTOrientJoints({$aJnts[3]}, "xyz", "yup");
			abRTOrientJoints({$aJnts[1],$aJnts[2]}, "xyz", "zdown");
			
			// mirror jnts
			mirrorJoint -mirrorBehavior -searchReplace "lf_" "rt_" $aJnts[1];
			string $rt_tUpArm = abRTSubstituteAll("lf_", $aJnts[1], "rt_");
			string $lf_tUpArm, $lf_tWrist, $rt_tWrist;
			
			
			// parent upArm_jnts under respective locs
			$lf_tUpArm = abRTParent($aJnts[1], $lf_tUpArmLoc);
			$rt_tUpArm = abRTParent($rt_tUpArm, $rt_tUpArmLoc);
			
			// get new wrists
			$aStr = `listRelatives -c -type joint $lf_tUpArm`;
			$aStr = `listRelatives -c -type joint $aStr[0]`;
			$lf_tWrist = $aStr[0];
			
			$aStr = `listRelatives -c -type joint $rt_tUpArm`;
			$aStr = `listRelatives -c -type joint $aStr[0]`;
			$rt_tWrist = $aStr[0];
			
			// parent new locs to wrist locs and snap to wrist rotation, so we now have the offset of the wrist rotation
			string $tLfWristOffsetLoc = abRTMakeLocatorV2("lf_TempWristOffset_loc", $lf_tWrist, $tLfWristLoc);
			string $tRtWristOffsetLoc = abRTMakeLocatorV2("rt_TempWristOffset_loc", $rt_tWrist, $tRtWristLoc);
			
			// snap back to orig wrist grpLoc position
			abRTSnapToPosition($tLfWristTargetLoc, $tLfWristLoc);
			abRTSnapToPosition($tRtWristTargetLoc, $tRtWristLoc);
			
			// rotate locs back
			setAttr ($lf_tUpArmLoc+".r") $lf_tUparmRot[0] $lf_tUparmRot[1] $lf_tUparmRot[2];
			setAttr ($rt_tUpArmLoc+".r") $rt_tUparmRot[0] $rt_tUparmRot[1] $rt_tUparmRot[2];
			
			// get left data
			$aLfWristTrans = `xform -q -ws -rp $tLfWristLoc`;
			$aLfWristRot = `xform -q -ws -ro $tLfWristOffsetLoc`;
			
			// get right data
			$aRtWristTrans = `xform -q -ws -rp $tRtWristLoc`;
			$aRtWristRot = `xform -q -ws -ro $tRtWristOffsetLoc`;
			
			
			delete $tLfWristTargetLoc;
			delete $tRtWristTargetLoc;
			delete $tLfWristLoc;
			delete $tRtWristLoc;
			delete $tJntGrp;
			delete $rt_tUpArmLocFrzGrp;
			delete $lf_tUpArmLocFrzGrp;
			clear $aJnts;
			
			
			if ($buildInProxyPose){
				
				setAttr "lf_arm_grpLoc.ry" $lf_tUparmRot[1];
				setAttr "lf_arm_grpLoc.rz" $lf_tUparmRot[2];
				setAttr "lf_hand_grpLoc.r" $lf_tWristRot[0] $lf_tWristRot[1] $lf_tWristRot[2];
			}
		}
		
		
		if ($saveLegProxyInfo){
			
			string $tJntGrp = `group -em -w -name "|tempProxyJointChain"`;
			
			// do the same for the legs
			// first, get arm pvPositions (while leg is still rotated)
			$aLfAnklePvTrans = abRTCalculatePVPosition({"lf_upLeg_loc","lf_knee_loc","lf_ankle_loc"});
			$aRtAnklePvTrans = abRTCalculatePVPosition({"rt_upLeg_loc","rt_knee_loc","rt_ankle_loc"});
			
			// save uparm rotation and zero out grpLocs z and y rot
			float $lf_tUplegRot[] = `getAttr "lf_leg_grpLoc.r"`;
			float $rt_tUplegRot[] = `getAttr "rt_leg_grpLoc.r"`;
			setAttr "lf_leg_grpLoc.ry" 0;
			setAttr "lf_leg_grpLoc.rx" 0;
			float $lf_tAnkleRot[] = `getAttr "lf_foot_grpLoc.r"`;
			float $rt_tAnkleRot[] = `getAttr "rt_foot_grpLoc.r"`;
			setAttr "lf_foot_grpLoc.ry" 0; 	
			setAttr "lf_foot_grpLoc.rx" 0;
			
			// make locs at upLegs with frozen rots
			string $tLfAnkleLoc = abRTMakeLocator("lf_TempAnkleReader_loc");
			string $tRtAnkleLoc = abRTMakeLocator("rt_TempAnkleReader_loc");
			
			string $lf_tUpLegLoc = abRTMakeLocator("lf_TempUpLeg_loc");
			string $rt_tUpLegLoc = abRTMakeLocator("rt_TempUpLeg_loc");
			string $lf_tAnkleLoc = abRTMakeLocator("lf_TempAnkle_loc");
			string $rt_tAnkleLoc = abRTMakeLocator("rt_TempAnkle_loc");
			string $lf_tUpLegLocFrzGrp, $rt_tUpLegLocFrzGrp, $lf_tAnkleLocFrzGrp, $rt_tAnkleLocFrzGrp;
			
			abRTSnapToPosition("lf_upLeg_loc", $lf_tUpLegLoc);
			abRTSnapToPosition("rt_upLeg_loc", $rt_tUpLegLoc);
			abRTSnapToPosition("lf_ankle_loc", $lf_tAnkleLoc);
			abRTSnapToPosition("rt_ankle_loc", $rt_tAnkleLoc);
			
			
			$lf_tUpLegLoc = abRTGroupFreezeReturnObj($lf_tUpLegLoc, 1);
			$lf_tUpLegLocFrzGrp = firstParentOf($lf_tUpLegLoc);
			
			$rt_tUpLegLoc = abRTGroupFreezeReturnObj($rt_tUpLegLoc, 1);
			$rt_tUpLegLocFrzGrp = firstParentOf($rt_tUpLegLoc);
			
			// parent ankle locs to upLegLocs
			$lf_tAnkleLoc = abRTParent($lf_tAnkleLoc, $lf_tUpLegLoc);
			$rt_tAnkleLoc = abRTParent($rt_tAnkleLoc, $rt_tUpLegLoc);
			
			// grpFrz ankle locs
			$lf_tAnkleLoc = abRTGroupFreezeReturnObj($lf_tAnkleLoc, 1);
			$lf_tAnkleLocFrzGrp = firstParentOf($lf_tAnkleLoc);
			
			$rt_tAnkleLoc = abRTGroupFreezeReturnObj($rt_tAnkleLoc, 1);
			$rt_tAnkleLocFrzGrp = firstParentOf($rt_tAnkleLoc);
			
			
			// ok, now make joints
			$aJnts = abRTDuplicateJointHierarchy({"hip_loc","lf_upLeg_loc","lf_knee_loc","lf_ankle_loc","lf_ball_loc","lf_toe_loc"}, {"tHip_loc","lf_tUpLeg_jnt","lf_tKnee_jnt","lf_tAnkle_jnt","lf_tBall_loc","lf_tToe_loc"}, $tJntGrp);
			
			// orient ankle, then other upLeg and knee (different orientations)
			abRTOrientJoints({$aJnts[3], $aJnts[4]}, "xyz", "ydown");
			abRTOrientJointBasedOnChildJntPos($aJnts[1], $aJnts[2], {0,0,-1}, "xyz", "ydown", "yup");
			abRTOrientJointBasedOnChildJntPos($aJnts[2], $aJnts[3], {0,0,1}, "xyz", "yup", "ydown");
			
			// mirror jnts
			mirrorJoint -mirrorBehavior -searchReplace "lf_" "rt_" $aJnts[1];
			string $rt_tUpLeg = abRTSubstituteAll("lf_", $aJnts[1], "rt_");
			string $lf_tUpLeg, $lf_tAnkle, $rt_tAnkle, $lf_tKnee, $rt_tKnee;
			
			// parent upLeg_jnts under respective locs
			$lf_tUpLeg = abRTParent($aJnts[1], $lf_tUpLegLoc);
			$rt_tUpLeg = abRTParent($rt_tUpLeg, $rt_tUpLegLoc);
			
			// get new ankles
			$aStr = `listRelatives -c -type joint $lf_tUpLeg`;
			$lf_tKnee = $aStr[0];
			$aStr = `listRelatives -c -type joint $lf_tKnee`;
			$lf_tAnkle = $aStr[0];
			
			$aStr = `listRelatives -c -type joint $rt_tUpLeg`;
			$rt_tKnee = $aStr[0];
			$aStr = `listRelatives -c -type joint $rt_tKnee`;
			$rt_tAnkle = $aStr[0];
			
			// temporarily parent ankles to ankle_loc
			$lf_tAnkle = abRTParent($lf_tAnkle, $lf_tAnkleLoc);
			$rt_tAnkle = abRTParent($rt_tAnkle, $rt_tAnkleLoc);
			
			// rotate locs back
			setAttr ($lf_tUpLegLoc+".r") $lf_tUplegRot[0] $lf_tUplegRot[1] $lf_tUplegRot[2];
			setAttr ($rt_tUpLegLoc+".r") $rt_tUplegRot[0] $rt_tUplegRot[1] $rt_tUplegRot[2];
			setAttr ($lf_tAnkleLoc+".r") $lf_tAnkleRot[0] $lf_tAnkleRot[1] $lf_tAnkleRot[2];
			setAttr ($rt_tAnkleLoc+".r") $rt_tAnkleRot[0] $rt_tAnkleRot[1] $rt_tAnkleRot[2];
			
			// parent ankles back to knees
			$lf_tAnkle = abRTParent($lf_tAnkle, $lf_tKnee);
			$rt_tAnkle = abRTParent($rt_tAnkle, $rt_tKnee);
			
			// snap locs
			abRTSnapToPosition($lf_tAnkle, $tLfAnkleLoc);
			abRTSnapToPosition($rt_tAnkle, $tRtAnkleLoc);
			
			// get left data
			$aLfAnkleTrans = `xform -q -ws -rp $tLfAnkleLoc`;
			$aLfAnkleRot = `xform -q -ws -ro $tLfAnkleLoc`;
			
			// get right data
			$aRtAnkleTrans = `xform -q -ws -rp $tRtAnkleLoc`;
			$aRtAnkleRot = `xform -q -ws -ro $tRtAnkleLoc`;
			
			delete $tLfAnkleLoc;
			delete $tRtAnkleLoc;
			delete $tJntGrp;
			delete $rt_tUpLegLocFrzGrp;
			delete $lf_tUpLegLocFrzGrp;
			clear $aJnts;
			
			
			if ($buildInProxyPose){
				
				setAttr "lf_leg_grpLoc.ry" $lf_tUplegRot[1];
				setAttr "lf_leg_grpLoc.rx" $lf_tUplegRot[0];
				setAttr "lf_foot_grpLoc.ry" $lf_tAnkleRot[1];	
				setAttr "lf_foot_grpLoc.rx" $lf_tAnkleRot[0];
			}
		}
	}
	// done with warning
	
	
	string $name = abRTGetGlobal("name");
	if ($name == "") $name = "abSkel";
	
	string $skelGrpName = $name+"_Skeleton_grp";
	
	if (objExists($skelGrpName)){
		warning ("A skeleton with the base name \""+$name+"\" already exists in this scene.  Try another name.");
		return;
	}
	
	string $skelGrp = `group -em -w -name $skelGrpName`;
	
	// first need to create handLoc at wrist loc position
	$aStr = `duplicate -name "lf_hand_loc" "lf_wrist_loc"`;
	$aStr = `listRelatives -c -fullPath $aStr[0]`;
	if (size($aStr) > 0) delete $aStr;
	
	for ($i=0;$i<size($aJntConnections);$i++){
		
		$subStr = $aJntConnections[$i];
		$aSub = stringToStringArray($subStr, ">");
		clear($aNames);
		$nonExistantLoc = false;
		
		if ($i == 0){
			$tGrp = $skelGrp;
		}else{
			
			// remove the first item from all but the first subArray because it already exists, and we want to parent the rest of the joints in $aSub under it.
			$baseName = $aSub[0];
			if (startsWith($aSub[0], "lf")){
				$prefix = "l";
				$baseName = `substring $baseName 4 (size($baseName))`;
			}else{
				$prefix = "";
			}
			
			$baseName = `substring $baseName 1 (size($baseName) - 4)`;
			$tGrp = abRTRigNamer($baseName, $prefix, "jnt");
			$aSub = stringArrayRemoveExact({$aSub[0]}, $aSub);
			
		}
		
		for ($loc in $aSub){
			
			if (!`objExists $loc`) $nonExistantLoc = true;
			
			$baseName = $loc;
			if (startsWith($loc, "lf")){
				$prefix = "l";
				$baseName = `substring $baseName 4 (size($baseName))`;
			}else{
				$prefix = "";
			}
			
			// remove "loc" from end of name
			$baseName = `substring $baseName 1 (size($baseName) - 4)`;
			$aNames[size($aNames)] = abRTRigNamer($baseName, $prefix, "jnt");
			$cJntName = $aNames[size($aNames)-1];
			
			// keep upJoints for potential split joints and other reasons
			if ($baseName == "upLeg"){
				$upLeg = $cJntName;
			}else if ($baseName == "clavicle"){
				$clavicle = $cJntName;
			}else if ($baseName == "knee"){
				$knee = $cJntName;
			}else if ($baseName == "eye"){
				$eye = $cJntName;
			}else if ($baseName == "upArm"){
				$upArm = $cJntName;
			}else if ($baseName == "elbow"){
				$elbow = $cJntName;
			}else if ($baseName == "wrist"){
				// keep wrist to duplicate and make hand jnt
				$wrist = $cJntName;
			}else if ($baseName == "neck" || $baseName == "neck_1" || $baseName == "neck_2" || $baseName == "neck_3" || $baseName == "neck_4" || $baseName == "head_a"){
				// keep head and neck to change orientation for controls
				$aHeadNeck[size($aHeadNeck)] = $cJntName;
			}else if ($baseName == "ankle"){
				$ankle = $cJntName;
			}else if ($baseName == "ball"){
				$ball = $cJntName;
			}else if (abRTGetPosInStrArray($baseName, $aFingerJnts) > 0){
				$aFingers[size($aFingers)] = $cJntName;
			}else if ($baseName == "spine_mid" || $baseName == "spine_mid_1" || $baseName == "spine_mid_2" || $baseName == "spine_mid_3" || $baseName == "spine_mid_4" || $baseName == "spine_mid_5" || $baseName == "spine_mid_6" || $baseName == "spine_mid_7" || $baseName == "spine_mid_8" || $baseName == "spine_mid_9"){
				$aMidSpineJnts[size($aMidSpineJnts)] = $cJntName;
			}else if ($baseName == "spine_hi"){
				$spineHi = $cJntName;
			}else if ($baseName == "spine_end"){
				$spineEnd = $cJntName;
			}else if ($baseName == "jaw_a" || $baseName == "jaw_b" || $baseName == "jaw_c"){
				$aJaw[size($aJaw)] = $cJntName;
			}
		}
		
		if ($nonExistantLoc) continue;
		$aStr = abRTDuplicateJointHierarchy($aSub, $aNames, $tGrp);
		
		// save root joint path
		if ($i == 0){
			$hipJnt = $aStr[0];
			$rootJnt = $aStr[1];
		}
	}
	
	// parent hip jnt under spine jnt
	$rootJnt = abRTParent($rootJnt, $skelGrp);
	$hipJnt = abRTParent($hipJnt, $rootJnt);
	$aJnts = `listRelatives -ad -fullPath -type joint $rootJnt`;
	
	// do radius
	float $float, $length;
	float $maxTx = 0;
	for ($jnt in $aJnts){
		$float = `getAttr ($jnt+".tx")`;
		$maxTx = max($maxTx, $float);
	}
	
	string $aRel[];
	float $minRad = .5;
	for ($jnt in $aJnts){
		if ($jnt == $hipJnt){
			setAttr ($jnt+".radius") 1;
		}else{
			$aRel = `listRelatives -c -type joint $jnt`;
			if (size($aRel) > 0){
				$length = `getAttr ($aRel[0]+".tx")`;
				$float = ($length/$maxTx)*(1-$minRad) + $minRad;
				setAttr ($jnt+".radius") $float;
			}else{
				setAttr ($jnt+".radius") $minRad;
			}
		}
	}
	// done with radius
	
	
	// orient joints
	$aJnts = `listRelatives -ad -fullPath -type joint $rootJnt`;
	$aJnts = stringArrayRemove({$hipJnt}, $aJnts);
	abRTOrientJoints($aJnts, "xyz", "zdown");
	
	// orient special case joints differently
	abRTOrientJoints($aHeadNeck, "yzx", "zup");
	abRTOrientJoints({$ankle, $ball}, "xyz", "ydown");
	abRTOrientJointBasedOnChildJntPos($upLeg, $knee, {0,0,-1}, "xyz", "ydown", "yup");
	abRTOrientJointBasedOnChildJntPos($knee, $ankle, {0,0,1}, "xyz", "yup", "ydown");
	
	// orient jaw joints
	abRTOrientJoints($aJaw, "yzx", "zdown");
	
	// orient finger joints
	abRTOrientJoints($aFingers, "xzy", "yup");
	
	// done orienting
	
	// replace hand joints with duplicate of wrist to preserve alignment and reparent children
	string $hand, $newWrist;
	
	if (`objExists $wrist`){
		
		// realign arm joints
		string $aArmJnts[] = abRTGetHierarchy($clavicle, $wrist, true);
		abRTOrientJoints($aArmJnts, "xyz", "yup");
		
		$aRel = `listRelatives -c -fullPath $wrist`;
		$hand = $aRel[0];
		
		$aStr = `duplicate $wrist`;
		$newWrist = $aStr[0];
		$newWrist = abRTParent($newWrist, $wrist);
		$aRel = `listRelatives -c -fullPath $newWrist`;
		if (size($aRel) > 0) delete $aRel;
		
		$aRel = `listRelatives -c -fullPath $hand`;
		for ($i=0;$i<size($aRel);$i++){
			abRTParent($aRel[$i], $newWrist);
		}
		
		delete $hand;
		abRTRename($newWrist, abRTStripPath($hand));
		
	}
	
	// reorient the ankle and ball joints if there's y rotation on the footGrploc (ankle group loc)
	// if ($aLAnkleRot[1] > .001) abRTOrientJoints({$ankle, $ball}, "xyz", "ydown");
	
	// mirror the skeleton.  Mirror behavior on clavicle and upleg and plane on eye
	mirrorJoint -mirrorBehavior -searchReplace "lf_" "rt_" $clavicle;
	mirrorJoint -mirrorYZ -searchReplace "lf_" "rt_" $eye;
	if ((int(abRTGetGlobal("legMirrorBehavior")))){
		mirrorJoint -mirrorBehavior -searchReplace "lf_" "rt_" $upLeg;
	}else{
		mirrorJoint -mirrorYZ -searchReplace "lf_" "rt_" $upLeg;
	}
	
	// add creation rotation data to upArm and upLeg joints
	string $mUpArm = abRTSubstituteAll("lf_", $upArm, "rt_");
	string $mElbow = abRTSubstituteAll("lf_", $elbow, "rt_");
	string $mWrist = abRTSubstituteAll("lf_", $wrist, "rt_");
	string $mUpLeg = abRTSubstituteAll("lf_", $upLeg, "rt_");
	string $mKnee = abRTSubstituteAll("lf_", $knee, "rt_");
	string $mAnkle = abRTSubstituteAll("lf_", $ankle, "rt_");
	
	// insert weight split jnts
	int $spineWtJntNum = int(abRTGetGlobal("spineJntNum"));
	int $upArmSplitNum = int(abRTGetGlobal("upArmSplitNum"));
	int $foreArmSplitNum = int(abRTGetGlobal("foreArmSplitNum"));
	int $upLegSplitNum = int(abRTGetGlobal("upLegSplitNum"));
	int $kneeSplitNum = int(abRTGetGlobal("lowLegSplitNum"));
	
	
	if ($spineWtJntNum > 0){
		
		// need to get spine jnts -- {$hipJnt, $rootJnt, $midJnt1, [$midJnt2, $midJnt3, ...], $hiJnt, $endJnt}
		string $aSpineRigCtrlJnts[] = {$hipJnt, $rootJnt};
		$aSpineRigCtrlJnts = stringArrayCatenate($aSpineRigCtrlJnts, $aMidSpineJnts);
		$aSpineRigCtrlJnts[size($aSpineRigCtrlJnts)] = $spineHi;
		$aSpineRigCtrlJnts[size($aSpineRigCtrlJnts)] = $spineEnd;
		
		int $addSpineShaper = int(abRTGetGlobal("addSpineShaper"));
		int $makeSpineShaper = (size($aMidSpineJnts) == 1 || $addSpineShaper); // make a spine shaper if there's only one spine joint or $addSpineShaper is true
		
		abRTMakeSpine($aSpineRigCtrlJnts, $spineWtJntNum, $makeSpineShaper, "", "", false);
	}
	
	abRTSetRootJntAtt("createLimbWtJntsInHierarchy", abRTGetGlobal("createLimbWtJntsInHierarchy"), $name);
	
	if ($upArmSplitNum > 0 || $foreArmSplitNum > 0){
		abRTMakeLimbWeightAndCtrlJnts({$upArm, $elbow, $wrist}, {"upArm", "elbow", "wrist"}, $upArmSplitNum, $foreArmSplitNum, "l", $rootJnt, "arm", "", false);
		abRTMakeLimbWeightAndCtrlJnts({$mUpArm, $mElbow, $mWrist}, {"upArm", "elbow", "wrist"}, $upArmSplitNum, $foreArmSplitNum, "r", $rootJnt, "arm", "", false);
	}else{
		abRTSetRootJntAtt("upArmSplitNum", "0", $name);
		abRTSetRootJntAtt("foreArmSplitNum", "0", $name);
	}
	
	if ($upLegSplitNum > 0 || $kneeSplitNum > 0){
		abRTMakeLimbWeightAndCtrlJnts({$upLeg, $knee, $ankle}, {"upLeg", "knee", "ankle"}, $upLegSplitNum, $kneeSplitNum, "l", $rootJnt, "leg", "", false);
		abRTMakeLimbWeightAndCtrlJnts({$mUpLeg, $mKnee, $mAnkle}, {"upLeg", "knee", "ankle"}, $upLegSplitNum, $kneeSplitNum, "r", $rootJnt, "leg", "", false);
	}else{
		abRTSetRootJntAtt("upLegSplitNum", "0", $name);
		abRTSetRootJntAtt("lowLegSplitNum", "0", $name);
	}
	
	
	// add creation rotation data to upArm and upLeg joints
	// add wrist and pv info if arms were rotated out of XZ plane
	if ($showWarning){
		
		if ($saveArmProxyInfo){
			
			addAttr -dt float3 -hidden true -keyable false -longName "wristTrans" $upArm;
			setAttr -type float3 ($upArm+".wristTrans") $aLfWristTrans[0] $aLfWristTrans[1] $aLfWristTrans[2];
			
			addAttr -dt float3 -hidden true -keyable false -longName "wristTrans" $mUpArm;
			setAttr -type float3 ($mUpArm+".wristTrans") $aRtWristTrans[0] $aRtWristTrans[1] $aRtWristTrans[2];
			
			addAttr -dt float3 -hidden true -keyable false -longName "wristRot" $upArm;
			setAttr -type float3 ($upArm+".wristRot") $aLfWristRot[0] $aLfWristRot[1] $aLfWristRot[2];
			
			addAttr -dt float3 -hidden true -keyable false -longName "wristRot" $mUpArm;
			setAttr -type float3 ($mUpArm+".wristRot") $aRtWristRot[0] $aRtWristRot[1] $aRtWristRot[2];
			
			addAttr -dt float3 -hidden true -keyable false -longName "wristPvTrans" $upArm;
			setAttr -type float3 ($upArm+".wristPvTrans") $aLfWristPvTrans[0] $aLfWristPvTrans[1] $aLfWristPvTrans[2];
			
			addAttr -dt float3 -hidden true -keyable false -longName "wristPvTrans" $mUpArm;
			setAttr -type float3 ($mUpArm+".wristPvTrans") $aRtWristPvTrans[0] $aRtWristPvTrans[1] $aRtWristPvTrans[2];
			
		}
		
		if ($saveLegProxyInfo){
			
			addAttr -dt float3 -hidden true -keyable false -longName "ankleTrans" $upLeg;
			setAttr -type float3 ($upLeg+".ankleTrans") $aLfAnkleTrans[0] $aLfAnkleTrans[1] $aLfAnkleTrans[2];
			
			addAttr -dt float3 -hidden true -keyable false -longName "ankleTrans" $mUpLeg;
			setAttr -type float3 ($mUpLeg+".ankleTrans") $aRtAnkleTrans[0] $aRtAnkleTrans[1] $aRtAnkleTrans[2];
			
			addAttr -dt float3 -hidden true -keyable false -longName "ankleRot" $upLeg;
			setAttr -type float3 ($upLeg+".ankleRot") $aLfAnkleRot[0] $aLfAnkleRot[1] $aLfAnkleRot[2];
			
			addAttr -dt float3 -hidden true -keyable false -longName "ankleRot" $mUpLeg;
			setAttr -type float3 ($mUpLeg+".ankleRot") $aRtAnkleRot[0] $aRtAnkleRot[1] $aRtAnkleRot[2];
			
			addAttr -dt float3 -hidden true -keyable false -longName "anklePvTrans" $upLeg;
			setAttr -type float3 ($upLeg+".anklePvTrans") $aLfAnklePvTrans[0] $aLfAnklePvTrans[1] $aLfAnklePvTrans[2];
			
			addAttr -dt float3 -hidden true -keyable false -longName "anklePvTrans" $mUpLeg;
			setAttr -type float3 ($mUpLeg+".anklePvTrans") $aRtAnklePvTrans[0] $aRtAnklePvTrans[1] $aRtAnklePvTrans[2];
			
		}
		
	}
	
	
	// delete the proxy
	if (`objExists skeleton_proxy_grpLoc`) delete skeleton_proxy_grpLoc;
	
	// update UI items
	if (`window -q -ex abRTWin`) abRTClearUIItems();
	
	select -clear;
}


global proc abRTInsertJoints(string $upJnt, string $aNames[], int $inline){
	// inserts size($aNames) joints named $aNames (respectively) below $upJnt (which can only have one child)
	// if $inline is true each split is parented to upJnt or the split before it and the previous child of upJnt becomes the child of the last inserted joint
	// otherwise each split will be inserted as a child of upJnt
	
	string $aRel[] = `listRelatives -c -fullPath -type joint $upJnt`;
	
	if (size($aRel) == 1){
		
		int $numJnts = size($aNames);
		string $dnJnt = $aRel[0];
		float $length = `getAttr ($dnJnt+".tx")`;
		
		// get radius
		float $upRadius = `getAttr ($upJnt+".radius")`;
		float $dnRadius = `getAttr ($dnJnt+".radius")`;
		float $radiusScalar = ($dnRadius-$upRadius)*(1.0/float($numJnts+1));
		
		// get split dist
		float $splitDist = $length/float($numJnts+1);
		
		int $i;
		string $aStr[], $splitJnt, $aSplitJnts[], $parentJnt, $childJnt; 
		for ($i=0;$i<$numJnts;$i++){
			
			$aStr = `duplicate $upJnt`;
			$splitJnt = $aStr[0];
			
			$aRel = `listRelatives -c -fullPath $splitJnt`;
			if (size($aRel) > 0) delete $aRel;
			$splitJnt = abRTParent($splitJnt, $upJnt);
			
			setAttr ($splitJnt+".tx") ($splitDist*(float($i+1)));
			setAttr ($splitJnt+".radius") ($upRadius+$radiusScalar*(float($i+1)));
			
			$aStr = abRTRename($splitJnt, $aNames[$i]);
			$splitJnt = $aStr[1];
			
			$aSplitJnts[size($aSplitJnts)] = $splitJnt;
		}
		
		if ($inline){
			// parent the second split joint to the first, etc, and dnJnt to the last split
			for ($i=0;$i<size($aSplitJnts);$i++){
				
				if ($i == 0){
					$parentJnt = $upJnt;
					$childJnt = $aSplitJnts[$i];
				}else{
					$parentJnt = $splitJnt;
					$childJnt = $aSplitJnts[$i];	
				}
				
				$splitJnt = abRTParent($childJnt, $parentJnt);
				
				if ($i == (size($aSplitJnts)-1)) abRTParent($dnJnt, $splitJnt);
				
			}
		}
	}
}


global proc abRTOrientJointBasedOnChildJntPos(string $jnt, string $childJnt, int $aXyzCond[], string $orient, string $trueSecOrient, string $falseSecOrient){
	// orients $jnt based on child ($childJnt) worldspace position
	// $aXyzCond is x, y, and z values (must have 3 values) of -1, 0, or 1.  If value is:
	// 0 -- ignored
	// 1 -- value of parent ($jnt) must be greater than that of the child ($childJnt) for successOrient to be applied
	// -1 -- value of parent ($jnt) must be less that the child ($childJnt) for successOrient to be applied
	// $orient is primary orient of joint ("xyz", etc)
	// $trueSecOrient and $falseSecOrient are both values taken by joint -sao flag ("yup", "xdown", etc)
	
	int $i, $condVal;
	float $aJntTrans[], $aChildTrans[];
	string $sao;
	
	$condVal = true;
	
	// return if $aXyzCond is not the right length or has no comparison values
	if (size($aXyzCond) < 3)
		return;
	
	if ($aXyzCond[0] == 0 && $aXyzCond[1] == 0 && $aXyzCond[2] == 0)
		return;
	
	$aJntTrans = `joint -q -a -position $jnt`;
	$aChildTrans = `joint -q -a -position $childJnt`;
	
	for ($i=0;$i<3;$i++){
		
		if ($aXyzCond[$i] == 1){
			
			// try and prove it wrong
			if ($aJntTrans[$i] < $aChildTrans[$i]){
				$condVal = false;
				break;
			}
			
		}else if ($aXyzCond[$i] == -1){
			
			// try and prove it wrong
			if ($aJntTrans[$i] > $aChildTrans[$i]){
				$condVal = false;
				break;
			}
		}
	}
	
	$sao = ($condVal) ? $trueSecOrient : $falseSecOrient;
	
	joint -e -orientJoint $orient -sao $sao $jnt;
	
}


global proc abRTSpaceSwitchWindow(){
	// creates window for space switch tool
	
	global string $aAbRTSpaceSwitchData[];
	
	if (`window -exists abRTSSWin`) deleteUI -window abRTSSWin;
	
	window -t "abSpaceSwitchMatcher" -w 125 -h 59 -menuBar false -minimizeButton false -maximizeButton false abRTSSWin;
		
	formLayout -numberOfDivisions 100 abRTSSForm;
	
	button -label "Copy Position" -h 25 -command "abRTSpaceSwitchCopyPaste(0);" abRTSSCopyBn;
	button -label "Paste Position" -h 25 -en (size($aAbRTSpaceSwitchData) > 0) -command "abRTSpaceSwitchCopyPaste(1);" abRTSSPasteBn;
	
	int $lmargin = 2;
	int $rmargin = 2;
	
	formLayout -e
	
	-af abRTSSCopyBn "top" 3
	-af abRTSSCopyBn "left" $lmargin
	-af abRTSSCopyBn "right" $rmargin
	
	-ac abRTSSPasteBn "top" 4 abRTSSCopyBn
	-af abRTSSPasteBn "left" $lmargin
	-af abRTSSPasteBn "right" $rmargin
	
	abRTSSForm
	;
	
	showWindow abRTSSWin;
	
}


global proc abRTSpaceSwitchCopyPaste(int $action){
	// used to match controls that have had their space switched
	// first, select the controls on the item at the frame that you want to match and call this function with action=0 to copy its position
	// then go to the frame where you want to match the control position after a space switch and paste the saved position (call this function with action=1)
	// $action = 0 is copy, $action = 1 is paste
	
	global string $aAbRTSpaceSwitchData[];
	
	// form of {"controlPath|Lots|Of|*tx,ty,tz*rx,ry,rz","controlPath|Lots|Of|*tx,ty,tz*rx,ry,rz"}
	
	if ($action == 0 || $action == 1){
		
		string $ctrl, $data, $aData[], $aSubData[], $statusStr;
		float $aTrans[], $aRot[];
		string $aSel[] = `ls -sl -type transform`;
		
		if ($action == 0){
			// copy the selected items info
			
			if (size($aSel) == 0){
				print "Select at least one control curve.";
				return;
			}
			
			string $transStr, $rotStr;
			
			for ($ctrl in $aSel){
				
				$aTrans = `xform -q -ws -rp $ctrl`;
				$aRot = `xform -q -ws -ro $ctrl`;
				
				$data = $ctrl+"*"+string($aTrans[0])+","+string($aTrans[1])+","+string($aTrans[2])+"*"+string($aRot[0])+","+string($aRot[1])+","+string($aRot[2]);
				$aData[size($aData)] = $data;
				
			}
			
			$aAbRTSpaceSwitchData = $aData;
			
			$statusStr = (size($aSel) == 1) ? " object position copied." : " object positions copied.";
			//print (size($aSel)+ $statusStr);
			
		}else if ($action == 1){
			// paste the save info
			
			if (size($aAbRTSpaceSwitchData) == 0){
				print "There is no data to paste.";
				return;
			}
			
			int $counter = 0;
			
			for ($data in $aAbRTSpaceSwitchData){
				$aData = stringToStringArray($data, "*");
				
				// get ctrl name
				$ctrl = $aData[0];
				
				// get trans info
				$aSubData = stringToStringArray($aData[1], ",");
				$aTrans[0] = float($aSubData[0]);
				$aTrans[1] = float($aSubData[1]);
				$aTrans[2] = float($aSubData[2]);
				
				// get rot info
				$aSubData = stringToStringArray($aData[2], ",");
				$aRot[0] = float($aSubData[0]);
				$aRot[1] = float($aSubData[1]);
				$aRot[2] = float($aSubData[2]);
				
				// apply it
				if (objExists($ctrl) && nodeType($ctrl) == "transform"){
					
					if (`getAttr -lock ($ctrl+".t")` == false) move -a -ws -rpr $aTrans[0] $aTrans[1] $aTrans[2] $ctrl;
					if (`getAttr -lock ($ctrl+".r")` == false) rotate -a -ws $aRot[0] $aRot[1] $aRot[2] $ctrl;
					
					$counter ++;
					
				}
			}
			
			$statusStr = (size($aSel) == 1) ? " object position modified." : " object positions modified.";
			//print ($counter+$statusStr);
			
		}
	}
	
	if (`window -exists abRTSSWin`) button -e -en (size($aAbRTSpaceSwitchData) > 0) abRTSSPasteBn;
	
}


global proc abRTMakeFKIKSnapBn(int $toggleStyle){
	// creates and displays the UI unless ctrl + shift are held in which case it adds a shelf button
	// $toggleStyle creates a one button UI with a toggle button
	
	string $cmd;
	
	int $lmargin = 3;
	int $rmargin = 3;
	int $vmargin = 3;
	
	int $mods = `getModifiers`;
	
	$saveToShelf = ($mods % 2 && ($mods / 4 % 2));
	
	$cmd = "if (`window -exists abRTFkIkSnapWin`) deleteUI -window abRTFkIkSnapWin;\n\n";
	
	$cmd += "window -t abFkIkSnap -w 136 -h 43 -menuBar true -minimizeButton false -maximizeButton false abRTFkIkSnapWin;\n\n";
	
	$cmd += "formLayout -numberOfDivisions 100 abRTFkIkSnapForm;\n\n";
	
	if (!$toggleStyle){
		
		$cmd += "button -label \"FK\" -command \"abRTFkIkSwitch(true);\" abRTFkIkSnapFKBn;\n";
		$cmd += "button -label \"IK\" -command \"abRTFkIkSwitch(false);\" abRTFkIkSnapIKBn;\n\n";
		
		$cmd += "formLayout -e\n\n";
		
		$cmd += "-af abRTFkIkSnapFKBn \"top\" "+$vmargin+"\n";
		$cmd += "-af abRTFkIkSnapFKBn \"bottom\" "+$vmargin+"\n";
		$cmd += "-af abRTFkIkSnapFKBn \"left\" "+$lmargin+"\n";
		$cmd += "-ap abRTFkIkSnapFKBn \"right\" "+(ceil($rmargin/2.0))+" 50\n\n";
		
		$cmd += "-ap abRTFkIkSnapIKBn \"left\" "+(ceil($lmargin/2.0))+" 50\n";
		$cmd += "-af abRTFkIkSnapIKBn \"right\" "+$rmargin+"\n";
		$cmd += "-af abRTFkIkSnapIKBn \"bottom\" "+$vmargin+"\n";
		$cmd += "-af abRTFkIkSnapIKBn \"top\" "+$vmargin+"\n\n";
		
		$cmd += "abRTFkIkSnapForm\n;\n\n";
		
	}else{
		
		$cmd += "button -label \"Toggle FK/IK\" -command \"abRTFkIkSwitch(2);\" abRTFkIkToggleBn;\n\n";
		
		$cmd += "formLayout -e\n\n";
		
		$cmd += "-af abRTFkIkToggleBn \"top\" "+$vmargin+"\n";
		$cmd += "-af abRTFkIkToggleBn \"bottom\" "+$vmargin+"\n";
		$cmd += "-af abRTFkIkToggleBn \"left\" "+$lmargin+"\n";
		$cmd += "-af abRTFkIkToggleBn \"right\" "+$rmargin+"\n\n";
		
		$cmd += "abRTFkIkSnapForm\n;\n\n";
	}
	
	// showWindow
	$cmd += "showWindow abRTFkIkSnapWin;\n";
	
	if ($saveToShelf){
		
		string $ann, $parent;
		
		$cmd = "if (!`exists abAutoRig`) source abAutoRig.mel;\nabRTInit();\n\n"+$cmd;
		
		if ($toggleStyle){
			$ann = "abAutoRig toggle IK/FK UI";
		}else{
			$ann = "abAutoRig switch IK/FK UI";
		}
		
		$parent = `shelfTabLayout -q -selectTab ShelfLayout`;
		$charBn = `shelfButton -i "abAutoRigSkel.bmp" -iol "IK/FK" -ann $ann -parent $parent -c $cmd`;
		
	}else{
		eval($cmd);
	}
	
}


global proc abRTSnapIkToFk(string $aFkJnts[], string $aFkCtrls[], string $aIkJnts[], string $ikCtrl, string $ikAttCtrl, string $jnt, string $pvCtrl){
	// snaps Ik ctrls to FkJnts in a most hacky way
	// $ikCtrl is wrist or ankle ikCtrl
	// $ikAttCtrl is curve with ikFkBlend attribute
	// $jnt is ankleJnt
	// if $jnt is "" then this is an arm that's being snapped (where the wrist joint has the same translation as the control curve)
	
	string $jntLoc, $ctrlLoc, $fkCtrlLoc, $ikCtrlLoc;
	float $aTrans[], $aRot[];
	
	// save current selection for later reselection
	string $aSel[] = `ls -sl`;
	
	if (!objExists($aFkCtrls[0])){
		warning ("Cannot find "+abRTStripPath($aFkCtrls[0])+" in the current scene.");
		return;
	}
	
	// if this is the old style of snap shelf button then user needs to rebuild the shelf button
	if (size($aFkCtrls) <= 2){
		warning "You need to rebuild the shelf button for this rig.  Look in the \"Tools\" menu.";
		return;
	}
	
	if ($jnt != ""){
		// dealing with a foot
		
		// get blend att and set it to 1 if not already (otherwise match won't work)
		float $ikFkBlend = `getAttr ($ikAttCtrl+".ikFkBlend")`;
		int $autoKey = `autoKeyframe -q -state`;
		int $changedIkFkBlend = false;
		
		if ($ikFkBlend < 1.0){
			if ($autoKey) autoKeyframe -state off;
			setAttr ($ikAttCtrl+".ikFkBlend") 1;
			$changedIkFkBlend = true;
		}
		
		// create loc for ankle joint and one for foot ctrl
		$jntLoc = abRTMakeLocator("snapIkToFkJntTempLoc");
		$ctrlLoc = abRTMakeLocator("snapIkToFkCtrlTempLoc");
		
		// parent ctrlLoc to ankleLoc
		$ctrlLoc = abRTParent($ctrlLoc, $jntLoc);
		
		// snap locs to ankle and footCtrl
		abRTSnapToPosition($jnt, $jntLoc);
		abRTSnapToPosition($ikCtrl, $ctrlLoc);
		
		// snap jntLoc to fkAnkleCtrl (same translation as the fkAnkle, and it's available) to find ctrl position
		abRTSnapToPosition($aFkJnts[2], $jntLoc);
		
		// get trans and rot of ctrl loc
		$aTrans = `xform -q -ws -rp $ctrlLoc`;
		
		// reset ikFkBlend and autoKey if necessary
		if ($changedIkFkBlend){
			autoKeyframe -state $autoKey;
			setAttr ($ikAttCtrl+".ikFkBlend") $ikFkBlend;
		}
		
		// hack attack
		// make dup ikCtrl to snap to $ctrlLoc and copy rot values
		string $aStr[] = `duplicate $ikCtrl`;
		string $dupIkCtrl = $aStr[0];
		
		abRTShowAttr($dupIkCtrl, {"tx","ty","tz","rx","ry","rz"});
		
		abRTSnapToPosition($ctrlLoc, $dupIkCtrl);
		
		// position ikCtrl
		move -a -ws -rpr $aTrans[0] $aTrans[1] $aTrans[2] $ikCtrl;
		
		$aRot = `getAttr ($dupIkCtrl+".r")`;
		setAttr ($ikCtrl+".r") $aRot[0] $aRot[1] $aRot[2];
		
		delete $dupIkCtrl;
		delete $jntLoc;
		
	}else{
		
		// it's an arm
		
		// need ikCtrl.IkCtrlOffsetFromWristJnt value for exact match (rigs created with v.4.3 and above)
		float $aIkCtrlWristJntOffset[];
		
		if (attributeExists("IkCtrlOffsetFromWristJnt", $ikCtrl)){
			
			$aIkCtrlWristJntOffset = `getAttr ($ikCtrl+".IkCtrlOffsetFromWristJnt")`;
		}else{
			
			string $result = `confirmDialog -title "Confirm" -message "You need to update your rig for IK/FK snap to work properly.\nSelect one of your character's control curves and run the\nfollowing mel in the command line or script window: \n\nabRTUpdateIkCtrlWristJntOffsetData();" -button "OK" -button "Update Now" -defaultButton "OK"`;
			if ($result == "Update Now")
				abRTUpdateIkCtrlWristJntOffsetData();
			return;
		}
		
		// create loc for ik and fk wrist ctrl
		string $ikCtrlLoc = abRTMakeLocator("snapIkToFkCtrlTempLoc");
		string $ikJntLoc = abRTMakeLocator("snapIkToFkCtrlTempLoc");
		
		// snap locs to ikCtrl and ikWristJnt
		abRTSnapToPosition($aFkJnts[2], $ikJntLoc);
		abRTSnapToPosition($aFkJnts[2], $ikCtrlLoc);
		
		// parent ikCtrlLoc to ikJntLoc
		$ikCtrlLoc = abRTParent($ikCtrlLoc, $ikJntLoc);
		
		// rotate ikCtrlLoc
		if (size($aIkCtrlWristJntOffset) == 3)
			setAttr ($ikCtrlLoc+".r") $aIkCtrlWristJntOffset[0] $aIkCtrlWristJntOffset[1] $aIkCtrlWristJntOffset[2];
		
		// make dup ikCtrl to snap to $ctrlLoc and copy rot values
		string $aStr[] = `duplicate $ikCtrl`;
		string $dupIkCtrl = $aStr[0];
		
		abRTShowAttr($dupIkCtrl, {"tx","ty","tz","rx","ry","rz"});
		abRTSnapToPosition($ikCtrlLoc, $dupIkCtrl);
		
		// now move arm to position (easy)
		$aTrans = `joint -q -p $aFkJnts[2]`;
		
		// position ikCtrl
		move -a -ws -rpr $aTrans[0] $aTrans[1] $aTrans[2] $ikCtrl;
		
		$aRot = `getAttr ($dupIkCtrl+".r")`;
		setAttr ($ikCtrl+".r") $aRot[0] $aRot[1] $aRot[2];
		
		delete $dupIkCtrl;
		delete $ikJntLoc;
		//delete $ikCtrlLoc;
	}
	
	// now to deal with the pvCtrl
	float $aPvTrans[] = abRTCalculatePVPosition($aFkJnts);
	move -a -ws -rpr $aPvTrans[0] $aPvTrans[1] $aPvTrans[2] $pvCtrl;
	
	if (size($aSel) > 0) select -r $aSel;
	
}


global proc float[] abRTCalculatePVPosition(string $aJnts[]){
	// returns worldspace position for pv given 3 joints in a chain
	
	float $aTrans[];
	
	// make 1 degree curve snapped to joints to determine pv location
	// pv offset is distance of fkKneeCtrl to fkAnkleCtrl (don't want to have to sent ikJnts)
	
	float $aUpJntTrans[] = `xform -q -ws -rp $aJnts[0]`;
	float $aMidJntTrans[] = `xform -q -ws -rp $aJnts[1]`;
	float $pvOffset = sqrt(pow(($aUpJntTrans[0] - $aMidJntTrans[0]), 2) + pow(($aUpJntTrans[1] - $aMidJntTrans[1]), 2) + pow(($aUpJntTrans[2] - $aMidJntTrans[2]), 2));
	
	int $i;
	string $curveCmd = "curve -d 1";
	
	for ($i=0;$i<size($aJnts);$i++){
		
		if (`nodeType $aJnts[$i]` == "joint")
			$aTrans = `joint -q -p $aJnts[$i]`;
		else
			$aTrans = `xform -q -ws -rp $aJnts[$i]`;
		
		$curveCmd += " -p "+$aTrans[0]+" "+$aTrans[1]+" "+$aTrans[2];
	}
	
	string $curve = eval($curveCmd);
	
	select -r ($curve+".cv[1]");
	moveVertexAlongDirection -n $pvOffset;
	select -clear;
	
	float $aPvTrans[] = `xform -q -ws -t ($curve+".cv[1]")`;
	
	delete $curve;
	
	return $aPvTrans;
	
}


global proc abRTUpdateIkCtrlWristJntOffsetData(){
	// updates older rigs by adding offset data to wrist ik ctrls
	
	//string $aSel[] = `ls -sl "*_ctrl"`;
	string $aSel[] = abRTStringArrayMatch(`ls -sl`, ".+_ctrl$");
	
	if (size($aSel) == 0){
		warning "Select one of your character's control curves and try again.";
		return;
	}
	
	string $charName = abRTGetCharNameFromCtrl($aSel[0], false);
	
	if ($charName == ""){
		warning "Unable to determine character.  Select a character control curve and try again.";
		return;
	}
	
	// reset pose
	abRTResetCharPose(true);
	
	abRTWriteIkCtrlWristJntOffsetData($charName+"_lf_wrist_jnt", $charName+"_lf_arm_ik_ctrl", "IkCtrlOffsetFromWristJnt");
	abRTWriteIkCtrlWristJntOffsetData($charName+"_rt_wrist_jnt", $charName+"_rt_arm_ik_ctrl", "IkCtrlOffsetFromWristJnt");
	
	print "\nUpdated offset data\n";
	
}


global proc abRTWriteIkCtrlWristJntOffsetData(string $jnt, string $ctrl, string $attName){
	// writes ikCtrl wrist jnt offset data (written by default on rigs created in v.4.3 and above)
	// $attName is name of att to add to $ctrl containing the offset values
	
	// get offset values (of Ik ctrl from wrist joint) for matching Ik to Fk
	string $jntLoc = abRTMakeLocator("tempOffsetJnt_loc");
	string $ctrlLoc = abRTMakeLocator("tempOffsetCtrl_loc");
	
	// match ikCtrl .ro
	abRTSnapToPosition($jnt, $jntLoc);
	abRTSnapToPosition($ctrl, $ctrlLoc);
	
	$ctrlLoc = abRTParent($ctrlLoc, $jntLoc);
	
	float $aRot[] = `getAttr ($ctrlLoc+".r")`;
	
	addAttr -dt float3 -hidden true -keyable false -longName $attName $ctrl;
	setAttr -type float3 ($ctrl+"."+$attName) $aRot[0] $aRot[1] $aRot[2];
	
	delete $jntLoc;
	// done with offset
	
}


global proc abRTSnapFkToIk(string $aFkCtrls[], string $aFkJnts[], string $aIkJnts[]){
	// snaps fk ctrls to ikJnts
	// aOffsets are rotation offsets (to compensate for fkctrls being zeroed out) in the form of {offsetX|offsetY|offsetZ, offsetX|offsetY|offsetZ}
	
	string $dupFkCtrl, $aStr[];
	int $i, $h;
	float $aFlt[], $aRot[];
	
	int $badSel = false;
	int $ok = true;
	
	// save current selection for later reselection
	string $aSel[] = `ls -sl`;
	
	if (!objExists($aFkCtrls[0])){
		warning ("Cannot find "+abRTStripPath($aFkCtrls[0])+" in the current scene.");
		return;
	}
	
	for ($i=0;$i<size($aIkJnts);$i++){
		if (`objExists $aFkCtrls[$i]` && `objExists $aIkJnts[$i]`){
			
			// hack attack
			// make dup fkCtrl to snap to $ctrlLoc and copy rot values
			
			for ($h=0;$h<size($aFkCtrls);$h++){
				
				$aStr = `duplicate $aFkCtrls[$i]`;
				$dupFkCtrl = $aStr[0];
				
				abRTShowAttr($dupFkCtrl, {"tx","ty","tz","rx","ry","rz"});
				abRTSnapToPosition($aIkJnts[$i], $dupFkCtrl);
				
				$aRot = `getAttr ($dupFkCtrl+".r")`;
				if (!`getAttr -lock ($aFkCtrls[$i]+".rx")`)
					setAttr ($aFkCtrls[$i]+".rx") $aRot[0];
				if (!`getAttr -lock ($aFkCtrls[$i]+".ry")`)
					setAttr ($aFkCtrls[$i]+".ry") $aRot[1];
				if (!`getAttr -lock ($aFkCtrls[$i]+".rz")`)
					setAttr ($aFkCtrls[$i]+".rz") $aRot[2];
				
				//setAttr ($aFkCtrls[$i]+".r") $aRot[0] $aRot[1] $aRot[2];
				
				delete $dupFkCtrl;
			}
			
		}else{
			$badSel = true;
		}
	}
	
	if ($badSel) warning "One or more specified objects no longer exist";
	
	if (size($aSel) > 0) select -r $aSel;
	
}


global proc abRTFkIkSwitch(int $toFk){
	// switches IK to FK if $toFk is true, else FK to IK
	// if $toFk == 2 then acts as a toggle
	
	string $aSel[], $ctrl, $snCtrl, $suf, $aLimbsToSnap[], $limbData, $cCharName, $cmd, $cLimb, $cPrefix, $blendObj, $blendAtt;
	int $match;
	
	string $lf = abRTGetGlobal("leftPrefix");
	string $rt = abRTGetGlobal("rightPrefix");
	
	string $aArmSuf[] = {"hand_ctrl","arm_ik_ctrl","elbow_pv_ctrl","wrist_fk_ctrl","elbow_fk_ctrl","upArm_fk_ctrl","clavicle_fk_ctrl","shoulder_ctrl","masterThumb_ctrl","thumbBase_fk_ctrl","thumbMid_fk_ctrl","thumbTip_fk_ctrl","masterIndex_ctrl","indexBase_fk_ctrl","indexMid_fk_ctrl","indexTip_fk_ctrl","masterMiddle_ctrl","middleBase_fk_ctrl","middleMid_fk_ctrl","middleTip_fk_ctrl","masterRing_ctrl","ringBase_fk_ctrl","ringMid_fk_ctrl","ringTip_fk_ctrl","masterPinky_ctrl","pinkyBase_fk_ctrl","pinkyMid_fk_ctrl","pinkyTip_fk_ctrl"};
	string $aLegSuf[] = {"foot_ctrl","heel_ik_ctrl","knee_pv_ctrl","ball_fk_ctrl","ankle_fk_ctrl","knee_fk_ctrl","upLeg_fk_ctrl","hip_ctrl"};
	
	float $cIkFkBlend;
	
	$blendAtt = "ikFkBlend";
	
	// get selection
	//$aSel = `ls -sl "*_ctrl"`;
	$aSel = abRTStringArrayMatch(`ls -sl`, ".+_ctrl$");
	
	if (size($aSel) == 0){
		warning "Select one or more limb controls and try again.";
		return;
	}
	
	for ($ctrl in $aSel){
		
		$cIkFkBlend = -1.0;
		$match = false;
		$snCtrl = shortNameOf($ctrl);
		$cCharName = abRTGetCharNameFromCtrl($snCtrl, false);
		
		if ($cCharName == "")
			continue;
		
		// check arms
		for ($suf in $aArmSuf){
			
			if (`match ($suf+"$") $snCtrl` == $suf){
				
				// found an arm
				if (`match ($lf+$suf+"$") $snCtrl` == ($lf+$suf)){
					
					$limbData = $cCharName+"|lfArm";
					if (abRTGetPosInStrArray($limbData, $aLimbsToSnap) == -1){
						$cPrefix = "l";
						$aLimbsToSnap[size($aLimbsToSnap)] = $limbData;
					}
					
				}else if (`match ($rt+$suf+"$") $snCtrl` == ($rt+$suf)){
					
					$limbData = $cCharName+"|rtArm";
					if (abRTGetPosInStrArray($limbData, $aLimbsToSnap) == -1){
						$cPrefix = "r";
						$aLimbsToSnap[size($aLimbsToSnap)] = $limbData;
					}
				}
				
				$cLimb = "arm";
				$match = true;
				
				// get blend value
				$blendObj = ($cPrefix == "l") ? $cCharName+"_"+$lf+"hand_ctrl" : $cCharName+"_"+$rt+"hand_ctrl";
				
				if (attributeExists($blendAtt, $blendObj)){
					$cIkFkBlend = `getAttr ($blendObj+"."+$blendAtt)`;
				}else{
					warning ("Unable to find attribute: "+$blendObj+"."+$blendAtt+".  Moving on.");
					continue;
				}
			}
		}
		
		if (!$match){
			for ($suf in $aLegSuf){
				
				if (`match ($suf+"$") $snCtrl` == $suf){
					
					// found an leg
					if (`match ($lf+$suf+"$") $snCtrl` == ($lf+$suf)){
						
						$limbData = $cCharName+"|lfLeg";
						if (abRTGetPosInStrArray($limbData, $aLimbsToSnap) == -1){
							$cPrefix = "l";
							$aLimbsToSnap[size($aLimbsToSnap)] = $limbData;
						}
						
					}else if (`match ($rt+$suf+"$") $snCtrl` == ($rt+$suf)){
						
						$limbData = $cCharName+"|rtLeg";
						if (abRTGetPosInStrArray($limbData, $aLimbsToSnap) == -1){
							$cPrefix = "r";
							$aLimbsToSnap[size($aLimbsToSnap)] = $limbData;
						}
					}
					
					// set some vars
					$cLimb = "leg";
					$match = true;
					
					// get blend value
					$blendObj = ($cPrefix == "l") ? $cCharName+"_"+$lf+"foot_ctrl" : $cCharName+"_"+$rt+"foot_ctrl";
					
					if (attributeExists($blendAtt, $blendObj)){
						$cIkFkBlend = `getAttr ($blendObj+"."+$blendAtt)`;
					}else{
						warning ("Unable to find attribute: "+$blendObj+"."+$blendAtt+".  Moving on.");
						continue;
					}
				}
			}
		}
		
		// make snap command
		if ($cIkFkBlend < 0)
			continue;
		
		int $snapToFk, $setIkFkBlendVal;
		
		$snapToFk = $toFk;
		
		
		if ($toFk != 2){
			$setIkFkBlendVal = 1 - $toFk;
		}else{
			// toggle ikFk
			$setIkFkBlendVal = ($cIkFkBlend > .5) ? 0 : 1;
		}
		
		
		if ($cIkFkBlend == 1){
			// if in IK and switching to FK, want FK to snap to IK to match position
			if ($toFk)
				$snapToFk = false;
		}else if ($cIkFkBlend == 0){
			// if in FK and switching to IK, want IK to snap to FK to match position
			if (!$toFk)
				$snapToFk = true;
		}
		
		$cmd = abRTMakeIKFKSnapCmd($cCharName, $cPrefix, $cLimb, $snapToFk);
		$cmd += "\n";
		$cmd += "setAttr \""+$blendObj+"."+$blendAtt+"\" "+$setIkFkBlendVal+";\n";
		
		eval($cmd);
	}
	
}


global proc string abRTMakeIKFKSnapCmd(string $charName, string $prefix, string $limb, int $toFK){
	// returns string command with args filled in for abRTSnapFkToIk or abRTSnapIkToFk (based on $toFk)
	// prefix is "l" or "r", $limb is "arm" or "leg"
	
	string $retStr;
	
	string $armFkToIkCmdStr = "abRTSnapFkToIk({\"*_#upArm_fk_ctrl\",\"*_#elbow_fk_ctrl\",\"*_#wrist_fk_ctrl\"},{\"*_#upArm_fk_jnt\",\"*_#elbow_fk_jnt\",\"*_#wrist_fk_jnt\"},{\"*_#upArm_ik_jnt\",\"*_#elbow_ik_jnt\",\"*_#wrist_ik_jnt\"});";
	string $armIkToFkCmdStr = "abRTSnapIkToFk({\"*_#upArm_fk_jnt\",\"*_#elbow_fk_jnt\",\"*_#wrist_fk_jnt\"},{\"*_#upArm_fk_ctrl\",\"*_#elbow_fk_ctrl\",\"*_#wrist_fk_ctrl\"},{\"*_#upArm_ik_jnt\",\"*_#elbow_ik_jnt\",\"*_#wrist_ik_jnt\"},\"*_#arm_ik_ctrl\",\"*_#hand_ctrl\",\"\",\"*_#elbow_pv_ctrl\");";
	string $legFkToIkCmdStr = "abRTSnapFkToIk({\"*_#upLeg_fk_ctrl\",\"*_#knee_fk_ctrl\",\"*_#ankle_fk_ctrl\",\"*_#ball_fk_ctrl\"},{\"*_#upLeg_fk_jnt\",\"*_#knee_fk_jnt\",\"*_#ankle_fk_jnt\",\"*_#ball_fk_jnt\"},{\"*_#upLeg_ik_jnt\",\"*_#knee_ik_jnt\",\"*_#ankleBallReader_Ankle_jnt\",\"*_#ankleBallReader_Ball_jnt\"});";
	string $legIkToFkCmdStr = "abRTSnapIkToFk({\"*_#upLeg_fk_jnt\",\"*_#knee_fk_jnt\",\"*_#ankle_fk_jnt\",\"*_#ball_fk_jnt\"},{\"*_#upLeg_fk_ctrl\",\"*_#knee_fk_ctrl\",\"*_#ankle_fk_ctrl\",\"*_#ball_fk_ctrl\"},{\"*_#upLeg_ik_jnt\",\"*_#knee_ik_jnt\",\"*_#ankleBallReader_Ankle_jnt\",\"*_#ankleBallReader_Ball_jnt\"},\"*_#heel_ik_ctrl\",\"*_#foot_ctrl\",\"*_#ankle_jnt\",\"*_#knee_pv_ctrl\");";
	
	string $pref = ($prefix == "l") ? abRTGetGlobal("leftPrefix") : abRTGetGlobal("rightPrefix");
	
	//* = charName
	//# = prefix
	
	if ($toFK)
		$retStr = ($limb == "arm") ? $armIkToFkCmdStr : $legIkToFkCmdStr;
	else
		$retStr = ($limb == "arm") ? $armFkToIkCmdStr : $legFkToIkCmdStr;
		
	$retStr = substituteAllString($retStr, "*", $charName);
	$retStr = substituteAllString($retStr, "#", $pref);
	
	return $retStr;
}


global proc int abRTGetPosInStrArray(string $str, string $aStr[]){
	// returns int (0 based) position of string in string array or -1 on fail.
	
	int $i;
	int $ret = -1;
	for ($i=0;$i<size($aStr);$i++){
		if ($aStr[$i] == $str){
			$ret = $i;
			break;
		}
	}
	
	return $ret;
	
}


global proc int abRTGetPosInIntArray(int $int, int $aInt[]){
	// returns int (0 based) position of int in int array or -1 on fail.
	
	int $i;
	int $ret = -1;
	for ($i=0;$i<size($aInt);$i++){
		if ($aInt[$i] == $int){
			$ret = $i;
			break;
		}
	}
	
	return $ret;
	
}


global proc string[] abRTStringArrayMatch(string $aArray[], string $matchStr){
	// runs a match ($matchstr) on all of the items in $aArray and returns the items that matched the full string
	// using this method because `ls -sl "*_ctrl"` doesn't seem to work with multiple characters in a scene for some reason
	
	string $item, $aRet[], $matchResult;
	
	for ($item in $aArray){
		
		$matchResult = `match $matchStr $item`;
		
		if ($matchResult == $item)
			$aRet[size($aRet)] = $item;
	}
	
	return $aRet;
}


global proc abRTToggleMenuItem(string $menuItem, string $globalKey){
	// toggles a checkbox boolean menuItem and updates it's global value
	
	int $cVal;
	if (!catchQuiet($cVal = `menuItem -q -checkBox $menuItem`)){
		abRTSetGlobal($globalKey, (string($cVal)));
	}
	
}


global proc abRTGlobals(){
	// init global prefs string[]
	
	global string $abRTGlobalPrefs[];
	global string $abRTGlobalPrefNames[];
	
	clear($abRTGlobalPrefNames);
	clear($abRTGlobalPrefs);
	
	$abRTGlobalPrefNames[0] = "leftPrefix";$abRTGlobalPrefs[0] = "lf_"; 			// left prefix
	$abRTGlobalPrefNames[1] = "rightPrefix";$abRTGlobalPrefs[1] = "rt_"; 			// rt prefix
	
	$abRTGlobalPrefNames[2] = "name";$abRTGlobalPrefs[2] = "charName"; 			// character name
	$abRTGlobalPrefNames[3] = "globalScale";$abRTGlobalPrefs[3] = "1"; 			// global scale
	$abRTGlobalPrefNames[4] = "avgHeight";$abRTGlobalPrefs[4] = "183"; 			// units in avg height -- used to determine scale {183~6'0")
	$abRTGlobalPrefNames[5] = "deleteMeGrp";$abRTGlobalPrefs[5] = "abRTDeleteMeWhenDone"; 	// name of group to put temp rig building transforms in
	$abRTGlobalPrefNames[6] = "ctrlDir";$abRTGlobalPrefs[6] = "ctrl_grp"; 			// name of group to put control curves in
	$abRTGlobalPrefNames[7] = "versionNum";$abRTGlobalPrefs[7] = "6.03"; 			// script version Number
	$abRTGlobalPrefNames[8] = "premiumVersion";$abRTGlobalPrefs[8] = "0"; 			// true if this is the premium version of the script (standard or premium)
	
	$abRTGlobalPrefNames[10] = "pvOffset";$abRTGlobalPrefs[10] = "20"; 			// pv ctrl offset from controlled jnt -- (no longer used)
	$abRTGlobalPrefNames[11] = "eyeCtrlOffset";$abRTGlobalPrefs[11] = "40"; 		// eye ctrl offset from eye jnts
	
	$abRTGlobalPrefNames[22] = "includeHeadNeckTransAtts";$abRTGlobalPrefs[22] = "1"; 	// show the fk (trans and useRootSpace) options on head and neck controls
	$abRTGlobalPrefNames[23] = "addSpineShaper";$abRTGlobalPrefs[23] = "0"; 		// enable to add a spine shaper to the spine control curves
	$abRTGlobalPrefNames[24] = "createIkFingerCtrls";$abRTGlobalPrefs[24] = "1"; 		// add IK controls to finger rig
	$abRTGlobalPrefNames[25] = "alignHandIkToWorld";$abRTGlobalPrefs[25] = "1"; 		// align the hand IK controls to the world axes
	$abRTGlobalPrefNames[26] = "alignCtrlCrvsToSpine";$abRTGlobalPrefs[26] = "0"; 		// align top two spine control curves to the spine
	$abRTGlobalPrefNames[27] = "spineJntNum";$abRTGlobalPrefs[27] = "8"; 			// default number of weightSpineJnts
	$abRTGlobalPrefNames[28] = "footIKCtrlAtAnkle";$abRTGlobalPrefs[28] = "1"; 		// foot IK control rotates around the heel or the ankle
	$abRTGlobalPrefNames[29] = "createLimbWtJntsInHierarchy";$abRTGlobalPrefs[29] = "1"; 	// if true, limb weight joints will be created in a hierarchical chain;  otherwise, they'll be separate and apart
	
	// colors
	$abRTGlobalPrefNames[30] = "ikJntColor";$abRTGlobalPrefs[30] = "28"; 			// ik joint color
	$abRTGlobalPrefNames[31] = "fkJntColor";$abRTGlobalPrefs[31] = "18"; 			// fk joint color
	$abRTGlobalPrefNames[32] = "lfCtrlColor";$abRTGlobalPrefs[32] = "6"; 			// left ctrl joint color
	$abRTGlobalPrefNames[33] = "rtCtrlColor";$abRTGlobalPrefs[33] = "13"; 			// right ctrl joint color
	$abRTGlobalPrefNames[34] = "ctrCtrlColor";$abRTGlobalPrefs[34] = "17"; 			// center ctrl color
	$abRTGlobalPrefNames[35] = "ctrMasterCtrlColor";$abRTGlobalPrefs[35] = "21"; 		// center master ctrl color
	$abRTGlobalPrefNames[36] = "cogCtrlColor";$abRTGlobalPrefs[36] = "16"; 			// cog ctrl color
	$abRTGlobalPrefNames[37] = "rootCtrlColor";$abRTGlobalPrefs[37] = "3"; 			// root and rigSettings ctrl color
	$abRTGlobalPrefNames[38] = "lfFingerCtrlColor";$abRTGlobalPrefs[38] = "6"; 		// left finger ctrl color
	$abRTGlobalPrefNames[39] = "rtFingerCtrlColor";$abRTGlobalPrefs[39] = "13"; 		// right finger ctrl color
	
	// skeleton maker
	$abRTGlobalPrefNames[40] = "autoSaveSkeleton";$abRTGlobalPrefs[40] = "1"; 		// autoSave skeleton checkbox
	$abRTGlobalPrefNames[41] = "autoMirror";$abRTGlobalPrefs[41] = "1"; 			// autoMirror rigs on creation (legs, arms, hands)
	$abRTGlobalPrefNames[42] = "proxyLocScale";$abRTGlobalPrefs[42] = ".4"; 		// size of locs on proxy skeleton
	$abRTGlobalPrefNames[43] = "lockProxyCtlAxes";$abRTGlobalPrefs[43] = "1"; 		// lock proxy control axes
	$abRTGlobalPrefNames[44] = "legMirrorBehavior";$abRTGlobalPrefs[44] = "1"; 		// if true, the leg joints will be mirrored using behavior, otherwise will be mirrored using orientation
	
	// rotation
	$abRTGlobalPrefNames[50] = "thumbCurlSpreadRoll";$abRTGlobalPrefs[50] = "zyx"; 		// axes for thumb curl, spread and roll
	$abRTGlobalPrefNames[51] = "fingerCurlSpreadRoll";$abRTGlobalPrefs[51] = "yzx"; 	// axes for finger curl, spread and roll
	$abRTGlobalPrefNames[52] = "fingerCupAxis";$abRTGlobalPrefs[52] = "y"; 			// axis for finger cup joints
	$abRTGlobalPrefNames[53] = "reverseFingerCurl";$abRTGlobalPrefs[53] = "0"; 		// true if handJoints have been mirrored without -mirrorBehavior (pre 2.0 skeletons), otherwise false 
	
	// split joints
	$abRTGlobalPrefNames[60] = "upArmSplitNum";$abRTGlobalPrefs[60] = "1";			// number of split joints on upArm
	$abRTGlobalPrefNames[61] = "foreArmSplitNum";$abRTGlobalPrefs[61] = "2"; 		// number of split joints on foreArm
	$abRTGlobalPrefNames[62] = "upLegSplitNum";$abRTGlobalPrefs[62] = "1"; 			// number of split joints on upLeg
	$abRTGlobalPrefNames[63] = "lowLegSplitNum";$abRTGlobalPrefs[63] = "1"; 		// number of split joints on lowLeg
	
	// marking menu
	$abRTGlobalPrefNames[65] = "bakeFingersToFkCtrls";$abRTGlobalPrefs[65] = "0";		// bake masterFinger control rotations to FK controls if true, otherwise move them to hand control finger atts
	
	// rubberhose limbs
	$abRTGlobalPrefNames[70] = "rubberHoseLegs";$abRTGlobalPrefs[70] = "0"; 		// create rubberhose legs
	$abRTGlobalPrefNames[71] = "rhUpLegCtrlNum";$abRTGlobalPrefs[71] = "0"; 		// number of controls on the upLeg rubberhose
	$abRTGlobalPrefNames[72] = "rhLowLegCtrlNum";$abRTGlobalPrefs[72] = "0"; 		// number of controls on the lowLeg rubberhose
	$abRTGlobalPrefNames[73] = "rubberHoseArms";$abRTGlobalPrefs[73] = "0"; 		// create rubberhose arms
	$abRTGlobalPrefNames[74] = "rhUpArmCtrlNum";$abRTGlobalPrefs[74] = "0"; 		// number of controls on the upArm rubberhose
	$abRTGlobalPrefNames[75] = "rhForeArmCtrlNum";$abRTGlobalPrefs[75] = "0"; 		// number of controls on the foreArm rubberhose
	
	// squash and stretch
	$abRTGlobalPrefNames[80] = "squashStretchSpine";$abRTGlobalPrefs[80] = "0"; 		// add squash and stretch to spine
	$abRTGlobalPrefNames[81] = "squashStretchLegs";$abRTGlobalPrefs[81] = "0"; 		// add squash and stretch to legs
	$abRTGlobalPrefNames[82] = "squashStretchArms";$abRTGlobalPrefs[82] = "0"; 		// add squash and stretch to arms
	
	// split joint values
	$abRTGlobalPrefNames[84] = "upLegSpltBlndSettings";$abRTGlobalPrefs[84] = "0.4,1.0,2,0,1";		// start value, end value, blendType, blend from second value, blend to next to last value
	$abRTGlobalPrefNames[85] = "dnLegSpltBlndSettings";$abRTGlobalPrefs[85] = "0.0,1.0,6,1,1";
	$abRTGlobalPrefNames[86] = "upArmSpltBlndSettings";$abRTGlobalPrefs[86] = "0.4,1.0,2,0,1";
	$abRTGlobalPrefNames[87] = "dnArmSpltBlndSettings";$abRTGlobalPrefs[87] = "0.0,1.0,6,1,1";
	
	$abRTGlobalPrefNames[88] = "initUpLegSpltBlndSettings";$abRTGlobalPrefs[88] = $abRTGlobalPrefs[84];	// used for reseting split weight vars to default
	$abRTGlobalPrefNames[89] = "initDnLegSpltBlndSettings";$abRTGlobalPrefs[89] = $abRTGlobalPrefs[85];
	$abRTGlobalPrefNames[90] = "initUpArmSpltBlndSettings";$abRTGlobalPrefs[90] = $abRTGlobalPrefs[86];
	$abRTGlobalPrefNames[91] = "initDnArmSpltBlndSettings";$abRTGlobalPrefs[91] = $abRTGlobalPrefs[87];
	
}


global proc string abRTGetGlobal(string $name){
	// return string value of value $name
	
	global string $abRTGlobalPrefs[];
	global string $abRTGlobalPrefNames[];
	
	string $ret;
	
	int $index = abRTGetPosInStrArray($name, $abRTGlobalPrefNames);
	if ($index != -1) $ret = $abRTGlobalPrefs[$index];
	
	return $ret;
	
}


global proc abRTSetGlobal(string $name, string $strVal){
	// set global pref $name to $strVal
	
	global string $abRTGlobalPrefs[];
	global string $abRTGlobalPrefNames[];
	
	int $index = abRTGetPosInStrArray($name, $abRTGlobalPrefNames);
	if ($index != -1) $abRTGlobalPrefs[$index] = $strVal;
	
}


global proc string abRTGetFromUI(string $uiItem){
	// returns current value of UI item (usually a field) or "" if empty
	
	string $ret;
	
	$uiItem = capitalizeString($uiItem);
	
	if ($uiItem == "Name"){
		string $textFieldGrpName = "abRT"+$uiItem+"TxFldGrp";
		if (`textFieldGrp -q -exists $textFieldGrpName`)
			$ret = `textFieldGrp -q -text $textFieldGrpName`;
		
	}else{
		string $textFieldBnGrpName = "abRT"+$uiItem+"TxFldBnGrp";
		
		if (`textFieldButtonGrp -q -exists $textFieldBnGrpName`)
			$ret = `textFieldButtonGrp -q -text $textFieldBnGrpName`;
	}
	
	return $ret;
	
}


global proc abRTSetUITxtFld(string $uiName, string $obj){
	// sets text field named "abRT"+capitalizeString($caller)+"TxFldBnGrp" to $obj (if it exists)
	
	if (`objExists $obj`){
		string $aStr[] = `ls -long $obj`;
		$obj = $aStr[0];
		string $textField = "abRT"+capitalizeString($uiName)+"TxFldBnGrp";
		if (`textFieldButtonGrp -q -e $textField`){
			textFieldButtonGrp -e -text $obj $textField;
		}
	}
	
}


global proc abRTClearUIItems(){
	// clears all (but name) UI fields.  Called on create skeleton (in main ui) click

	string $aItems[] = {"masterScaleJnt","rootCtrl","spineRoot","hip","cogCtrl","lowSpineCtrl","midSpineCtrl_1","midSpineCtrl_2","midSpineCtrl_3","midSpineCtrl_4","midSpineCtrl_5","midSpineCtrl_6","midSpineCtrl_7","midSpineCtrl_8","midSpineCtrl_9","hiSpineCtrl","masterSpineCtrl","rigSettingsCtrl","neck","neck_1","neck_2","neck_3","neck_4","neck_1_Ctrl","neck_2_Ctrl","neck_3_Ctrl","neck_4_Ctrl","head","eye","headCtrl","hipCtrl","upLeg","heelLoc","lfLegIkCtrl","rtLegIkCtrl","upArm","lfArmIkCtrl","rtArmIkCtrl","handCtrl","lfHandCtrl","rtHandCtrl","thumb","index","middle","ring","pinky","pinkyCup","ringCup","jaw"};
	
	string $item;
	
	for ($item in $aItems) textFieldButtonGrp -e -text "" ("abRT"+capitalizeString($item)+"TxFldBnGrp");
	
	abRTGuessUIItems();
}


global proc abRTCheckUIItems(string $selObj){
	// runs through UI fields and checks to see if selected items still exist.  Called on new selection and button click
	// removes selObj (if != "") from any fields it's in to prevent selecting the same object for multiple fields
	
	string $aItems[] = {"masterScaleJnt","rootCtrl","spineRoot","hip","cogCtrl","lowSpineCtrl","midSpineCtrl_1","midSpineCtrl_2","midSpineCtrl_3","midSpineCtrl_4","midSpineCtrl_5","midSpineCtrl_6","midSpineCtrl_7","midSpineCtrl_8","midSpineCtrl_9","hiSpineCtrl","masterSpineCtrl","rigSettingsCtrl","neck","neck_1","neck_2","neck_3","neck_4","neck_1_Ctrl","neck_2_Ctrl","neck_3_Ctrl","neck_4_Ctrl","head","eye","headCtrl","hipCtrl","upLeg","heelLoc","lfLegIkCtrl","rtLegIkCtrl","upArm","lfArmIkCtrl","rtArmIkCtrl","handCtrl","lfHandCtrl","rtHandCtrl","thumb","index","middle","ring","pinky","pinkyCup","ringCup","jaw"};
	
	string $item, $uiValue;
	
	for ($item in $aItems){
		
		$uiValue = abRTGetFromUI($item);
		if (!`objExists $uiValue` || $uiValue == $selObj){
			textFieldButtonGrp -e -text "" ("abRT"+capitalizeString($item)+"TxFldBnGrp");
		}
	}
}


global proc abRTGuessUIItems(){
	// attempts to fill in various important hidden UI items when called using name matching
	
	string $charName = abRTGetGlobal("name");
	string $ctrl;
	
	string $aNameSuffix[] = {
		"rigSettingsCtrl","_rigSettings_ctrl",
		"rootCtrl","_root_ctrl",
		"hiSpineCtrl","_spineHigh_ctrl",
		"masterSpineCtrl","_masterSpine_ctrl",
		
		"midSpineCtrl_1","_spineMid_1_ctrl", 
		"midSpineCtrl_2","_spineMid_2_ctrl",
		"midSpineCtrl_3","_spineMid_3_ctrl",
		"midSpineCtrl_4","_spineMid_4_ctrl",
		"midSpineCtrl_5","_spineMid_5_ctrl",
		"midSpineCtrl_6","_spineMid_6_ctrl",
		"midSpineCtrl_7","_spineMid_7_ctrl",
		"midSpineCtrl_8","_spineMid_8_ctrl",
		"midSpineCtrl_9","_spineMid_9_ctrl",
		
		"lowSpineCtrl","_spineLow_ctrl",
		"cogCtrl","_cog_ctrl",
		"hipCtrl","_hip_ctrl",
		"headCtrl","_head_fk_ctrl",
		"spineRoot","_spine_low_jnt",
		"hip","_hip_jnt",
		
		"neck","_neck_jnt",
		"neck","_neck_1_jnt",
		"neck_1","_neck_1_jnt",
		"neck_2","_neck_2_jnt",
		"neck_3","_neck_3_jnt",
		"neck_4","_neck_4_jnt",
		"neck_1_Ctrl","_neck_fk_ctrl",
		"neck_1_Ctrl","_neck_1_ctrl",
		"neck_2_Ctrl","_neck_2_ctrl",
		"neck_3_Ctrl","_neck_3_ctrl",
		"neck_4_Ctrl","_neck_4_ctrl",
		
		"head","_head_a_jnt",
		"eye","_lf_eye_jnt",
		"jaw","_jaw_a_jnt",
		
		"upLeg","_lf_upLeg_jnt",
		"heelLoc","_lf_heel_loc",
		
		"upArm","_lf_upArm_jnt",
		
		"handCtrl","_lf_hand_ctrl",
		"thumb","_lf_thumb_a_jnt",
		"index","_lf_index_a_jnt",
		"middle","_lf_middle_a_jnt",
		"ring","_lf_ring_a_jnt",
		"pinky","_lf_pinky_a_jnt",
		"pinkyCup","_lf_pinkyCup_jnt",
		"ringCup","_lf_ringCup_jnt", 
		
		"lfHandCtrl","_lf_hand_ctrl",
		"rtHandCtrl","_rt_hand_ctrl",
		
		"lfLegIkCtrl","_lf_heel_ik_ctrl",
		"rtLegIkCtrl","_rt_heel_ik_ctrl",
		
		"lfArmIkCtrl","_lf_arm_ik_ctrl",
		"rtArmIkCtrl","_rt_arm_ik_ctrl"
	};
	
	int $i;
	for ($i=0;$i<size($aNameSuffix);$i+=2){
		
		if (abRTGetFromUI($aNameSuffix[$i]) == ""){
			$ctrl = $charName+$aNameSuffix[$i+1];
			if (`objExists $ctrl`) abRTSetUITxtFld($aNameSuffix[$i], $ctrl);
		}
	}
	
	// set checkBoxes and intSliders from embedded skeleton info
	string $attVal, $aStr[], $globalName, $uiName, $evalCmd;
	int $good;
	
	// make array to set and update all globals values read in from skeleton
	// in the form of "skeletonGlobalName","correspondingUIName","function to eval")
	// UIType inferred from UIName suffix -- must be standardized
	
	string $aGlobalAttVals[] = {
		"spineJntNum","abRTSpineJntsIntSldrGrp","",
		"alignCtrlCrvsToSpine","abRTOrientSpineCtrlsChkBx","",
		"addSpineShaper","abRTAddSpineShaperChkBx","",
		"includeHeadNeckTransAtts","abRTIncludeHeadNeckTransAttsChkBx","",
		"createIkFingerCtrls","abRTCreateIkFingerChkBx","",
		"alignHandIkToWorld","abRTAlignHandIKChkBx","",
		"upArmSplitNum","abRTUpArmSpltIntSldrGrp","abRTServiceUIButton(\"armSplitJointSlider\");",
		"foreArmSplitNum","abRTForeArmSpltIntSldrGrp","abRTServiceUIButton(\"armSplitJointSlider\");",
		"upLegSplitNum","abRTUpLegSpltIntSldrGrp","abRTServiceUIButton(\"legSplitJointSlider\");",
		"lowLegSplitNum","abRTLowLegSpltIntSldrGrp","abRTServiceUIButton(\"legSplitJointSlider\");",
		"rubberHoseLegs","abRTCreateRubberHoseLegsChkBx","abRTServiceUIButton(\"legSplitJointSlider\");abRTServiceUIButton(\"legRubberHoseBn\");",
		"rhUpLegCtrlNum","abRTUpLegRhCtrlNumIntSldrGrp","",
		"rhLowLegCtrlNum","abRTLowLegRhCtrlNumIntSldrGrp","",
		"rubberHoseArms","abRTCreateRubberHoseArmsChkBx","abRTServiceUIButton(\"armSplitJointSlider\");abRTServiceUIButton(\"armRubberHoseBn\");",
		"rhUpArmCtrlNum","abRTUpArmRhCtrlNumIntSldrGrp","",
	        "rhForeArmCtrlNum","abRTForeArmRhCtrlNumIntSldrGrp","",
	        "squashStretchSpine","abRTSpineSqStChkBx","",
	        "squashStretchLegs","abRTLegsSqStChkBx","",
	        "squashStretchArms","abRTArmsSqStChkBx","",
	        "footIKCtrlAtAnkle","abRTFootIKCtrlAtAnkleChkBx",""
	};
	
	for ($i=0;$i<size($aGlobalAttVals);$i+=3){
		
		$good = false;
		
		$globalName = $aGlobalAttVals[$i];
		$uiName = $aGlobalAttVals[$i+1];
		$evalCmd = $aGlobalAttVals[$i+2];
		
		if (abRTGetRootJntAtt($globalName, $charName) != ""){
			
			$attVal = abRTGetRootJntAtt($globalName, $charName);
			abRTSetGlobal($globalName, $attVal);
			
			if (`match "intsldrgrp$" (tolower($uiName))` == "intsldrgrp"){
				
				if (`intSliderGrp -q -ex $uiName`)
					intSliderGrp -e -v (int($attVal)) $uiName;
				
				$good = true;
				
			}else if (`match "chkbx$" (tolower($uiName))` == "chkbx"){
				
				if (`checkBox -q -ex $uiName`)
					checkBox -e -v (int($attVal)) $uiName;
				
				$good = true;
			}
			
			if ($good){
				if ($evalCmd != "")
					eval($evalCmd);
			}
		}
	}
	
}


global proc string abRTGetDeleteMeGrpName(){
	// returns name of group to be used as a trash can for transforms to delete once the rig is built (like heelLocs).  The null will be created if it doesn't exist
	
	string $grp = abRTGetGlobal("deleteMeGrp");
	if (!(`objExists $grp`)) group -name $grp -em -w;
	
	return $grp;
	
}


global proc string abRTSwapSidePrefix(string $str){
	// swaps all occurences of left or right prefix with opposite
	
	string $lfPre = abRTGetGlobal("leftPrefix");
	string $rtPre = abRTGetGlobal("rightPrefix");
	string $ret, $regEx, $replace;
	int $match = false;
	
	if (`match $lfPre $str` == $lfPre){
		$match = true;
		$regEx = $lfPre;
		$replace = $rtPre;
	}else if (`match $rtPre $str` == $rtPre){
		$match = true;
		$regEx = $rtPre;
		$replace = $lfPre;
	}
	
	if ($match) $ret = abRTSubstituteAll($regEx, $str, $replace);
	
	return $ret;
	
}


global proc string abRTSubstituteAll(string $regEx, string $subject, string $replace){
	// like substitute all, but will replace all occurences of $regEx in $subject with $replace
	
	string $ret, $lastSubject;
	string $str = $subject;
	
	while ($str != $lastSubject){
		$lastSubject = $str;
		$str = `substitute $regEx $str $replace`;
	}
	
	$ret = $str;
	
	return $ret;
}


global proc string abRTGetObjSide(string $obj){
	/*
	returns "l", "r", or "" based on x trans of given joint (rigs must be symmetrical across YZ and facing forward in Z)
	will return nothing if $obj.tx is within tolerance of origin
	*/
	
	string $ret;
	float $tol = .0001;
	
	string $tLoc = abRTMakeLocator("abGetObjSide_loc");
	
	abRTSnapToPosition($obj, $tLoc);
	
	float $aTrans[] = `xform -q -ws -t $tLoc`;
	delete $tLoc;
	
	float $tx = $aTrans[0];
	
	if ($tx > $tol){
		$ret = "l";
	}else if ($tx < -$tol){
		$ret = "r";
	}
	
	return $ret;
}


global proc string abRTRigNamer(string $locKey, string $prefix, string $objType){
	/*
	returns a string with a name for an object based on:
	$locKey = global keyword for object name in hierarchy "hip", "upLeg", etc, unless $useLocKeyAsName is true, in which case $locKey will be used as the name
	$prefix = "l", "r", or ""
	$objType can be "ctrl" (curve controller), "jnt" (regular joint skin will be weighted to), "ikJnt" (joint for ik), "fkkJnt" (joint for fk),
	"utilJnt" (utility joint)
	*/
	
	string $rigName = abRTGetGlobal("name");
	
	if ($prefix == "l"){
		$prefix = abRTGetGlobal("leftPrefix");
	}else if ($prefix == "r"){
		$prefix = abRTGetGlobal("rightPrefix");
	}
	
	//string $locName = ($useLocKeyAsName) ? $locKey : abRTGetGlobal($locKey);
	string $locName = $locKey;
	string $newName = $rigName+"_"+$prefix+$locName;
	string $suf;
	
	switch($objType){
		case "ctrl": $suf = "ctrl"; break;
		case "ikCtrl": $suf = "ik_ctrl"; break;
		case "fkCtrl": $suf = "fk_ctrl"; break;
		case "jnt": $suf = "jnt"; break;
		case "ikJnt": $suf = "ik_jnt"; break;
		case "fkJnt": $suf = "fk_jnt"; break;
		case "rvRigJnt": $suf = "rev_rig_jnt"; break;
		case "utilJnt": $suf = "ut_jnt"; break;
		case "loc": $suf = "loc"; break;
		case "grp": $suf = "grp"; break;
		case "rigGrp": $suf = "rig_grp"; break;
		case "refJnt": $suf = "ref_jnt"; break;
		case "ikHndl": $suf = "ikHandle"; break;
		case "pvCtrl": $suf = "pv_ctrl"; break;
		case "pvCons": $suf = "pv_cons"; break;
		case "orCons": $suf = "or_cons"; break;
		case "ptCons": $suf = "pt_cons"; break;
		case "parCons": $suf = "par_cons"; break;
		case "aimCons": $suf = "aim_cons"; break;
		case "lineLoc": $suf = "line_loc"; break;
		case "fkPtCons": $suf = "fk_pt_cons"; break;
		case "fkParCons": $suf = "fk_par_cons"; break;
		case "fkPlsmns": $suf = "fk_plusMinus"; break;
		case "fkOrCons": $suf = "fk_or_cons"; break;
		case "ikOrCons": $suf = "ik_or_cons"; break;
		case "spcSwtchGrp": $suf = "space_switch_grp"; break;
		case "cond": $suf = "cond"; break;
		case "clmp": $suf = "clamp"; break;
		case "plsmns": $suf = "plusMinus"; break;
		case "rvrs": $suf = "reverse"; break;
		case "blnd": $suf = "blend"; break;  
		case "mltDiv": $suf = "multDiv"; break;
		default: $suf = $objType; break;
	}
	
	$newName += "_"+$suf;
	
	return $newName;
}


global proc string[] abRTRename(string $fullPath, string $newName){
	/*
	renames $obj (send fullPath) to $newName
	returns string[] where $aRet[0] = object's new name, $aRet[1] = objects new path with name, $aRet[2] = objects new path not including name
	*/
	
	string $aRet[];
	
	$fullPath = longNameOf($fullPath);
	
	string $newName = `rename $fullPath $newName`;
	string $aStr[] = stringToStringArray($newName, "|");
	$newName = $aStr[size($aStr)-1];
	
	$aStr = stringToStringArray($fullPath, "|");
	$aStr[size($aStr)-1] = $newName;
	string $newLongName = stringArrayToString($aStr, "|");
	
	int $i;
	string $newPath;
	for ($i=0;$i<(size($aStr)-1);$i++){
		if ($i>0) $newPath += "|";
		$newPath += $aStr[$i];
	}
	
	$aRet[size($aRet)] = $newName;
	$aRet[size($aRet)] = "|"+$newLongName;
	$aRet[size($aRet)] = "|"+$newPath;
	
	return $aRet;
}


global proc string abRTParent(string $child, string $parent){
	// parents $child to $parent and returns new full path of $child
	
	string $ret;
	
	string $aStr[] = `ls -long $parent`;
	$parent = $aStr[0];
	$aStr = `ls -long $child`;
	$child = $aStr[0];
	
	if (firstParentOf($child) != $parent){
		$aStr = `parent $child $parent`;
		$ret = $parent+"|"+abRTStripPath($aStr[0]);
	}else{
		$ret = $child;
	}
	
	return $ret;
}


global proc abRTServiceUI(string $caller){
	// updates globals and fields when a joint is specified in the UI
	// $caller gives the info as to what control called this proc
	
	int $badSel;
	string $selObj;
	string $aSel[] = `ls -sl -long`;
	
	if (size($aSel) == 1){
		$selObj = $aSel[0];
		abRTCheckUIItems($selObj);
	}else{
		$badSel = true;
	}
	
	if (!$badSel){
		
		int $i, $int;
		string $aJnts[], $jnt, $newName, $aNewName[], $fieldStr, $aRel[], $aTempRel[], $aStr[];
		
		$aRel = `listRelatives -ad -fullPath $selObj`;
		
		switch($caller){
			case "upLeg": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTUpLegTxFldBnGrp; break;
			case "upArm": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTUpArmTxFldBnGrp; break;
			case "heelLoc": if (`nodeType $selObj` == "transform" || `nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTHeelLocTxFldBnGrp; break;
			
			
			case "spineRoot":
			float $float;
			if (`nodeType $selObj` == "joint"){
				$float = `getAttr ($selObj+".tx")`;
				if ((abs($float)) <= .0000000000001){
					textFieldButtonGrp -e -text $selObj abRTSpineRootTxFldBnGrp;
				}else{
					warning "Root joint must have a x translate of 0.";
					$badSel = true;
				}
			}
			break;
			
			case "hip": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTHipTxFldBnGrp; else $badSel = true; break;
			case "neck": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTNeckTxFldBnGrp; else $badSel = true; break;
			case "head": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTHeadTxFldBnGrp; else $badSel = true; break;
			case "eye": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTEyeTxFldBnGrp; else $badSel = true; break;
			
			case "handCtrl": if (`nodeType $selObj` == "transform" && `nodeType $aRel[0]` == "nurbsCurve") textFieldButtonGrp -e -text $selObj abRTHandCtrlTxFldBnGrp; else $badSel = true; break;
			case "thumb": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTThumbTxFldBnGrp; else $badSel = true; break;
			case "index": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTIndexTxFldBnGrp; else $badSel = true; break;
			case "middle": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTMiddleTxFldBnGrp; else $badSel = true; break;
			case "ring": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTRingTxFldBnGrp; else $badSel = true; break;
			case "pinky": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTPinkyTxFldBnGrp; else $badSel = true; break;
			case "ringCup": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTRingCupTxFldBnGrp; else $badSel = true; break;
			case "pinkyCup": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTPinkyCupTxFldBnGrp; else $badSel = true; break;
			
		}
	}
	
	if ($badSel){
		
		string $textFieldBnGrpName = "abRT"+capitalizeString($caller)+"TxFldBnGrp";
		if (`textFieldButtonGrp -q -exists $textFieldBnGrpName`) textFieldButtonGrp -e -text "" $textFieldBnGrpName;
		
		if (size($aSel) > 1) warning "Select only one object";
	}
}


global proc abRTServiceUIButton(string $caller){
	
	abRTCheckUIItems("");
	string $aJnts[];
	int $result;
	int $autoMirror = int(abRTGetGlobal("autoMirror"));
	
	if (`currentUnit -q -linear` != "cm"){
		warning "The rig can't be built unless your linear working unit is set to centimeter.  Change it in Window > Settings/Preferences > Preferences > Settings and try again.  You can always change back to your preferred setting once the rig has been built.";
		return;
	}
	
	abRTCheckSoftMod(true);
	
	switch($caller){
		case "createLeg":
		
		string $upLeg = abRTGetFromUI("upLeg");
		string $heelLoc = abRTGetFromUI("heelLoc");
		if ($upLeg != "" && $heelLoc != ""){
			
			string $mUpLeg = abRTGetMirrorObj($upLeg);
			string $mHeelLoc = abRTGetMirrorObj($heelLoc);
			
			// check leg joint rotation
			$aJnts = `listRelatives -ad -type joint -f $upLeg`;
			$aJnts = stringArrayCatenate({$upLeg}, $aJnts);
			if ($autoMirror && $mUpLeg != ""){
				$aJnts = stringArrayCatenate($aJnts,{$mUpLeg});
				$aJnts = stringArrayCatenate($aJnts,(`listRelatives -ad -type joint -f $mUpLeg`));
			}
			if (abRTCheckJointOrient($aJnts, "leg") == 0){
				print "The leg joint rotations were zeroed out.  You can rig now.";
				return;
			}
			
			$result = abRTRigLeg($upLeg, $heelLoc);
			
			if ($result == true && $autoMirror){
				// rig mirror
				if ($mUpLeg != "" && $mHeelLoc != ""){
					abRTRigLeg($mUpLeg, $mHeelLoc);
				}
			}
			abRTRRPopulateScrollList();
		}else{
			warning "All fields must be filled.";
		}
		
		break;
		
		case "createSpine": 
		
		string $spineRoot = abRTGetFromUI("spineRoot");
		string $hip = abRTGetFromUI("hip");
		
		if ($spineRoot != "" && $hip != ""){
			abRTRigSpine($spineRoot, $hip);
			abRTRRPopulateScrollList();
		}else{
			warning "All fields must be filled.";
		}
		
		
		break;
		
		case "createHead": 
		
		string $neck = abRTGetFromUI("neck");
		string $head = abRTGetFromUI("head");
		
		if ($neck != "" && $head != ""){
			abRTRigHead($neck, $head);
			abRTRRPopulateScrollList();
		}else{
			warning "All fields must be filled.";
		}
		
		break;
		
		case "createArm": 
		
		string $upArm = abRTGetFromUI("upArm");
		
		if ($upArm != ""){
			
			string $mUpArm = abRTGetMirrorObj($upArm);
			
			// check arm joint rotation
			$aJnts = `listRelatives -ad -type joint -f $upArm`;
			$aJnts = stringArrayCatenate({$upArm}, $aJnts);
			if ($autoMirror && $mUpArm != ""){
				$aJnts = stringArrayCatenate($aJnts,{$mUpArm});
				$aJnts = stringArrayCatenate($aJnts,(`listRelatives -ad -type joint -f $mUpArm`));
			}
			if (abRTCheckJointOrient($aJnts, "arm") == 0){
				print "The arm joint rotations were zeroed out.  You can rig now.";
				return;
			}
			
			$result = abRTRigArm($upArm);
			
			if ($result == true && $autoMirror){
				// rig mirror
				if ($mUpArm != ""){
					abRTRigArm($mUpArm);
				}
			}
			abRTRRPopulateScrollList();
			abRTGuessUIItems(); // used to capture hand ctrl curve
		}else{
			warning "All fields must be filled.";
		}
		
		break;
		
		case "createHand": 
		
		string $handCtrl = abRTGetFromUI("handCtrl");
		string $thumb = abRTGetFromUI("thumb");
		string $index = abRTGetFromUI("index");
		string $middle = abRTGetFromUI("middle");
		string $ring = abRTGetFromUI("ring");
		string $pinky = abRTGetFromUI("pinky");
		string $pinkyCup = abRTGetFromUI("pinkyCup");
		string $ringCup = abRTGetFromUI("ringCup");
		
		if ($handCtrl != "" && $thumb != "" && $index != ""){
			$result = abRTRigHand($handCtrl, $thumb, $index, $middle, $ring, $pinky, $pinkyCup, $ringCup);
			
			if ($result == true && $autoMirror){
				// rig mirror
				$handCtrl = abRTGetMirrorObj($handCtrl);
				$thumb = abRTGetMirrorObj($thumb);
				$index = abRTGetMirrorObj($index);
				$middle = abRTGetMirrorObj($middle);
				$ring = abRTGetMirrorObj($ring);
				$pinky = abRTGetMirrorObj($pinky);
				$pinkyCup = abRTGetMirrorObj($pinkyCup);
				$ringCup = abRTGetMirrorObj($ringCup);
				
				if ($handCtrl != "" && $thumb != "" && $index != ""){
					abRTRigHand($handCtrl, $thumb, $index, $middle, $ring, $pinky, $pinkyCup, $ringCup);
				}
			}
			abRTRRPopulateScrollList();
		}else{
			warning "You need to specify a hand ctrl and thumb and index joints.";
		}
		
		break;
		
		case "handQuickSel": 
		
		string $aSel[] = `ls -sl`;
		
		if (size($aSel) > 0){
			string $aHandUiNames[] = {"thumb","index","middle","ring","pinky","pinkyCup","ringCup"};
			string $aRel[] = `listRelatives -type shape $aSel[0]`;
			if (size($aRel) > 0 && `nodeType $aRel[0]` == "nurbsCurve"){
				
				abRTSetUITxtFld("handCtrl", $aSel[0]);
				
				if (abRTGetObjSide($aSel[0]) == "l") abRTSetUITxtFld("lfHandCtrl", $aSel[0]);
				else abRTSetUITxtFld("rtHandCtrl", $aSel[0]);
				
				int $i;
				int $ok = true;
				int $entryNum = min((size($aSel)), (size($aHandUiNames)+1));
				
				for ($i=1;$i<$entryNum;$i++){
					if (`nodeType $aSel[$i]` != "joint"){
						$ok = false;
						break;
					}else{
						abRTSetUITxtFld(($aHandUiNames[($i-1)]), $aSel[$i]);
					}
				}
				
				if (!$ok) warning "All but the first selected item must be joints.";
				
			}else{
				warning "The first selection must be a nurbsCurve.";
			}
		}
		
		break;
		
	}
}


global proc abRTServiceNameFld(){
	// ensures that the name field is correctly filled
	
	string $aStr[], $newName;
	string $name = `textFieldGrp -q -text abRTNameTxFldGrp`;
	string $origName = $name;
	
	if (isValidObjectName($name)){
		
		do {
			$newName = $name;
			$name = substitute("lf", $name, "lph");
			
		} while ($newName != $name);
		
		do {
			$newName = $name;
			$name = substitute("rt", $name, "ht");
			
		} while ($newName != $name);
		
		if ($origName != $name){
			confirmDialog -title "Confirm" -message "The character name was changed because it contained\n the default left (\"lf\") or right (\"rt\") naming prefix." -button "OK";
			
			textFieldGrp -e -text $name abRTNameTxFldGrp;
		}
		
		abRTSetGlobal("name",$name);
		
	}else{
		textFieldGrp -e -text (abRTGetGlobal("name")) abRTNameTxFldGrp;
	}
	
	// clear UI items
	abRTClearUIItems();
	
}


global proc abRTServiceNameFldPopUp(){
	// builds the popup menu on the character name field
	
	string $aRootJnts[], $rootJnt, $aCharNames[], $char;
	
	$aRootJnts = `ls -type joint "*_spine_low_jnt"`;
	
	popupMenu -e -deleteAllItems abRTCharNamePopUpMn;
	
	if (size($aRootJnts) > 0){
		
		// extract names from rootJnt node names
		for ($rootJnt in $aRootJnts)
			$aCharNames[size($aCharNames)] = substitute("_spine_low_jnt", $rootJnt, "");
		
		for ($char in $aCharNames)
			menuItem -l $char -c ("textFieldGrp -e -text "+$char+" abRTNameTxFldGrp;abRTServiceNameFld();") -p abRTCharNamePopUpMn;
		
	}else{
		menuItem -l "No Characters Found" -en false -p abRTCharNamePopUpMn;
	}
}


global proc int[] testHardness3degree(string $shape){
	// found here: http://www.highend3d.com/boards/index.php?showtopic=212778&pid=213300&mode=threaded&start=#entry213300 and modified
	
	int $aHard[], $knot;
	int $hit = 0;
	int $last = -1;
	float $flt;
	
	string $info = `createNode curveInfo`;
	
	connectAttr -f ($shape+".worldSpace[0]") ($info+".inputCurve");
	
	int $num = `getAttr -s ($info+".kn")`;
	float $aKnots[] = `getAttr ($info+".kn[0:"+($num-1)+"]")`;
	
	for ($flt in $aKnots){
		
		$knot = int($flt);
		
		if ($knot == $last){
			$hit++;
		}else{
			if ($hit > 1){
				$aHard[size($aHard)] = $last;
				$hit = 0;
			}
		}
		
		$last = $knot;
	}
	
	delete $info;
	
	if ($hit > 1) $aHard[size($aHard)] = ($knot);
	
	return $aHard;
	
}


global proc string[] re_getCurvePointInfo(string $curve, int $retWS){
	// I found this proc online at http://ryane.com and modified it
	// if $retWS == true, it returns worldSpace coordinates.  Otherwise it returns them in objectSpace.
	// returns {curveCmd, hardnessCmd}
	
	string $aRel[], $hardnessCmd;
	float $loc[];
	int $aHardCvs[], $int;
	int $degree = `getAttr ($curve+".degree")`;
	
	string $curveReplaceStr = "#curve#";
	
	select ($curve+".cv[*]");
	string $allPoints[] = `filterExpand -ex true -sm 28`;
	
	string $curveStart = ("curve -d "+$degree);
	
	// get hard knots (need curve shape first)
	if ($degree == 3){
		$aRel = `listRelatives -c -type shape $curve`;
		if (size($aRel) == 1)
			$aHardCvs = testHardness3degree($aRel[0]);
	}
	
	for ($i=0;$i<size($allPoints);$i++){
		$loc = ($retWS) ? `xform -q -ws -t $allPoints[$i]` : `xform -q -os -t $allPoints[$i]`;
		$curveStart += (" -p "+ $loc[0]+ " "+ $loc[1]+ " "+ $loc[2]);
	}
	
	// add hardness
	if (size($aHardCvs) > 0){
		
		$hardnessCmd = "hardenPointCurve -ch 1 -rpo 1 -m 1";
		
		for ($int in $aHardCvs)
			$hardnessCmd += " "+$curveReplaceStr+".cv["+$int+"]";
		
		//$hardnessCmd += ";";
	}

	return {$curveStart, $hardnessCmd};
}


global proc gmDeleteConnection(string $destName){
	// found here: http://forums.cgsociety.org/archive/index.php/t-53862.html. Taken from built in function
	// If the specified name is the destination of a connection,
	// then delete that connection.
	
	if ( `connectionInfo -isDestination $destName` ){
		string $destination = `connectionInfo -getExactDestination $destName`;
		// When deleting a src connection from a character, you must remove
		// the item from the character set or the character will no longer
		// work consistently: bug 127212
		string $srcConn[] = `listConnections -s 1 -d 0 -type character $destination`;
		if (size($srcConn)) {
			string $warnMsg = ("Removed \'"+$destination+"\' from character \'"+$srcConn[0]+"\'.");
			warning($warnMsg);
			character -e -rm $srcConn[0] $destination;
		}
		
		// delete -icn doesn't work if destination attr is readOnly
		// so use disconnectAttr in this case
		string $sArr[1] = `ls -ro $destination`;
		if (size($sArr)) {
			string $src = `connectionInfo -sourceFromDestination $destination`;
			disconnectAttr $src $destination;
		}else{
			delete -icn $destination;
		}
	}
}


global proc abRTCheckSoftMod(int $warn){
	// if softmod is enabled this proc disables it and issues a warning if $warn
	
	int $warning = false;
	
	if (exists("softSelect")){
		if (`softSelect -q -softSelectEnabled`){
			softSelect -softSelectEnabled false;
			$warning = true;
		}
	}
	
	if (`currentCtx` == "softModContext"){
		setToolTo moveSuperContext;
		$warning = true;
	}
	
	if ($warning && $warn) warning "This script doesn't work with sofMod of any kind.  Soft selection has been disabled and the current context has been switched to move.  Let us not discuss this again";
}


global proc abAutoRig(){
	// make main rig tool ui
	
	global int $abRTInit;
	
	if ($abRTInit != true)
		abRTInit();
	
	int $premiumVersion = int(abRTGetGlobal("premiumVersion"));
	string $vNum = abRTGetGlobal("versionNum");
	string $versionName = ($premiumVersion == true) ? "Premium" : "Standard";
	string $str;
	
	abRTCheckSoftMod(true);
	
	if (`window -exists abRTWin`)
		deleteUI -window abRTWin;
	
	window -t ("abAutoRig "+$versionName+" "+$vNum) -w 354 -h 394 -menuBar true -minimizeButton false -maximizeButton false abRTWin;
	
	int $autoMirror = int(abRTGetGlobal("autoMirror"));
	
	menu -label "Options" -postMenuCommand "" abRTOptionsOpMn;
	
	menuItem -label "Auto Mirror" -checkBox $autoMirror -command "abRTToggleMenuItem(\"abRTAutoMirMnIt\", \"autoMirror\");" abRTAutoMirMnIt;
	
	menuItem -divider true -p abRTOptionsOpMn;
	
	menuItem -label "Hand Options" -sm true abRTHandOptionsMnIt;
	
	$str = abRTGetGlobal("thumbCurlSpreadRoll");
	
	menuItem -label "Thumb Curl Spread Roll Axes" -p abRTHandOptionsMnIt -sm true abRTThumbCurlSpreadRollMnIt;
	radioMenuItemCollection;
	menuItem -l "xyz" -rb ($str == "xyz") -c ("abRTSetGlobal(\"thumbCurlSpreadRoll\",\"xyz\");") -p abRTThumbCurlSpreadRollMnIt;
	menuItem -l "yzx" -rb ($str == "yzx") -c ("abRTSetGlobal(\"thumbCurlSpreadRoll\",\"yzx\");") -p abRTThumbCurlSpreadRollMnIt;
	menuItem -l "zxy" -rb ($str == "zxy") -c ("abRTSetGlobal(\"thumbCurlSpreadRoll\",\"zxy\");") -p abRTThumbCurlSpreadRollMnIt;
	menuItem -l "xzy" -rb ($str == "xzy") -c ("abRTSetGlobal(\"thumbCurlSpreadRoll\",\"xzy\");") -p abRTThumbCurlSpreadRollMnIt;
	menuItem -l "yxz" -rb ($str == "yxz") -c ("abRTSetGlobal(\"thumbCurlSpreadRoll\",\"yxz\");") -p abRTThumbCurlSpreadRollMnIt;
	menuItem -l "zyx" -rb ($str == "zyx") -c ("abRTSetGlobal(\"thumbCurlSpreadRoll\",\"zyx\");") -p abRTThumbCurlSpreadRollMnIt;
	
	setParent ..;
	
	$str = abRTGetGlobal("fingerCurlSpreadRoll");
	
	menuItem -label "Finger Curl Spread Roll Axes" -p abRTHandOptionsMnIt -sm true abRTFingerCurlSpreadRollMnIt;
	radioMenuItemCollection;
	menuItem -l "xyz" -rb ($str == "xyz") -c ("abRTSetGlobal(\"fingerCurlSpreadRoll\",\"xyz\");") -p abRTFingerCurlSpreadRollMnIt;
	menuItem -l "yzx" -rb ($str == "yzx") -c ("abRTSetGlobal(\"fingerCurlSpreadRoll\",\"yzx\");") -p abRTFingerCurlSpreadRollMnIt;
	menuItem -l "zxy" -rb ($str == "zxy") -c ("abRTSetGlobal(\"fingerCurlSpreadRoll\",\"zxy\");") -p abRTFingerCurlSpreadRollMnIt;
	menuItem -l "xzy" -rb ($str == "xzy") -c ("abRTSetGlobal(\"fingerCurlSpreadRoll\",\"xzy\");") -p abRTFingerCurlSpreadRollMnIt;
	menuItem -l "yxz" -rb ($str == "yxz") -c ("abRTSetGlobal(\"fingerCurlSpreadRoll\",\"yxz\");") -p abRTFingerCurlSpreadRollMnIt;
	menuItem -l "zyx" -rb ($str == "zyx") -c ("abRTSetGlobal(\"fingerCurlSpreadRoll\",\"zyx\");") -p abRTFingerCurlSpreadRollMnIt;
	
	setParent ..;
	
	$str = abRTGetGlobal("fingerCupAxis");
	
	menuItem -label "Finger Cup Axis" -p abRTHandOptionsMnIt -sm true abRTFingerCupAxisMnIt;
	radioMenuItemCollection;
	menuItem -l "x" -rb ($str == "x") -c ("abRTSetGlobal(\"fingerCupAxis\",\"x\");") -p abRTFingerCupAxisMnIt;
	menuItem -l "y" -rb ($str == "y") -c ("abRTSetGlobal(\"fingerCupAxis\",\"y\");") -p abRTFingerCupAxisMnIt;
	menuItem -l "z" -rb ($str == "z") -c ("abRTSetGlobal(\"fingerCupAxis\",\"z\");") -p abRTFingerCupAxisMnIt;
	
	setParent ..;
	
	menuItem -divider true -p abRTHandOptionsMnIt;
	menuItem -l "Reverse Right Curl" -cb (int(abRTGetGlobal("reverseFingerCurl"))) -c ("abRTSetGlobal(\"reverseFingerCurl\",(1-int(abRTGetGlobal(\"reverseFingerCurl\"))));") -p abRTHandOptionsMnIt abRTReverseFingerCurlMnIt;
	
	setParent ..;
	
	menuItem -divider true -p abRTOptionsOpMn;
	menuItem -label "Refresh UI" -ann "Update the UI with values for the currently selected character, specified by the Char Name field in the \"Start\" tab." -command "abRTCheckUIItems(\"\");abRTGuessUIItems();tabLayout -e -selectTabIndex (`tabLayout -q -selectTabIndex abRTTabLayout`) abRTTabLayout;" -p abRTOptionsOpMn;
	
	
	menu -label "Tools" -postMenuCommand "abRTCheckSoftMod(false);";
	menuItem -label "Select All Character Controls" -ann "Select all of the control curves for a character.  Select any one of your character control curves first." -command "abRTSelectAllCharControls();";
	menuItem -divider true;
	menuItem -label "Skeleton Maker" -ann "Create a skeleton." -command "abRTSkeletonMaker();";
	menuItem -label "Rig Remover" -command "abRTRigRemover();";
	
	menuItem -divider true;
	menuItem -label "Weight Joint Selector" -ann "A UI to help select the joints on your skeleton to which you can bind your character mesh." -command "abRTSelWeightJntsUI();";
	menuItem -label "Split Joint Weight Tool" -ann "A UI to help quickly set the twist contributions of multiple upLimb split joints by specifying the first and last joint twist amounts.  Select a character control curve first." -command "abRTSplitJointWeighterUI();";
	menuItem -divider true;
	
	menuItem -divider true;
	menuItem -label "Joint Orient Rotation Tool" -ann "Simple joint orient tool for rotating LRAs in 90 degree increments." -command "abRTRotateOrientUI();";
	menuItem -label "Change Rotation Order Tool" -ann "Change the rotation order of controls that have already been animated." -command "abRTChangeRotOrderWindow();";
	menuItem -divider true;
	menuItem -label "Stretchy Spline From Curve" -ann "Add a stretchy spline to your character." -command "abRTMakeStretchySplineWin();";
	menuItem -divider true;
	menuItem -label "Wire Replacer" -ann "Save your rig control curve shapes and colors to a shelf button.  Select a character control curve first." -command "abRTWireReplaceUI();";
	
	menuItem -label "Save Wires To Shelf" -ann "Save your modified wires to a shelf button for later recall.  Select any one of your character control curves first." -command "abRTCaptureControlCurves();";
	menuItem -divider true;
	menuItem -label "Quick Create Character Set" -ann "Creates a character set for all of your character's animatable attributes.  Select any one of your character control curves first." -command "abRTMakeCharSetFromSel();";
	menuItem -label "Make abxPicker Character Sheet" -ann "Creates a node for use with the abxPicker script.  Select any one of your character control curves first." -command "abRTMakeAbxPickerUI();";
	menuItem -divider true;
	menuItem -label "Show IK/FK Snap UI" -ann "Displays a simple UI that allows you to snap to FK or IK on limbs associated with the selected controls.  Hold Ctrl(Command)+Shift and click this menu item to create a shelf button." -command "abRTMakeFKIKSnapBn(false);";
	menuItem -label "Show IK/FK Toggle UI" -ann "Displays a simple UI that allows you to toggle between IK and FK on limbs associated with the selected controls.  Hold Ctrl(Command)+Shift and click this menu item to create a shelf button." -command "abRTMakeFKIKSnapBn(true);";
	menuItem -divider true;
	menuItem -label "Unstickify IK Limb" -ann "For use on IK limbs that lock before solving all the way (sometimes the result of re-rigging with a different number of split joints).  Select a control curve on the selected limb and click this menu item.  You can also click the this menu item with nothing selected to unstickify all of the IK limbs in the current scene." -command "abRTUnStickifyIKLimb();";
	menuItem -divider true;
	
	menuItem -label "Space Switch Matcher" -ann "Match the position of controls between space switches." -command "abRTSpaceSwitchWindow();";
	menuItem -divider true;
	
	menuItem -label "Reset Character to Default Pose" -ann "Reset a character to its default pose.  Select any one of your character control curves first." -command "abRTResetCharPose(1);";
	menuItem -label "Reset Selected Control Curves to Default" -ann "Reset selected control curves to their default pose.  Highlight entries in the ChannelBox to revert selected attributes." -command "abRTResetCharPose(0);";
	
	menu -label "Help" -postMenuCommand "";
	menuItem -label "Online Help" -command "showHelp -a \"http://www.supercrumbly.com/archive/post/abAutoRig_II\"";
	menuItem -divider true;
	menuItem -label "Check For Updates" -command ("showHelp -a \"http://www.supercrumbly.com/updatecheck.php?script=abAutoRig_II&userver="+$vNum+"&prem="+abRTGetGlobal("premiumVersion")+"\"");
	
	int $lmargin = 3;
	int $rmargin = 3;
	int $lCol = 70;
	int $lSliderCol = 130;
	int $rSliderCol = $lmargin;
	int $cCol = 100;
	int $rCol = 60;
	
	formLayout -numberOfDivisions 100 abRTForm;
	
	tabLayout -innerMarginWidth 0 -innerMarginHeight 0 abRTTabLayout;
	
	// start form
	formLayout -numberOfDivisions $cCol abRTStartTabForm;
	textFieldGrp -label "Char Name:" -text (abRTGetGlobal("name")) -columnWidth2 $lCol $cCol -adjustableColumn2 2 -cc "abRTServiceNameFld();" abRTNameTxFldGrp;
	popupMenu -button 3 -postMenuCommand "abRTServiceNameFldPopUp();" -p abRTNameTxFldGrp abRTCharNamePopUpMn;
	
	textFieldButtonGrp -ed false -manage false -label "Master Scale Jnt:" -text "" abRTMasterScaleJntTxFldBnGrp; // used to determine if masterscale has been set for a skeleton
	
	button -label "Create a Skeleton" -h 28 -c "abRTClearUIItems();abRTSkeletonMaker();" abRTCreateSkeletonBn;
	
	
	// spine form
	setParent ..;
	string $name = abRTGetGlobal("name");
	formLayout -numberOfDivisions $cCol abRTSpineTabForm;
	intSliderGrp -label "Spine Joints:" -min 4 -max 18 -v (int(abRTGetGlobal("spineJntNum"))) -cc "abRTSetGlobal(\"spineJntNum\", `intSliderGrp -q -v abRTSpineJntsIntSldrGrp`);" -field true -columnWidth3 $lSliderCol 40 100 -adjustableColumn3 3 -ann "Select the number of joints you want on the ik spine." abRTSpineJntsIntSldrGrp;
	
	textFieldButtonGrp -ed false -label "Spine Root:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"spineRoot\");" -ann "Select the root spine joint." abRTSpineRootTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Hip:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"hip\");" -ann "Select the hip joint." abRTHipTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Root Ctrl:" -text "" abRTRootCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Hip Ctrl:" -text "" abRTHipCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Cog Ctrl:" -text "" abRTCogCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Low Spine Ctrl:" -text "" abRTLowSpineCtrlTxFldBnGrp;
	
	textFieldButtonGrp -ed false -manage false -label "Mid Spine 1 Ctrl:" -text "" abRTMidSpineCtrl_1TxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Mid Spine 2 Ctrl:" -text "" abRTMidSpineCtrl_2TxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Mid Spine 3 Ctrl:" -text "" abRTMidSpineCtrl_3TxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Mid Spine 4 Ctrl:" -text "" abRTMidSpineCtrl_4TxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Mid Spine 5 Ctrl:" -text "" abRTMidSpineCtrl_5TxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Mid Spine 6 Ctrl:" -text "" abRTMidSpineCtrl_6TxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Mid Spine 7 Ctrl:" -text "" abRTMidSpineCtrl_7TxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Mid Spine 8 Ctrl:" -text "" abRTMidSpineCtrl_8TxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Mid Spine 9 Ctrl:" -text "" abRTMidSpineCtrl_9TxFldBnGrp;
	
	textFieldButtonGrp -ed false -manage false -label "Hi Spine Ctrl:" -text "" abRTHiSpineCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Master Spine Ctrl:" -text "" abRTMasterSpineCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Rig Settings Ctrl:" -text "" abRTRigSettingsCtrlTxFldBnGrp;
	checkBox -label "Align Control Curves to Spine" -value (int(abRTGetGlobal("alignCtrlCrvsToSpine"))) -cc "abRTSetGlobal(\"alignCtrlCrvsToSpine\",1-(int(abRTGetGlobal(\"alignCtrlCrvsToSpine\"))));" -ann "If enabled, the mid and high spine control curves will be oriented to their respective spine joints; otherwise they'll lie on the XZ plane." abRTOrientSpineCtrlsChkBx;
	
	button -label "Create Spine Rig" -h 28 -c "abRTServiceUIButton(\"createSpine\");" abRTCreateSpineBn;
	
	// head form
	setParent ..;
	formLayout -numberOfDivisions $cCol abRTHeadTabForm;
	textFieldButtonGrp -ed false -label "Neck:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"neck\");" -ann "Select a neck joint." abRTNeckTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Head:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"head\");" -ann "Select the head joint." abRTHeadTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Eye:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"eye\");" -ann "Select an eye joint." abRTEyeTxFldBnGrp;
	checkBox -label "Hide Translate on Head/Neck Controls" -value (1-(int(abRTGetGlobal("includeHeadNeckTransAtts")))) -cc "abRTSetGlobal(\"includeHeadNeckTransAtts\",(1-(int(abRTGetGlobal(\"includeHeadNeckTransAtts\")))));" -ann "The actual rig will be unaffected, but the translate and FK channels on the head and neck controls will be locked and hidden." abRTIncludeHeadNeckTransAttsChkBx;
	
	textFieldButtonGrp -ed false -manage false -label "Neck_1:" -text "" abRTNeck_1TxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Neck_2:" -text "" abRTNeck_2TxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Neck_3:" -text "" abRTNeck_3TxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Neck_4:" -text "" abRTNeck_4TxFldBnGrp;
	
	textFieldButtonGrp -ed false -manage false -label "Neck_1 Ctrl:" -text "" abRTNeck_1_CtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Neck_2 Ctrl:" -text "" abRTNeck_2_CtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Neck_3 Ctrl:" -text "" abRTNeck_3_CtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Neck_4 Ctrl:" -text "" abRTNeck_4_CtrlTxFldBnGrp;
	
	textFieldButtonGrp -ed false -manage false -eb false -label "Neck Ctrl:" -text "" abRTNeckCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -eb false -label "Head Ctrl:" -text "" abRTHeadCtrlTxFldBnGrp;
	
	textFieldButtonGrp -ed false -manage false -label "Jaw:" -text "" abRTJawTxFldBnGrp;
	
	// head s&s button
	button -label "Create Head Rig" -h 28 -c "abRTServiceUIButton(\"createHead\");" abRTCreateHeadBn;
	
	
	// leg form
	setParent ..;
	formLayout -numberOfDivisions $cCol abRTLegTabForm;
	textFieldButtonGrp -ed false -label "UpLeg:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"upLeg\");" abRTUpLegTxFldBnGrp;
	intSliderGrp -label "UpLeg Split Joints:" -min 0 -max 6 -v (int(abRTGetGlobal("upLegSplitNum"))) -cc "abRTSetGlobal(\"upLegSplitNum\",`intSliderGrp -q -v abRTUpLegSpltIntSldrGrp`);abRTServiceUIButton(\"legSplitJointSlider\");" -field true -columnWidth3 $lSliderCol 40 100 -adjustableColumn3 3 abRTUpLegSpltIntSldrGrp;
	intSliderGrp -label "LowerLeg Split Joints:" -min 0 -max 6 -v (int(abRTGetGlobal("lowLegSplitNum"))) -cc "abRTSetGlobal(\"lowLegSplitNum\",`intSliderGrp -q -v abRTLowLegSpltIntSldrGrp`);abRTServiceUIButton(\"legSplitJointSlider\");" -field true -columnWidth3 $lSliderCol 40 100 -adjustableColumn3 3 abRTLowLegSpltIntSldrGrp; 
	textFieldButtonGrp -ed false -label "Heel Loc:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"heelLoc\");" abRTHeelLocTxFldBnGrp;
	button -label " Create Heel Locator " -c "abRTMakeHeelLoc();" abRTcreateHeelLocBn;
	checkBox -label "Create Mirror Loc" -value 1 abRTCreateBothHeelLocChkBx;
	
	checkBox -label "Center Foot IK Control On Ankle" -value (int(abRTGetGlobal("footIKCtrlAtAnkle"))) -cc "abRTSetGlobal(\"footIKCtrlAtAnkle\",1-(int(abRTGetGlobal(\"footIKCtrlAtAnkle\"))));" -ann "If enabled, the foot IK control will rotate the foot around the ankle instead of the heel."  abRTFootIKCtrlAtAnkleChkBx;
	
	textFieldButtonGrp -ed false -manage false -eb false -label "LfLegIkCtrl:" -text "" abRTLfLegIkCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -eb false -label "RtLegIkCtrl:" -text "" abRTRtLegIkCtrlTxFldBnGrp;
	
	button -label "Create Leg Rig" -h 28 -c "abRTServiceUIButton(\"createLeg\");" abRTCreateLegBn;
	
	
	// arm form
	setParent ..;
	formLayout -numberOfDivisions $cCol abRTArmTabForm;
	textFieldButtonGrp -ed false -label "Up Arm:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"upArm\");" abRTUpArmTxFldBnGrp;
	intSliderGrp -label "UpArm Split Joints:" -min 0 -max 6 -v (int(abRTGetGlobal("upArmSplitNum"))) -cc "abRTSetGlobal(\"upArmSplitNum\",`intSliderGrp -q -v abRTUpArmSpltIntSldrGrp`);abRTServiceUIButton(\"armSplitJointSlider\");" -field true -columnWidth3 $lSliderCol 40 100 -adjustableColumn3 3 abRTUpArmSpltIntSldrGrp;
	intSliderGrp -label "ForeArm Split Joints:" -min 0 -max 6 -v (int(abRTGetGlobal("foreArmSplitNum"))) -cc "abRTSetGlobal(\"foreArmSplitNum\",`intSliderGrp -q -v abRTForeArmSpltIntSldrGrp`);abRTServiceUIButton(\"armSplitJointSlider\");" -field true -columnWidth3 $lSliderCol 40 100 -adjustableColumn3 3 abRTForeArmSpltIntSldrGrp; 
	checkBox -label "Align Hand IK to World Axes" -value (int(abRTGetGlobal("alignHandIkToWorld"))) -cc "abRTSetGlobal(\"alignHandIkToWorld\",1-(int(abRTGetGlobal(\"alignHandIkToWorld\"))));" -ann "If enabled, the IK control will be aligned to the world axes."  abRTAlignHandIKChkBx;
	
	textFieldButtonGrp -ed false -manage false -eb false -label "LfArmIkCtrl:" -text "" abRTLfArmIkCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -eb false -label "RtArmIkCtrl:" -text "" abRTRtArmIkCtrlTxFldBnGrp;
	
	button -label "Create Arm Rig" -h 28 -c "abRTServiceUIButton(\"createArm\");" abRTcreateArmBn;
	
	
	// hand form
	setParent ..;
	formLayout -numberOfDivisions $cCol abRTHandTabForm;
	textFieldButtonGrp -ed false -label "Hand Ctrl:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"handCtrl\");" -ann "Select the hand control (must be a nurbs curve)." abRTHandCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Thumb:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"thumb\");" -ann "Select the first thumb joint (optional)." abRTThumbTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Index:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"index\");" -ann "Select the first index finger joint (optional)." abRTIndexTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Middle:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"middle\");" -ann "Select the middle finger joint (optional)." abRTMiddleTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Ring:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"ring\");" -ann "Select the first ring finger joint (optional)." abRTRingTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Pinky:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"pinky\");" -ann "Select the first pinky finger joint (optional)." abRTPinkyTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Ring Cup:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"ringCup\");" -ann "Select the ring cup joint (optional)." abRTRingCupTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Pinky Cup:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"pinkyCup\");" -ann "Select the first pinky cup joint (optional)." abRTPinkyCupTxFldBnGrp;
	button -label " Hand Quick Select " -c "abRTServiceUIButton(\"handQuickSel\");" -ann "Select controls in order that the fields on this tab are listed and press this button to fill them." abRTHandQuickSelBn;
	
	textFieldButtonGrp -ed false -manage false -eb false -label "LfHandCtrl:" -text "" abRTLfHandCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -eb false -label "RtHandCtrl:" -text "" abRTRtHandCtrlTxFldBnGrp;
	
	checkBox -label "Create Ik Finger Controls" -value (int(abRTGetGlobal("createIkFingerCtrls"))) -cc "abRTSetGlobal(\"createIkFingerCtrls\",1-(int(abRTGetGlobal(\"createIkFingerCtrls\"))));" abRTCreateIkFingerChkBx;
	
	button -label "Create Hand Rig" -h 28 -c "abRTServiceUIButton(\"createHand\");" abRTcreateHandBn;
	
	
	formLayout -edit
	
	-af abRTTabLayout "top" 0
	-af abRTTabLayout "left" 0
	-af abRTTabLayout "right" 0
	-af abRTTabLayout "bottom" 0
	
	abRTForm
	;
	
	
	// start tab
	formLayout -edit
	
	-af abRTNameTxFldGrp "top" 14
	-af abRTNameTxFldGrp "left" $lmargin
	-af abRTNameTxFldGrp "right" ($rCol+$rmargin)
	
	-af abRTCreateSkeletonBn "bottom" 2
	-af abRTCreateSkeletonBn "left" 2
	-af abRTCreateSkeletonBn "right" 2
	
	abRTStartTabForm
	;
	
	
	// spine tab (without spine shaper checkbox)
	formLayout -edit
	
	-af abRTSpineJntsIntSldrGrp "top" 14
	-af abRTSpineJntsIntSldrGrp "left" $lmargin
	-af abRTSpineJntsIntSldrGrp "right" $rSliderCol
	
	-ac abRTSpineRootTxFldBnGrp "top" 4 abRTSpineJntsIntSldrGrp
	-af abRTSpineRootTxFldBnGrp "left" $lmargin
	-af abRTSpineRootTxFldBnGrp "right" $rmargin
	
	-ac abRTHipTxFldBnGrp "top" 4 abRTSpineRootTxFldBnGrp
	-af abRTHipTxFldBnGrp "left" $lmargin
	-af abRTHipTxFldBnGrp "right" $rmargin
	
	-ac abRTOrientSpineCtrlsChkBx "top" 9 abRTHipTxFldBnGrp
	-af abRTOrientSpineCtrlsChkBx "left" (70+$lmargin)
	
	-af abRTCreateSpineBn "bottom" 2
	-af abRTCreateSpineBn "left" 2
	-af abRTCreateSpineBn "right" 2
	
	abRTSpineTabForm
	;
	
	
	// head/neck tab
	formLayout -edit
	
	-af abRTNeckTxFldBnGrp "top" 14
	-af abRTNeckTxFldBnGrp "left" $lmargin
	-af abRTNeckTxFldBnGrp "right" $rmargin
	
	-ac abRTHeadTxFldBnGrp "top" 4 abRTNeckTxFldBnGrp
	-af abRTHeadTxFldBnGrp "left" $lmargin
	-af abRTHeadTxFldBnGrp "right" $rmargin
	
	-ac abRTEyeTxFldBnGrp "top" 4 abRTHeadTxFldBnGrp
	-af abRTEyeTxFldBnGrp "left" $lmargin
	-af abRTEyeTxFldBnGrp "right" $rmargin
	
	-ac abRTIncludeHeadNeckTransAttsChkBx "top" 9 abRTEyeTxFldBnGrp
	-af abRTIncludeHeadNeckTransAttsChkBx "left" (70+$lmargin)
	
	-af abRTCreateHeadBn "bottom" 2
	-af abRTCreateHeadBn "left" 2
	-af abRTCreateHeadBn "right" 2
	
	abRTHeadTabForm
	;
	
	
	// leg tab
	formLayout -edit
	
	-af abRTUpLegTxFldBnGrp "top" 14
	-af abRTUpLegTxFldBnGrp "left" $lmargin
	-af abRTUpLegTxFldBnGrp "right" $rmargin
	
	-ac abRTUpLegSpltIntSldrGrp "top" 4 abRTUpLegTxFldBnGrp
	-af abRTUpLegSpltIntSldrGrp "left" $lmargin
	-af abRTUpLegSpltIntSldrGrp "right" $rSliderCol
	
	-ac abRTLowLegSpltIntSldrGrp "top" 4 abRTUpLegSpltIntSldrGrp
	-af abRTLowLegSpltIntSldrGrp "left" $lmargin
	-af abRTLowLegSpltIntSldrGrp "right" $rSliderCol
	
	-ac abRTHeelLocTxFldBnGrp "top" 4 abRTLowLegSpltIntSldrGrp
	-af abRTHeelLocTxFldBnGrp "left" $lmargin
	-af abRTHeelLocTxFldBnGrp "right" $rmargin
	
	-ac abRTcreateHeelLocBn "top" 6 abRTHeelLocTxFldBnGrp
	-af abRTcreateHeelLocBn "left" (70+$lmargin)
	
	-ac abRTCreateBothHeelLocChkBx "top" 9 abRTHeelLocTxFldBnGrp
	-ac abRTCreateBothHeelLocChkBx "left" 12 abRTcreateHeelLocBn
	
	-ac abRTFootIKCtrlAtAnkleChkBx "top" 9 abRTcreateHeelLocBn
	-af abRTFootIKCtrlAtAnkleChkBx "left" (70+$lmargin)
	
	-af abRTCreateLegBn "bottom" 2
	-af abRTCreateLegBn "left" 2
	-af abRTCreateLegBn "right" 2
	
	abRTLegTabForm
	;
	
	
	// arm tab
	formLayout -edit
	
	-af abRTUpArmTxFldBnGrp "top" 14
	-af abRTUpArmTxFldBnGrp "left" $lmargin
	-af abRTUpArmTxFldBnGrp "right" $rmargin
	
	-ac abRTUpArmSpltIntSldrGrp "top" 5 abRTUpArmTxFldBnGrp
	-af abRTUpArmSpltIntSldrGrp "left" $lmargin
	-af abRTUpArmSpltIntSldrGrp "right" $rSliderCol
	
	-ac abRTForeArmSpltIntSldrGrp "top" 5 abRTUpArmSpltIntSldrGrp
	-af abRTForeArmSpltIntSldrGrp "left" $lmargin
	-af abRTForeArmSpltIntSldrGrp "right" $rSliderCol
	
	-ac abRTAlignHandIKChkBx "top" 9 abRTForeArmSpltIntSldrGrp
	-af abRTAlignHandIKChkBx "left" (70+$lmargin)
	
	-af abRTcreateArmBn "bottom" 2
	-af abRTcreateArmBn "left" 2
	-af abRTcreateArmBn "right" 2
	
	abRTArmTabForm
	;
		
	
	// hand tab
	formLayout -edit
	
	-af abRTHandCtrlTxFldBnGrp "top" 14
	-af abRTHandCtrlTxFldBnGrp "left" $lmargin
	-af abRTHandCtrlTxFldBnGrp "right" $rmargin
	
	-ac abRTThumbTxFldBnGrp "top" 6 abRTHandCtrlTxFldBnGrp
	-af abRTThumbTxFldBnGrp "left" $lmargin
	-af abRTThumbTxFldBnGrp "right" $rmargin
	
	-ac abRTIndexTxFldBnGrp "top" 4 abRTThumbTxFldBnGrp
	-af abRTIndexTxFldBnGrp "left" $lmargin
	-af abRTIndexTxFldBnGrp "right" $rmargin
	
	-ac abRTMiddleTxFldBnGrp "top" 4 abRTIndexTxFldBnGrp
	-af abRTMiddleTxFldBnGrp "left" $lmargin
	-af abRTMiddleTxFldBnGrp "right" $rmargin
	
	-ac abRTRingTxFldBnGrp "top" 4 abRTMiddleTxFldBnGrp
	-af abRTRingTxFldBnGrp "left" $lmargin
	-af abRTRingTxFldBnGrp "right" $rmargin
	
	-ac abRTPinkyTxFldBnGrp "top" 4 abRTRingTxFldBnGrp
	-af abRTPinkyTxFldBnGrp "left" $lmargin
	-af abRTPinkyTxFldBnGrp "right" $rmargin
	
	-ac abRTPinkyCupTxFldBnGrp "top" 6 abRTPinkyTxFldBnGrp
	-af abRTPinkyCupTxFldBnGrp "left" $lmargin
	-af abRTPinkyCupTxFldBnGrp "right" $rmargin
	
	-ac abRTRingCupTxFldBnGrp "top" 4 abRTPinkyCupTxFldBnGrp
	-af abRTRingCupTxFldBnGrp "left" $lmargin
	-af abRTRingCupTxFldBnGrp "right" $rmargin
	
	-ac abRTHandQuickSelBn "top" 4 abRTRingCupTxFldBnGrp
	-af abRTHandQuickSelBn "left" ($lCol+$lmargin)
	
	-ac abRTCreateIkFingerChkBx "top" 6 abRTHandQuickSelBn
	-af abRTCreateIkFingerChkBx "left" ($lCol+$lmargin)
	
	-af abRTcreateHandBn "bottom" 2
	-af abRTcreateHandBn "left" 2
	-af abRTcreateHandBn "right" 2
	
	abRTHandTabForm
	;
	
	
	tabLayout -edit -tabLabel abRTStartTabForm "Start" -tabLabel abRTSpineTabForm "Spine" -tabLabel abRTHeadTabForm "Head/Neck" -tabLabel abRTLegTabForm "Legs/Feet" -tabLabel abRTArmTabForm "Arms" -tabLabel abRTHandTabForm "Hands" -preSelectCommand "abRTCheckUIItems(\"\");" abRTTabLayout;
	
	showWindow abRTWin;
	
	abRTGuessUIItems(); // update fields with existing ctrls
	
	// show shelf if it's hidden
	if (!`isUIComponentVisible "Shelf"`){
			toggleUIComponentVisibility "Shelf";
			warning "Enabling the shelf so the script will work.";
	}
}


global proc string abRTMakeHeelLoc(){
	// creates a loc to be positioned for heel joint when an upLeg joint has been selected in the UI
	// actually creates two locs -- one on each side of the character
	
	abRTCheckUIItems("");
	
	string $ret, $aRel[], $aAimCons[], $cons;
	float $aXform[];
	int $i;
	string $upLeg = abRTGetFromUI("upLeg");
	int $createMirror = `checkBox -q -value abRTCreateBothHeelLocChkBx`;
	
	if ($upLeg != ""){
		
		if (`objExists (abRTGetGlobal("deleteMeGrp"))`) delete (abRTGetGlobal("deleteMeGrp"));
		string $deleteMeGrp = abRTGetDeleteMeGrpName();
		
		// get leg joints (not splits)
		string $jnt;
		string $aJnts[] = {$upLeg};
		
		for ($i=0;$i<5;$i++){
			$jnt = abRTGetDownJoint($aJnts[$i]);
			if ($jnt != ""){
				$aJnts[size($aJnts)] = $jnt;
			}else{
				break;
			}
		}
		
		if (size($aJnts) < 5){
			warning "Your upLeg joint should be the first of a chain of no less than five joints.";
			return "";
		}
		
		$toe = $aJnts[size($aJnts)-1];
		$ball = $aJnts[size($aJnts)-2];
		$ankle = $aJnts[size($aJnts)-3];
		
		string $prefix = abRTGetObjSide($toe);
		string $newName = abRTRigNamer("heel", $prefix, "loc");
		string $heelLoc = abRTMakeLocator($newName);
		
		// snap loc to ankle
		abRTSnapToPosition($ankle, $heelLoc);
		
		// get ball xform (will use its Y)
		$aXform = `xform -q -ws -t $toe`;
		
		// move the heelLoc to the toe world Y
		select -r $heelLoc;
		move -a -ws -y $aXform[1];
		
		// and aim it at the ball
		$aAimCons = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 -1 0 -worldUpType "scene" $toe $heelLoc`;
		for ($cons in $aAimCons) delete $cons;
		
		string $heelFrzGrp = abRTGroupFreeze($heelLoc, 1);
		$heelLoc = $heelFrzGrp+$heelLoc;
		
		setAttr -lock true ($heelLoc+".tz");
		
		setAttr ($heelLoc+".rx") 180;
		setAttr ($heelLoc+".ry") -90;
		
		setAttr -lock true ($heelLoc+".rx");
		setAttr -lock true ($heelLoc+".ry");
		setAttr -lock true ($heelLoc+".rz");
		
		if ($createMirror && $prefix != ""){
			
			string $aDupObj[] = `duplicate -rr -rc -name (abRTSwapSidePrefix($heelFrzGrp)) $heelFrzGrp`;
			string $mHeelFrzGrp = $aDupObj[0];
			
			$aRel = `listRelatives -c -fullPath $mHeelFrzGrp`;
			if (size($aRel) == 1){
				string $aMName[] = abRTRename($aRel[0], (abRTSwapSidePrefix($newName)));
				string $mHeelLoc = $aMName[1];
				
				float $aXform3[] = `xform -q -ws -t $mHeelFrzGrp`;
				setAttr ($mHeelFrzGrp+".tx") (-$aXform3[0]);
				float $aXform4[] = `xform -q -ws -ro $mHeelFrzGrp`;
				setAttr ($mHeelFrzGrp+".rx") (-($aXform4[0]+180));
				setAttr ($mHeelFrzGrp+".rz") (-($aXform4[2]+180));
				
				abRTPointConnect($heelLoc, $mHeelLoc, 3);
				
				parent $mHeelFrzGrp $deleteMeGrp;
			}
		}
		
		parent $heelFrzGrp $deleteMeGrp;
		
		$ret = $heelLoc = $deleteMeGrp+"|"+$heelLoc;
		select -r $heelLoc;
		
		abRTServiceUI("heelLoc");
		
		
	}else{
		warning "You must select an upLeg joint before you can create a heel locator.";
	}
	
	return $ret;
}


global proc abRTSetScale(string $jnt){
	// sets global scale var based on size of entire skeleton -- $jnt can be any joint in skeleton below the rootJnt
	
	string $rootJnt = abRTGetRootFromJoint($jnt);
	
	if ($rootJnt == "") return;
	
	// if a masterScaleJnt has been specified and it's the same as the rootJnt, then the global scale var is accurate
	if ($rootJnt == abRTGetFromUI("masterScaleJnt")) return;
	
	string $tJnt;
	string $aJnts[] = `listRelatives -type joint -fullPath -ad $rootJnt`;
	float $aTrans[], $minY, $maxY;
	
	string $tLoc = abRTMakeLocator("abRTFindScaleLoc");
	
	// find highest and lowest joints (in Y) to determine height of skeleton
	
	$minY = $maxY = 0;
	for ($tJnt in $aJnts){
		
		abRTSnapToPosition($tJnt, $tLoc);
		
		$aTrans = `xform -q -ws -t $tLoc`;
		if ($aTrans[1] > $maxY) $maxY = $aTrans[1];
		else if ($aTrans[1] < $minY) $minY = $aTrans[1];
	}
	
	delete $tLoc;
	
	float $height = $maxY - $minY;
	float $avgHeight = float(abRTGetGlobal("avgHeight"));
	float $scale = $height/$avgHeight;
	string $scaleStr = string($scale);
	abRTSetGlobal("globalScale", $scaleStr);
	
	// fill the masterScaleJnt field to flag that scale has been determined for this jnt
	
	abRTSetUITxtFld("masterScaleJnt", $rootJnt);
	
}


global proc abRTMakeRootCon(string $jnt){
	/*
	$jnt should be the root joint of the skeleton
	creates a root control and determines the appropriate scale
	assume avg height of 175 -- units are assumed to be centimeters
	*/
	
	
	if ($jnt != "" && `objExists $jnt` && `nodeType $jnt` == "joint"){
		
		string $rigRtGrp = abRTRigRootFolder();
		
		string $ctrl = abRTMakeWireController("circle", 1, {}, 125);
		string $newName = abRTRigNamer("root", "", "ctrl");
		string $aName[] = abRTRename($ctrl, $newName);
		$ctrl = abRTParent($aName[1], $rigRtGrp);
		
		abRTColorObj($ctrl, "rootCtrlColor", -1);
		
		string $aPointCons[] = `pointConstraint -offset 0 0 0 -weight 1 $jnt $ctrl`;
		delete $aPointCons[0];
		setAttr ($ctrl+".ty") 0;
		makeIdentity -apply true -t 1 -r 1 -s 1 $ctrl;
		
		// add masterScale
		addAttr -ln "masterScale" -at double -dv 1 -keyable true -min .001 -max 10 $ctrl;
		
		// add skeleton vis att
		addAttr -ln "skeletonVis" -at bool -keyable true $ctrl;
		setAttr ($ctrl+".skeletonVis") true;
		connectAttr -f ($ctrl+".skeletonVis") ($jnt+".v");
		
		abRTSetUITxtFld("rootCtrl", $ctrl);
	}
}


global proc string abRTGetCharVarNode(){
	// returns or creates charVar node for a given character rootCon.  CharVar node contains info on the nodes created and associated with each part of the rigging process to allow easy removal of the rig.
	// charVar is a "geometryVarGroup" node with separate atts for spine, head/neck/eyes and lf and rt legs arms and hands;
	// Also holds version of script rig was created with
	// charVar is a child of the character_rig_grp
	// determines active character by nameField in UI.  If that's not consistent with name of rig group, then charVar won't be created correctly
	
	string $charName = abRTGetGlobal("name");
	
	if ($charName == ""){
		warning "Character Name is undefined.  Unable to save data to charVar node.";
		return "";
	}
	
	string $rigGrp = $charName+"_rig_grp";
	
	if (!`objExists $rigGrp` || `nodeType $rigGrp` != "transform"){
		warning ("The rig group \""+$rigGrp+"\" doesn't exist.  Unable to proceed.");
		return "";
	}
	
	string $aRel[] = `listRelatives -ad -type geometryVarGroup $rigGrp`;
	if (size($aRel) == 1){
		return $aRel[0];
	}else{
		// create the charVars node
		string $charVarNode = `createNode geometryVarGroup -n ($charName+"_charVars") -p $rigGrp`;
		addAttr -ln "versionNum" -at double $charVarNode;
		setAttr ($charVarNode+".versionNum") (float(abRTGetGlobal("versionNum")));
		return $charVarNode;
	}
	
}


global proc string abRTCreateNode(string $nodeType, string $baseName, string $prefix, string $limbName){
	// creates a node and records it to the character's charVars for easy rig removal
	// $nodeType is the type of node to create ("blendColors", "curveInfo", "plusMinusAverage", "multiplyDivide", "reverse", "condition", "clamp"
	// $baseName is baseName of node to be created, $prefix is "l","r", or "", and $cat is category att of charVars in which to record this node.
	// leave $limbName empty ("") to avoid it being recorded to charVars
	
	string $suffix, $cmd, $node;
	
	switch($nodeType){
		case "blendColors":$suffix="blnd";break;
		case "curveInfo":$suffix="crvInfo";break;
		case "plusMinusAverage":$suffix="plsMns";break;
		case "multiplyDivide":$suffix="mltDiv";break;
		case "reverse":$suffix="rvrs";break;
		case "condition":$suffix="cond";break;
		case "clamp":$suffix="clmp";break;
		case "blendWeighted":$suffix="bldWght";break;
	}
	
	$cmd = "createNode "+$nodeType+" -n (abRTRigNamer(\""+$baseName+"\", \""+$prefix+"\", \""+$suffix+"\"));";
	
	$node = eval($cmd);
	
	if ($limbName != "") abRTSaveToCharVars({$node}, $limbName);
	
	return $node;
	
}


global proc abRTSaveRigGrpToCharVars(string $rigGrp, string $limbName){
	// saves the rigGrp to charVars in the attribute $limbName+"RigGrp".  Used for rig removal
	
	string $charVarNode = abRTGetCharVarNode();
	
	$rigGrp = shortNameOf($rigGrp);
	
	if ($charVarNode != ""){
		string $attName = $limbName+"RigGrp";
		if (!attributeExists($attName, $charVarNode)) addAttr -ln $attName -dt "string" $charVarNode;
		setAttr -type "string" ($charVarNode+"."+$attName) $rigGrp;	
	}
	
}


global proc abRTSaveToCharVars(string $aNodes[], string $limbName){
	// Used for rig removal.
	// saves the joints to charVars in the attribute $limbName+"Jnts".
	// saves atts (nodeName.att) to charVars in the attribute $limbName+"Atts". 
	// saves transforms to charVars in att $limbName+"Trans"
	// saves other nodes to charVars in att $limbName+"Nodes"
	
	string $charVarNode = abRTGetCharVarNode();
	if ($charVarNode == "") return;
	
	// sort jnts into one array and atts and transforms into another
	string $aJnts[], $aAtts[], $aTrans[], $aOthers[], $node, $aStr[], $cVarAtt, $cAttVal, $arrayStr;
	
	for ($node in $aNodes){
		
		if ($node == "") continue;
		
		// determine whether this is an attribute
		$aStr = stringToStringArray($node, ".");
		if (size($aStr) == 2){
			// it's an att
			$aStr[0] = abRTStripPath($aStr[0]);
			if (attributeExists($aStr[1], $aStr[0])){
				$aAtts[size($aAtts)] = abRTStripPath($node);
				continue;
			}
		}
		
		// transforms
		if (`nodeType $node` == "transform" && `objExists $node`){
			$aTrans[size($aTrans)] = abRTStripPath($node);
			continue;
		}
		
		// joints
		if (`nodeType $node` == "joint" && `objExists $node`){
			$aJnts[size($aJnts)] = abRTStripPath($node);
			continue;
		}
		
		// capture others in $aOthers
		if (`objExists $node`){
			$aOthers[size($aOthers)] = abRTStripPath($node);
			continue;
		}
		
	}
	
	if (size($aAtts) > 0){
		
		$cVarAtt = $limbName+"Atts";
		$arrayStr = stringArrayToString($aAtts, ",");
		
		if (!attributeExists($cVarAtt, $charVarNode)) addAttr -ln $cVarAtt -dt "string" $charVarNode;
		
		$cAttVal = `getAttr ($charVarNode+"."+$cVarAtt)`;
		if (size($cAttVal) > 0) $arrayStr = $cAttVal+","+$arrayStr;
		
		setAttr -type "string" ($charVarNode+"."+$cVarAtt) $arrayStr;
		
	}
	if (size($aTrans) > 0){
		
		$cVarAtt = $limbName+"Trans";
		$arrayStr = stringArrayToString($aTrans, ",");
		
		if (!attributeExists($cVarAtt, $charVarNode)) addAttr -ln $cVarAtt -dt "string" $charVarNode;
		
		$cAttVal = `getAttr ($charVarNode+"."+$cVarAtt)`;
		if (size($cAttVal) > 0) $arrayStr = $cAttVal+","+$arrayStr;
		
		setAttr -type "string" ($charVarNode+"."+$cVarAtt) $arrayStr;
		
	}
	if (size($aJnts) > 0){
		
		$cVarAtt = $limbName+"Jnts";
		$arrayStr = stringArrayToString($aJnts, ",");
		
		if (!attributeExists($cVarAtt, $charVarNode)) addAttr -ln $cVarAtt -dt "string" $charVarNode;
		
		$cAttVal = `getAttr ($charVarNode+"."+$cVarAtt)`;
		if (size($cAttVal) > 0) $arrayStr = $cAttVal+","+$arrayStr;
		
		setAttr -type "string" ($charVarNode+"."+$cVarAtt) $arrayStr;
		
	}
	if (size($aOthers) > 0){
		
		$cVarAtt = $limbName+"Nodes";
		$arrayStr = stringArrayToString($aOthers, ",");
		
		if (!attributeExists($cVarAtt, $charVarNode)) addAttr -ln $cVarAtt -dt "string" $charVarNode;
		
		$cAttVal = `getAttr ($charVarNode+"."+$cVarAtt)`;
		if (size($cAttVal) > 0) $arrayStr = $cAttVal+","+$arrayStr;
		
		setAttr -type "string" ($charVarNode+"."+$cVarAtt) $arrayStr;
		
	}
	
}


global proc abRTReplaceWireController(string $curve, string $wireType, int $facingAxis, int $useScaleSlider, int $aUseInternalVars[]){
	// replaces existing control curve $curve, with a controller of the type $wireType (see abRTMakeWireController proc) and facing axis +x,+y,+z,-x,-y,-z (1,2,3,4,5,6)
	// if $useScaleSlider then size will be based on the position of the scale slider in the replaceWire UI.
	// $aUseInternalVars is array of 4 bools {useInternalWireType, $useInternalFacingAxis, $useInternalSize}; if size() < 4 but > 0, only the specified internal vars will be used, others will be ignored, so the main $wireType, $facingAxis, etc. must be specified.
	// internalSize is overridden by useScaleSlider
	
	float $tol = .00001;
	
	int $useInternalWireType, $useInternalFacingAxis, $useInternalSize;
	
	$useInternalWireType = $useInternalFacingAxis = $useInternalSize = false;
	
	if (size($aUseInternalVars) > 0)
		$useInternalWireType = $aUseInternalVars[0];
	if (size($aUseInternalVars) > 1)
		$useInternalFacingAxis = $aUseInternalVars[1];
	if (size($aUseInternalVars) > 1 && !$useScaleSlider)
		$useInternalSize = $aUseInternalVars[2];
	
	string $aRel[] = `listRelatives -c -type nurbsCurve $curve`;
	
	if (size($aRel) == 1){
		
		float $size, $globalScale, $scaleSlider;
		
		$globalScale = float(abRTGetGlobal("globalScale"));
		
		if (attributeExists("wireScale", $curve) && $useInternalSize){
			
			$size = `getAttr ($curve+".wireScale")`;
			$size *= $globalScale;
			
		}else{
			
			if ($useScaleSlider && `window -q -exists abRTWrRplcWin`){
				$scaleSlider = `floatField -q -v abRTWRScaleFltFld`;
				$size = $globalScale*$scaleSlider;
			}else{
				$size = abRTGetMaxDim($curve);
				$size = $size/$globalScale;
			}
		}
		
		if (attributeExists("wireType", $curve) && $useInternalWireType)
			$wireType = `getAttr ($curve+".wireType")`;
		
		if (attributeExists("wireFacingAxis", $curve) && $useInternalFacingAxis)
			$facingAxis = `getAttr ($curve+".wireFacingAxis")`;
		
		
		// get offset
		float $aBbox[], $aCenter[], $aParent[], $aTrans1[], $aTrans2[];
		string $parent, $tLoc1, $tLoc2, $tGrp;
		
		$aBbox = `xform -q -os -boundingBox $curve`;
		
		$parent = firstParentOf($curve);
		
		if ($parent != ""){
			
			$tGrp = `group -em -n "abRTReplaceWireController_tGrp"`;
			
			$tLoc1 = abRTMakeLocatorV2("abRTReplaceWireController_1_tLoc", "", $tGrp);
			$tLoc2 = abRTMakeLocatorV2("abRTReplaceWireController_2_tLoc", "", $tGrp);
			string $tLoc3 = abRTMakeLocatorV2("abRTReplaceWireController_3_tLoc", "", $tGrp);
			
			xform -ws -t $aBbox[0] $aBbox[1] $aBbox[2] $tLoc1;
			xform -ws -t $aBbox[3] $aBbox[4] $aBbox[5] $tLoc2;
			
			abRTSnapToPosition($parent, $tGrp);
			
			parentConstraint $tLoc1 $tLoc2 $tLoc3;
			
			$aCenter = `xform -q -ws -t $tLoc3`;
			
			delete $tGrp;
			
		}else{
			$aCenter = {($aBbox[0]+$aBbox[3])/2.0,($aBbox[1]+$aBbox[4])/2.0,($aBbox[2]+$aBbox[5])/2.0};
		}
		
		string $aStr[] = abRTGetWireControllerDirections($wireType, $facingAxis, $aCenter, $size, true);
		string $directions = $aStr[0];
		string $hardness = $aStr[1];
		
		
		// make it
		string $replaceCmd = `substitute "curve -d" $directions ("curve -r -ws -d")`;
		$replaceCmd += " "+$curve;
		eval ($replaceCmd);
		
		// now do hardness
		
		if ($hardness != ""){
			$hardness = substituteAllString($hardness, "#curve#", $curve);
			eval ($hardness);
		}
		
		// now add some hidden atts
		abRTSetWireAttributes($curve, {"wireScale", (string($size/$globalScale)), "wireType", $wireType, "wireFacingAxis", (string($facingAxis))});
		
	}else{
		warning "Select a curve.";
	}
	
}


global proc abRTMoveWireRelativeToPivot(string $curve, float $x, float $y, float $z, int $useWorldSpace){
	// moves curve relative to its pivot
	// $x, $y, and $z can be -1,0,1 based on whether you want to move the curve points min, center, max relative to the pivot in each dimension
	// can be greater or less than 1 and -1 respectively.  $x == -2 will move the wire two bBox widths -x beyond its pivot.
	// uses worldspace if $useWorldSpace == true, otherwise uses local space
	
	
	string $aRel[] = `listRelatives -c -type nurbsCurve $curve`;
	if (size($aRel) == 1){
		
		string $cNode = $aRel[0];
		float $aBbox[] = `xform -q -ws -boundingBox $curve`;
		
		float $aBboxDim[] = {$aBbox[3]-$aBbox[0], $aBbox[4]-$aBbox[1], $aBbox[5]-$aBbox[2]};
		float $aCenter[] = {($aBbox[0]+$aBbox[3])/2.0,($aBbox[1]+$aBbox[4])/2.0,($aBbox[2]+$aBbox[5])/2.0};
		
		float $aPivot[] = `xform -q -ws -rp $curve`;
		float $xOffset, $yOffset, $zOffset;
		
		$xOffset = $aPivot[0] - $aCenter[0] + $aBboxDim[0]*$x;
		$yOffset = $aPivot[1] - $aCenter[1] + $aBboxDim[1]*$y;
		$zOffset = $aPivot[2] - $aCenter[2] + $aBboxDim[2]*$z;
		
		string $aCvs[] = `filterExpand -ex true -sm 28 ($curve+".cv[*]")`;
		string $cv;
		float $xForm[], $xForm2[];
		
		for ($cv in $aCvs){
			$xForm = ($useWorldSpace) ? `xform -q -ws -t $cv` : `xform -q -os -t $cv` ;
			$xForm2[0] = $xForm[0] + $xOffset;
			$xForm2[1] = $xForm[1] + $yOffset;
			$xForm2[2] = $xForm[2] + $zOffset;
			if ($useWorldSpace){
				xform -ws -t $xForm2[0] $xForm2[1] $xForm2[2] $cv;
			}else{
				xform -os -t $xForm2[0] $xForm2[1] $xForm2[2] $cv;
			}
		}
	}
}


global proc abRTCenterWireOnPivot(string $curve, string $objPivotToUse){
	// centers $curve on its pivot
	// specify objPivotToUse if you want to center it on an object other than the curve itself
	
	string $tLoc, $tPivObj, $aStr[], $str;
	float $wireTrans[], $aPivotTrans[], $aOffset[], $aNewOffset[], $aCurveTrans[], $aNewWireTrans[];
	
	float $aBbox[] = `xform -q -ws -boundingBox $curve`;
	
	$wireTrans[0] = ($aBbox[3] + $aBbox[0])/2.0;
	$wireTrans[1] = ($aBbox[4] + $aBbox[1])/2.0;
	$wireTrans[2] = ($aBbox[5] + $aBbox[2])/2.0;
	
	$tPivObj = ($objPivotToUse == "") ? $curve : $objPivotToUse;
	
	$tLoc = abRTMakeLocatorV2("abRTCenterWireOnPivt_tLoc", $tPivObj, "");
	
	$aPivotTrans = `xform -q -ws -t $tLoc`;
	
	delete $tLoc;
	
	$aOffset[0] = $aPivotTrans[0] - $wireTrans[0];
	$aOffset[1] = $aPivotTrans[1] - $wireTrans[1];
	$aOffset[2] = $aPivotTrans[2] - $wireTrans[2];
	
	// now move cvs
	string $aCvs[] = `filterExpand -ex true -sm 28 ($curve+".cv[*]")`;
	string $cv;
	float $xForm[], $xForm2[];
	
	for ($cv in $aCvs){
		
		$xForm = `xform -q -ws -t $cv`;
		$xForm2[0] = $xForm[0] + $aOffset[0];
		$xForm2[1] = $xForm[1] + $aOffset[1];
		$xForm2[2] = $xForm[2] + $aOffset[2];
		
		xform -ws -t $xForm2[0] $xForm2[1] $xForm2[2] $cv;
	}
	
	if ($objPivotToUse != ""){
		
		// want to update and store the new offset for the wires snapped to objects
		$aBbox = `xform -q -ws -boundingBox $curve`;
		
		$aNewWireTrans[0] = ($aBbox[3] + $aBbox[0])/2.0;
		$aNewWireTrans[1] = ($aBbox[4] + $aBbox[1])/2.0;
		$aNewWireTrans[2] = ($aBbox[5] + $aBbox[2])/2.0;
		
		//$tLoc = abRTMakeLocatorV2("abRTCenterWireOnPivt_tLoc", $curve, "");
		$tLoc = abRTMakeLocator("abRTCenterWireOnPivot_tLoc");
		$aStr = `pointConstraint $curve $tLoc`;
			for ($str in $aStr)
				delete $str;
		
		$aCurveTrans = `xform -q -ws -t $tLoc`;
		
		delete $tLoc;
		
		$aNewOffset[0] = $aNewWireTrans[0] - $aCurveTrans[0];
		$aNewOffset[1] = $aNewWireTrans[1] - $aCurveTrans[1];
		$aNewOffset[2] = $aNewWireTrans[2] - $aCurveTrans[2];
		
	}
	
}


global proc abRTSetWireAttributes(string $curve, string $aData[]){
	// updates values on wires in form of {variableKey, varVal, variableKey2, varVal2}
	// use "&" to concatenate arrays
	
	string $varKey, $varStringVal, $aStr[];
	int $i;
	
	for ($i=0;$i<size($aData);$i+=2){
		
		$varKey = $aData[$i];
		$varStringVal = $aData[$i+1];
		
		if ($varKey == "wireScale"){
			
			if ($varStringVal != ""){
				
				if (!attributeExists("wireScale", $curve))
					addAttr -ln "wireScale" -at double -min 0 -keyable false -hidden true $curve;
				
				setAttr ($curve+".wireScale") (float($varStringVal));
				
			}else{
				if (attributeExists("wireScale", $curve))
					deleteAttr ($curve+".wireScale");
			}
			
			
		}else if ($varKey == "wireType"){
			
			if ($varStringVal != ""){
				
				if (!attributeExists("wireType", $curve))
					addAttr -ln "wireType" -dt "string" -keyable false -hidden true $curve;
				
				setAttr -type "string" ($curve+".wireType") $varStringVal;
				
			}else{
				if (attributeExists("wireType", $curve))
					deleteAttr ($curve+".wireType");
			}
			
		}else if ($varKey == "wireFacingAxis"){
			
			if ($varStringVal != ""){
				
				if (!attributeExists("wireFacingAxis", $curve))
					addAttr -ln "wireFacingAxis" -at short -keyable false -hidden true $curve;
				
				setAttr ($curve+".wireFacingAxis") (int($varStringVal));
				
			}else{
				if (attributeExists("wireFacingAxis", $curve))
					deleteAttr ($curve+".wireFacingAxis");
			}
			
		}
	}
	
}


global proc abRTCopyWireAttributes(string $curve, string $mCtrl){
	// copies mirror wire attributes from curve to mCtrl
	
	float $maOffset[];
	string $aWireAtts[];
	
	if (attributeExists("wireType", $curve)){
		$aWireAtts[size($aWireAtts)] = "wireType";
		$aWireAtts[size($aWireAtts)] = `getAttr ($curve+".wireType")`;
	}
	
	if (attributeExists("wireScale", $curve)){
		$aWireAtts[size($aWireAtts)] = "wireScale";
		$aWireAtts[size($aWireAtts)] = string(`getAttr ($curve+".wireScale")`);
	}
	
	if (attributeExists("wireFacingAxis", $curve)){
		$aWireAtts[size($aWireAtts)] = "wireFacingAxis";
		$aWireAtts[size($aWireAtts)] = string(`getAttr ($curve+".wireFacingAxis")`);
	}
	
	// now add atts
	abRTSetWireAttributes($mCtrl, $aWireAtts);
	
}


global proc string[] abRTGetWireControllerDirections(string $wireType, int $facingAxis, float $aOffset[], float $size, int $useWS){
	// returns instructions for wire controller in form of {curveDirections, [curveHardness]}
	
	string $aDirections[] = abRTWireController($wireType, $facingAxis, $aOffset, $size, true, $useWS);
	
	return $aDirections;
}


global proc string abRTMakeWireController(string $wireType, int $facingAxis, float $aOffset[], float $size){
	// builds a control curve
	
	string $aStr[] = abRTWireController($wireType, $facingAxis, $aOffset, $size, false, true);
	
	string $curve = $aStr[0];
	
	// add hidden atts
	float $globalScale = float(abRTGetGlobal("globalScale"));
	
	abRTSetWireAttributes($curve, {"wireScale", (string($size/$globalScale)), "wireType", $wireType, "wireFacingAxis", (string($facingAxis))});
	
	return $curve;
}


global proc string[] abRTWireController(string $wireType, int $facingAxis, float $aOffset[], float $size, int $getIns, int $useWS){
	/*
	$wireType is the type of controller to build
	$facingAxis is the direction that the controller will face 0(x+), 1(y+), 2(z+), 3, 4, and 5 are the coresponding negative directions
	$aOffset is used to offset wire from origin
	$size is how big to make the max dimension on the bounding box (in Maya units which is modified by the global "globalScale")
	if $getIns (get instructions) is true, directions on how to build the control will be returned -- controller won't be built
	if $getIns is false, newly built controller name will be returned
	if $useWS, operation will be performed in worldSpace, otherwise objectSpace will be used
	*/
	
	string $aDirections[], $directions, $hardness, $aRet[], $aStr[], $cmdStr, $spcFlg;
	float $aRot[];
	
	switch($wireType){
		
		case "fatArrow": $aDirections = {"curve -d 1 -p -1.13696793 -4.532183231e-016 -1.736420648 -p -1.13696793 -3.029387864e-016 -0.2273470747 -p -2 -4.945704011e-016 -0.2273470747 -p 1.550375579e-005 1.450820363e-016 1.736420648 -p 2 3.936080183e-016 -0.2273470747 -p 1.136881109 2.019571254e-016 -0.2273470747 -p 1.136881109 5.167758861e-017 -1.736420648 -p -1.13696793 -4.532183231e-016 -1.736420648"}; break;
		case "medArrow": $aDirections = {"curve -d 1 -p -1.008294648 -4.71258548e-016 -2 -p -1.008294648 -2.895354667e-016 -0.1751773671 -p -1.773670842 -4.594831208e-016 -0.1751773671 -p 8.820779928e-015 1.509637169e-016 2 -p 1.773670842 3.281849614e-016 -0.1751773671 -p 1.008215818 1.582198035e-016 -0.1751773671 -p 1.008215818 -2.350327819e-017 -2 -p -1.008294648 -4.71258548e-016 -2"}; break;
		case "fatFourWayArrowMed": $aDirections = {"curve -d 1 -p -9.860761315e-032 -1.99167939e-016 -2 -p -0.6639344264 -2.655067899e-016 -1.185770492 -p -0.3774000001 -2.018833665e-016 -1.185770492 -p -0.3774000001 -1.213826241e-016 -0.3774000001 -p -1.185770492 -3.008769306e-016 -0.3774000001 -p -1.185770492 -3.294111661e-016 -0.6639344264 -p -2 -4.440892099e-016 9.860761318e-032 -p -1.185770492 -1.971767147e-016 0.6639344264 -p -1.185770492 -2.257076853e-016 0.3774327869 -p -0.3774327869 -4.622065895e-017 0.3774327869 -p -0.3774327869 3.427681844e-017 1.185770492 -p -0.6639344264 -2.933932489e-017 1.185770492 -p 9.860761315e-032 1.99167939e-016 2 -p 0.6639344264 2.655067899e-016 1.185770492 -p 0.3774000001 2.018833665e-016 1.185770492 -p 0.3774000001 1.213826241e-016 0.3774000001 -p 1.185770492 3.008769306e-016 0.3774000001 -p 1.185770492 3.294111661e-016 0.6639344264 -p 2 4.440892099e-016 -9.860761318e-032 -p 1.185770492 1.971767147e-016 -0.6639344264 -p 1.185770492 2.257076853e-016 -0.3774327869 -p 0.3774327869 4.622065895e-017 -0.3774327869 -p 0.3774327869 -3.427681844e-017 -1.185770492 -p 0.6639344264 2.933932489e-017 -1.185770492 -p -9.860761315e-032 -1.99167939e-016 -2"}; break;
		case "fatFourWayArrow": $aDirections = {"curve -d 1 -p 1.30541401e-006 -1.991662106e-016 -2 -p -0.5286913681 -2.519920061e-016 -1.35162697 -p -0.3005519943 -2.01334889e-016 -1.35162697 -p -0.3005519943 -9.666337077e-017 -0.3005389401 -p -1.351613916 -3.300459999e-016 -0.3005389401 -p -1.351613916 -3.527652843e-016 -0.5286809248 -p -1.999986946 -4.440837024e-016 1.174872608e-005 -p -1.351613916 -2.474666541e-016 0.5287044222 -p -1.351613916 -2.701882786e-016 0.3005389401 -p -0.3005519943 -3.680564937e-017 0.3005389401 -p -0.3005519943 6.786586888e-017 1.35162697 -p -0.5286913681 1.720875176e-017 1.35162697 -p 1.30541401e-006 1.991696677e-016 2 -p 0.5286939789 2.519954634e-016 1.35162697 -p 0.300525886 2.013319694e-016 1.35162697 -p 0.300525886 9.666045107e-017 0.3005389401 -p 1.351613916 3.300488774e-016 0.3005389401 -p 1.351613916 3.527705018e-016 0.5287044222 -p 1.999986946 4.440889199e-016 1.174872608e-005 -p 1.351613916 2.474718716e-016 -0.5286809248 -p 1.351613916 2.701911561e-016 -0.3005389401 -p 0.300525886 3.680272967e-017 -0.3005389401 -p 0.300525886 -6.786878854e-017 -1.35162697 -p 0.5286939789 -1.720529447e-017 -1.35162697 -p 1.30541401e-006 -1.991662106e-016 -2"}; break;
		case "fatFoutWayArrowSmall_1": $aDirections = {"curve -d 1 -p 1.180149114e-015 -1.991627351e-016 -1.999976564 -p -0.9492113346 -3.25514564e-016 -1.152295686 -p -0.5396067219 -2.345640697e-016 -1.152295686 -p -0.5396067219 -1.735477366e-016 -0.5395832847 -p -1.152319123 -3.095972196e-016 -0.5395832847 -p -1.152319123 -3.503872729e-016 -0.9491878972 -p -2 -4.440840058e-016 2.34373169e-005 -p -1.152319123 -1.613348076e-016 0.9492347719 -p -1.152319123 -2.021295288e-016 0.5395832847 -p -0.5396067219 -6.608004592e-017 0.5395832847 -p -0.5396067219 -5.059044821e-018 1.15234256 -p -0.9492113346 -9.600953922e-017 1.15234256 -p 1.180149114e-015 1.991684754e-016 1.999976564 -p 0.9492113346 3.255249723e-016 1.15234256 -p 0.5395598474 2.345640698e-016 1.15234256 -p 0.5395598474 1.735430687e-016 0.5395832847 -p 1.152319123 3.096029599e-016 0.5395832847 -p 1.152319123 3.503976812e-016 0.9492347719 -p 2 4.440944141e-016 2.34373169e-005 -p 1.152319123 1.613452159e-016 -0.9491878972 -p 1.152319123 2.021352691e-016 -0.5395832847 -p 0.5395598474 6.607537795e-017 -0.5395832847 -p 0.5395598474 5.059044751e-018 -1.152295686 -p 0.9492113346 9.601994752e-017 -1.152295686 -p 1.180149114e-015 -1.991627351e-016 -1.999976564"}; break;
		case "twoWayArrow": $aDirections = {"curve -d 1 -p -1.185770492 -3.008769306e-016 -0.3774000001 -p -1.185770492 -3.294111661e-016 -0.6639344264 -p -2 -4.440892099e-016 -3.301863753e-015 -p -1.185770492 -1.971767147e-016 0.6639344264 -p -1.185770492 -2.257076853e-016 0.3774327869 -p 1.185770492 3.008769306e-016 0.3774000001 -p 1.185770492 3.294111661e-016 0.6639344264 -p 2 4.440892099e-016 -3.301863753e-015 -p 1.185770492 1.971767147e-016 -0.6639344264 -p 1.185770492 2.257076853e-016 -0.3774327869 -p -1.185770492 -3.008769306e-016 -0.3774000001"}; break;
		case "medTwoWayArrow": $aDirections = {"curve -d 1 -p -0.8347730204 -2.391417678e-016 -0.5400961875 -p -0.8347730204 -2.799762183e-016 -0.9501466274 -p -2 -4.440892098e-016 2.362623916e-015 -p -0.8347730204 -9.073747268e-017 0.9501466274 -p -0.8347730204 -1.315677179e-016 0.5401384163 -p 0.8347683283 2.391402587e-016 0.5400914956 -p 0.8347683283 2.799751764e-016 0.9501466274 -p 2 4.440892098e-016 2.362623916e-015 -p 0.8347683283 9.073643084e-017 -0.9501466274 -p 0.8347683283 1.315666761e-016 -0.5401384163 -p -0.8347730204 -2.391417678e-016 -0.5400961875"}; break;
		case "fatCross": $aDirections = {"curve -d 1 -p -1.295999999 -4.869377471e-016 -2 -p -1.295999999 -4.168306324e-016 -1.295999999 -p -2 -5.731500341e-016 -1.295999999 -p -2 -3.150283852e-016 1.295999999 -p -1.295999999 -1.587089834e-016 1.295999999 -p -1.295999999 -8.860186874e-017 2 -p 1.295999999 4.869377471e-016 2 -p 1.295999999 4.168306324e-016 1.295999999 -p 2 5.731500341e-016 1.295999999 -p 2 3.150283852e-016 -1.295999999 -p 1.295999999 1.587089834e-016 -1.295999999 -p 1.295999999 8.860186874e-017 -2 -p -1.295999999 -4.869377471e-016 -2"}; break;
		case "medCross": $aDirections = {"curve -d 1 -p -0.8839111111 -3.954356325e-016 -2 -p -0.8839111111 -2.842969718e-016 -0.8839703704 -p -2 -5.321184883e-016 -0.8839703704 -p -2 -3.560599313e-016 0.8839703704 -p -0.8839111111 -1.082384149e-016 0.8839703704 -p -0.8839111111 2.900245553e-018 2 -p 0.8840296296 3.95461949e-016 2 -p 0.8840296296 2.843232883e-016 0.8839703704 -p 2 5.321184883e-016 0.8839703704 -p 2 3.560599313e-016 -0.8839703704 -p 0.8840296296 1.082647314e-016 -0.8839703704 -p 0.8840296296 -2.873929247e-018 -2 -p -0.8839111111 -3.954356325e-016 -2"}; break;
		case "hexagon": $aDirections = {"curve -d 1 -p 1.732069186 4.841823955e-016 1.000018152 -p 1.728708577e-005 1.991717776e-016 2 -p -1.732069186 -2.850108411e-016 1.000018152 -p -1.732069186 -4.841823955e-016 -1.000018152 -p 1.728708577e-005 -1.991641006e-016 -2 -p 1.732069186 2.850108411e-016 -1.000018152 -p 1.732069186 4.841823955e-016 1.000018152"}; break;
		case "pentagon": $aDirections = {"curve -d 1 -p 1.902094336 4.838950455e-016 1.236047533 -p -0.4489878479 3.792734978e-017 2 -p -1.902094336 -4.838950455e-016 -1.711825145e-015 -p -0.4489878479 -3.604085283e-016 -2 -p 1.902094336 2.377140058e-016 -1.236047533 -p 1.902094336 4.838950455e-016 1.236047533"}; break;
		case "triangle": $aDirections = {"curve -d 1 -p 1.732089031 8.881784197e-016 2 -p -1.732089031 -4.242328955e-016 -1.677410481e-005 -p 1.732089031 -8.881784197e-016 -2 -p 1.732089031 8.881784197e-016 2"}; break;
		case "square": $aDirections = {"curve -d 1 -p 2 2.449212707e-016 -2 -p 2 6.432571491e-016 2 -p -2 -2.449212707e-016 2 -p -2 -6.432571491e-016 -2 -p 2 2.449212707e-016 -2"}; break;
		case "rightFoot": $aDirections = {"curve -d 3 -p 0.06318265997 6.203348349e-016 -2.864061996 -p 0.35405183 5.763113415e-016 -2.867827055 -p 0.6910319521 5.03223827e-016 -2.762578432 -p 0.7665175589 4.211446138e-016 -2.412890286 -p 0.8420031658 3.390654006e-016 -2.063202141 -p 0.7025064917 1.781773447e-016 -1.158105227 -p 0.6544433436 1.254089529e-016 -0.8594840177 -p 0.5613395771 2.319404977e-017 -0.2810380245 -p 0.7874460407 -1.099241968e-016 0.2068702536 -p 0.8404922811 -1.538596233e-016 0.3843929599 -p 0.8935385215 -1.977950498e-016 0.5619156663 -p 1.322228305 -3.416252982e-016 0.9481911558 -p 1.306502307 -4.250885463e-016 1.374444873 -p 1.290776308 -5.085517943e-016 1.800698592 -p 1.241162247 -6.839057219e-016 2.708910254 -p 0.8524506908 -6.357743351e-016 2.767050547 -p 0.1786839945 -5.523465979e-016 2.867827055 -p -0.8717223576 -2.247705011e-016 2.044665902 -p -1.096975331 -1.007922303e-016 1.601468152 -p -1.322228305 2.318604052e-017 1.158270402 -p -0.9126966985 1.518189813e-017 0.8850652409 -p -0.8308564474 1.064731548e-016 0.3694411534 -p -0.7490161963 1.977644115e-016 -0.1461829341 -p -0.8609902906 3.716282977e-016 -0.9235268929 -p -0.8534468031 4.615886149e-016 -1.375773867 -p -0.8401568705 6.200876795e-016 -2.172577076 -p -0.3568401958 6.839057219e-016 -2.858624086 -p 0.06318265997 6.203348349e-016 -2.864061996"}; break;
		case "pyramid": $aDirections = {"curve -d 1 -p -1.19152376 -0.8425346782 -1.191524073 -p 1.191524021 -0.8425346782 -1.191523917 -p 5.200000844e-008 0.8425346782 5.199999977e-008 -p -1.19152376 -0.8425346782 -1.191524073 -p -1.191524021 -0.8425346782 1.191523916 -p 5.200000844e-008 0.8425346782 5.199999977e-008 -p 1.191523968 -0.8425346782 1.191524073 -p -1.191524021 -0.8425346782 1.191523916 -p 1.191523968 -0.8425346782 1.191524073 -p 1.191524021 -0.8425346782 -1.191523917"}; break;
		case "diamond": $aDirections = {"curve -d 1 -p 0 1.239355655 0 -p -1.514017025 0.0004742610035 -1.323595759e-007 -p -6.617978794e-008 0.0004742610035 1.514017025 -p 0 1.239355655 0 -p -6.617978794e-008 0.0004742610035 1.514017025 -p 0 -1.239355655 0 -p 1.985393517e-007 0.0004742610035 -1.514017025 -p 0 1.239355655 0 -p -1.514017025 0.0004742610035 -1.323595759e-007 -p 0 -1.239355655 0 -p 1.514017025 0.0004742610035 0 -p 0 1.239355655 0 -p -6.617978794e-008 0.0004742610035 1.514017025 -p -1.514017025 0.0004742610035 -1.323595759e-007 -p 1.985393517e-007 0.0004742610035 -1.514017025 -p 1.514017025 0.0004742610035 0 -p -6.617978794e-008 0.0004742610035 1.514017025"}; break;
		case "wedge": $aDirections = {"curve -d 1 -p 1.30736962 -0.5857146082 1.192092896e-007 -p -1.307369381 -0.5857146082 -1.509620428 -p -1.30736962 -0.5857146082 1.509620428 -p 1.30736962 -0.5857146082 1.192092896e-007 -p -1.30736962 0.5857146082 1.509620428 -p -1.30736962 -0.5857146082 1.509620428 -p -1.30736962 0.5857146082 1.509620428 -p -1.307369381 0.5857146082 -1.509620428 -p -1.307369381 -0.5857146082 -1.509620428 -p 1.30736962 -0.5857146082 1.192092896e-007 -p -1.307369381 0.5857146082 -1.509620428"}; break;
		case "cone": $aDirections = {"curve -d 1 -p 0.52405353 -1.12549606 -0.9076867709 -p -0.5240531214 -1.12549606 -0.9076870161 -p 0 1.12549606 4.085917841e-008 -p 0.52405353 -1.12549606 -0.9076867709 -p 1.04810657 -1.12549606 4.085917841e-008 -p 0 1.12549606 4.085917841e-008 -p 0.524053244 -1.12549606 0.9076870161 -p -0.5240534074 -1.12549606 0.9076869344 -p 0 1.12549606 4.085917841e-008 -p -1.04810657 -1.12549606 -1.15320871e-007 -p -0.5240531214 -1.12549606 -0.9076870161 -p 0 1.12549606 4.085917841e-008 -p 0.52405353 -1.12549606 -0.9076867709 -p 1.04810657 -1.12549606 4.085917841e-008 -p 0.524053244 -1.12549606 0.9076870161 -p -0.5240534074 -1.12549606 0.9076869344 -p -1.04810657 -1.12549606 -1.15320871e-007 -p -0.5240531214 -1.12549606 -0.9076870161"}; break;
		case "cube": $aDirections = {"curve -d 1 -p -0.9570669451 0.9570669451 0.9570669451 -p -0.9570669451 -0.9570669451 0.9570669451 -p -0.9570669451 -0.9570669451 -0.9570669451 -p -0.9570669451 0.9570669451 -0.9570669451 -p -0.9570669451 0.9570669451 0.9570669451 -p 0.9570669451 0.9570669451 0.9570669451 -p 0.9570669451 -0.9570669451 0.9570669451 -p -0.9570669451 -0.9570669451 0.9570669451 -p -0.9570669451 -0.9570669451 -0.9570669451 -p 0.9570669451 -0.9570669451 -0.9570669451 -p 0.9570669451 0.9570669451 -0.9570669451 -p -0.9570669451 0.9570669451 -0.9570669451 -p 0.9570669451 0.9570669451 -0.9570669451 -p 0.9570669451 0.9570669451 0.9570669451 -p 0.9570669451 -0.9570669451 0.9570669451 -p 0.9570669451 -0.9570669451 -0.9570669451"}; break;
		case "circle": $aDirections = {"curve -d 3 -p 4.582625498 1.198805e-018 0.00539896997 -p 4.595327382 -1.42574945e-016 -0.6349328974 -p 4.187970871 -5.45825705e-016 -2.451012894 -p 2.24143406 -9.27063555e-016 -4.157204192 -p 0.0795784565 -1.030068795e-015 -4.674855144 -p -2.227711712 -9.13822025e-016 -4.144158701 -p -4.071716142 -5.02430505e-016 -2.262745818 -p -4.595327382 1.198805e-018 0.00539896997 -p -4.074078553 5.10656515e-016 2.292624946 -p -2.218254915 9.19530425e-016 4.141196874 -p 0.0903297707 1.030068795e-015 4.674855144 -p 2.288113258 9.34742835e-016 4.160802767 -p 4.201866899 5.55205055e-016 2.396554092 -p 4.585715534 1.19738185e-016 0.686187481 -p 4.582625498 1.198805e-018 0.00539896997", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[12]"}; break;
		case "sphere": $aDirections = {"curve -d 1 -p -7.058219961e-008 1.489694643 -4.207026559e-015 -p -7.058219961e-008 1.376298421 -0.5700813997 -p -7.058219961e-008 1.05337317 -1.053373099 -p -7.058219961e-008 0.5700814703 -1.37629828 -p -7.058219961e-008 0 -1.489694502 -p -7.058219961e-008 -0.5700814703 -1.37629828 -p -7.058219961e-008 -1.05337317 -1.053373099 -p -7.058219961e-008 -1.376298421 -0.5700813997 -p -7.058219961e-008 -1.489694643 -4.207026559e-015 -p -7.058219961e-008 -1.376298421 0.570081435 -p -7.058219961e-008 -1.05337317 1.05337317 -p -7.058219961e-008 -0.5700814703 1.37629828 -p -7.058219961e-008 0 1.489694502 -p -7.058219961e-008 0.5700814703 1.37629828 -p -7.058219961e-008 1.05337317 1.05337317 -p -7.058219961e-008 1.376298421 0.570081435 -p -7.058219961e-008 1.489694643 -4.207026559e-015 -p -0.5700814703 1.376298421 -4.207026559e-015 -p -1.05337317 1.05337317 -4.207026559e-015 -p -1.37629835 0.5700814703 -4.207026559e-015 -p -1.489694573 0 -4.207026559e-015 -p -1.37629835 -0.5700814703 -4.207026559e-015 -p -1.05337317 -1.05337317 -4.207026559e-015 -p -0.5700814703 -1.376298421 -4.207026559e-015 -p -7.058219961e-008 -1.489694643 -4.207026559e-015 -p 0.5700813997 -1.376298421 -4.207026559e-015 -p 1.05337317 -1.05337317 -4.207026559e-015 -p 1.37629835 -0.5700814703 -4.207026559e-015 -p 1.489694573 0 -4.207026559e-015 -p 1.37629835 0.5700814703 -4.207026559e-015 -p 1.05337317 1.05337317 -4.207026559e-015 -p 0.5700813997 1.376298421 -4.207026559e-015 -p -7.058219961e-008 1.489694643 -4.207026559e-015 -p -0.5700814703 1.376298421 -4.207026559e-015 -p -1.05337317 1.05337317 -4.207026559e-015 -p -1.37629835 0.5700814703 -4.207026559e-015 -p -1.489694573 0 -4.207026559e-015 -p -1.05337317 0 1.053373099 -p -7.058219961e-008 0 1.489694502 -p 1.053373099 0 1.05337317 -p 1.489694573 0 -4.207026559e-015 -p 1.053373029 0 -1.053373099 -p -7.058219961e-008 0 -1.489694502 -p -1.05337317 0 -1.053373099 -p -1.489694573 0 -4.207026559e-015"}; break;
		case "leftFoot": $aDirections = {"curve -d 3 -p -0.06318265997 6.203348349e-016 -2.864061996 -p -0.35405183 5.763113415e-016 -2.867827055 -p -0.6910319521 5.03223827e-016 -2.762578432 -p -0.7665175589 4.211446138e-016 -2.412890286 -p -0.8420031658 3.390654006e-016 -2.063202141 -p -0.7025064917 1.781773447e-016 -1.158105227 -p -0.6544433436 1.254089529e-016 -0.8594840177 -p -0.5613395771 2.319404977e-017 -0.2810380245 -p -0.7874460407 -1.099241968e-016 0.2068702536 -p -0.8404922811 -1.538596233e-016 0.3843929599 -p -0.8935385215 -1.977950498e-016 0.5619156663 -p -1.322228305 -3.416252982e-016 0.9481911558 -p -1.306502307 -4.250885463e-016 1.374444873 -p -1.290776308 -5.085517943e-016 1.800698592 -p -1.241162247 -6.839057219e-016 2.708910254 -p -0.8524506908 -6.357743351e-016 2.767050547 -p -0.1786839945 -5.523465979e-016 2.867827055 -p 0.8717223576 -2.247705011e-016 2.044665902 -p 1.096975331 -1.007922303e-016 1.601468152 -p 1.322228305 2.318604052e-017 1.158270402 -p 0.9126966985 1.518189813e-017 0.8850652409 -p 0.8308564474 1.064731548e-016 0.3694411534 -p 0.7490161963 1.977644115e-016 -0.1461829341 -p 0.8609902906 3.716282977e-016 -0.9235268929 -p 0.8534468031 4.615886149e-016 -1.375773867 -p 0.8401568705 6.200876795e-016 -2.172577076 -p 0.3568401958 6.839057219e-016 -2.858624086 -p -0.06318265997 6.203348349e-016 -2.864061996"}; break;
		case "eyeHolder_2": $aDirections = {"curve -d 3 -p -3.316111111 4.060934653e-016 0 -p -3.316111111 5.618402142e-016 -0.701421 -p -1.831449361 5.062774923e-016 -1.27 -p 8.881784197e-016 2.819970399e-016 -1.27 -p 1.831445833 5.77170195e-017 -1.27 -p 3.316111111 -2.503459332e-016 -0.701421 -p 3.316111111 -4.06092682e-016 0 -p 3.316111111 -5.618402142e-016 0.7014245278 -p 1.831445833 -5.06276277e-016 1.27 -p 8.881784197e-016 -2.819962566e-016 1.27 -p -1.831449361 -5.771580416e-017 1.27 -p -3.316111111 2.503459332e-016 0.7014245278 -p -3.316111111 4.060934653e-016 0"}; break;
		case "eyeHolder_1": $aDirections = {"curve -d 3 -p -2.961370125 3.626512671e-016 -3.552713679e-015 -p -2.961370125 5.017374973e-016 -0.6263886944 -p -1.635525403 4.521175368e-016 -1.13414175 -p 1.763888889e-006 2.518298408e-016 -1.13414175 -p 1.635525403 5.15425768e-017 -1.13414175 -p 2.961370125 -2.235650369e-016 -0.6263886944 -p 2.961370125 -3.626512671e-016 -3.552713679e-015 -p 2.961370125 -5.017374973e-016 0.6263886944 -p 1.635525403 -4.521175368e-016 1.13414175 -p 1.763888889e-006 -2.518302728e-016 1.13414175 -p -1.635525403 -5.15425768e-017 1.13414175 -p -2.961370125 2.235650369e-016 0.6263886944 -p -2.961370125 3.626512671e-016 -3.552713679e-015"}; break;
		case "star": $aDirections = {"curve -d 1 -p 4.136342832e-006 3.507139171e-016 1.574294764 -p 0.4483431619 3.507139171e-016 0.4508811256 -p 1.655311323 3.20815096e-017 0.3716434898 -p 0.7254313938 -7.740425674e-017 -0.4019106506 -p 1.023042663 -3.507139171e-016 -1.574294764 -p 1.061470089e-006 -2.042082642e-016 -0.9289619621 -p -1.023034041 -3.507137159e-016 -1.57429398 -p -0.7254222595 -7.740298536e-017 -0.4019042755 -p -1.655311323 3.208211014e-017 0.3716441484 -p -0.5690329816 3.188507364e-016 0.4429598677 -p 4.136342832e-006 3.507139171e-016 1.574294764"}; break;
		case "star1": $aDirections = {"curve -d 1 -p 4.061744194e-006 3.006913913e-016 1.354193638 -p 0.4576062361 3.006913913e-016 1.707772517 -p 0.6771051956 2.764271376e-016 1.172768908 -p 1.25017858 2.743245875e-016 1.250170404 -p 1.172777397 1.510129357e-016 0.6770975918 -p 1.707785327 1.014703209e-016 0.4575947092 -p 1.354201648 2.706829724e-020 -3.179268949e-006 -p 1.707785965 -1.016137352e-016 -0.4576020564 -p 1.172777942 -1.50346153e-016 -0.6771040867 -p 1.25017926 -2.775954695e-016 -1.25017779 -p 0.6771073481 -2.604092926e-016 -1.172779411 -p 0.4575996775 -3.792026117e-016 -1.707776695 -p -8.724864601e-006 -3.006930827e-016 -1.354201273 -p -0.4576042094 -3.792018713e-016 -1.70777336 -p -0.6771189109 -2.60405873e-016 -1.17276401 -p -1.250185239 -2.775942557e-016 -1.250172323 -p -1.172773534 -1.503401313e-016 -0.6770769683 -p -1.707796469 -1.016121026e-016 -0.4575947024 -p -1.354185503 2.99797652e-020 9.930845686e-006 -p -1.707787678 1.014713003e-016 0.4575991166 -p -1.172765547 1.510125537e-016 0.677095857 -p -1.250169545 2.74324514e-016 1.250170012 -p -0.6770964489 2.764269275e-016 1.172768282 -p -0.4795462095 2.982649449e-016 1.654272164 -p 4.061744194e-006 3.006913913e-016 1.354193638"}; break;
		case "star2": $aDirections = {"curve -d 1 -p 0 3.184379554e-016 1.434117057 -p 0.2585374548 3.184379554e-016 1.632383541 -p 0.4431666299 3.118348089e-016 1.363918659 -p 0.7503239032 3.251489358e-016 1.472597395 -p 0.8429510582 2.579924383e-016 1.160209917 -p 1.168652347 2.594151329e-016 1.168645684 -p 1.160218835 1.871856583e-016 0.8429391055 -p 1.472585945 1.666011086e-016 0.750319008 -p 1.363907423 9.839997349e-017 0.443151162 -p 1.632387084 5.740854378e-017 0.2585456926 -p 1.434090436 1.502476341e-021 6.644875207e-006 -p 1.632383891 -5.740616099e-017 -0.2585343404 -p 1.363905697 -9.839791945e-017 -0.4431448385 -p 1.472579458 -1.666016841e-016 -0.7503072814 -p 1.160215127 -1.871717806e-016 -0.8429467614 -p 1.168646713 -2.594920104e-016 -1.168648121 -p 0.842945567 -2.576200165e-016 -1.16021741 -p 0.7503051693 -3.26978815e-016 -1.47258167 -p 0.4431415674 -3.028482973e-016 -1.363907479 -p 0.2585320214 -3.624617615e-016 -1.632382654 -p -1.676819145e-006 -3.184330345e-016 -1.434094896 -p -0.2585343448 -3.624616203e-016 -1.632382018 -p -0.4431462369 -3.028482981e-016 -1.363907482 -p -0.7503072085 -3.269782548e-016 -1.472579147 -p -0.8429491944 -2.576196435e-016 -1.16021573 -p -1.168649352 -2.594916529e-016 -1.168646511 -p -1.16021638 -1.871709056e-016 -0.8429428209 -p -1.472583305 -1.666014853e-016 -0.7503063863 -p -1.363905598 -9.839750762e-017 -0.4431429837 -p -1.632384466 -5.740592112e-017 -0.2585332601 -p -1.434090715 1.879755997e-021 8.343995287e-006 -p -1.632386475 5.740879466e-017 0.2585468225 -p -1.363907142 9.840032914e-017 0.4431527638 -p -1.472587818 1.666012888e-016 0.7503198196 -p -1.160218819 1.871854847e-016 0.8429383229 -p -1.168652893 2.594150897e-016 1.168645491 -p -0.8429515076 2.579923294e-016 1.160209423 -p -0.750324342 3.251488572e-016 1.472597025 -p -0.4431679377 3.11834848e-016 1.363919229 -p -0.2770005521 3.177776447e-016 1.605537148 -p 0 3.184379554e-016 1.434117057"}; break;
		case "star3": $aDirections = {"curve -d 1 -p 1.073841842e-015 4.038637772e-016 1.818840756 -p 0.1963090838 4.038637772e-016 0.9869130102 -p 0.6960591757 3.352535317e-016 1.680385963 -p 0.559054647 1.935382562e-016 0.8366578999 -p 1.286139925 2.839868753e-016 1.286130238 -p 0.8366495027 1.244525777e-016 0.5590153548 -p 1.680420473 1.544894361e-016 0.6960597407 -p 0.9869084139 4.360184999e-017 0.1963035392 -p 1.818865945 -2.80994677e-021 4.888041789e-011 -p 0.9869084145 -4.358756585e-017 -0.1963035394 -p 1.68042047 -1.545564279e-016 -0.6960597396 -p 0.8366495158 -1.241263207e-016 -0.5590153604 -p 1.286139861 -2.855782795e-016 -1.286130211 -p 0.559054958 -1.857754018e-016 -0.8366580349 -p 0.6960576588 -3.731204913e-016 -1.680385305 -p 0.1963164834 -2.191394229e-016 -0.9869162236 -p 1.751439113e-015 -4.038621878e-016 -1.818833599 -p -0.1963164834 -2.191394229e-016 -0.9869162236 -p -0.6960576588 -3.731204913e-016 -1.680385305 -p -0.559054958 -1.857754018e-016 -0.8366580349 -p -1.286139861 -2.855782795e-016 -1.286130211 -p -0.8366495158 -1.241263207e-016 -0.5590153604 -p -1.68042047 -1.545564279e-016 -0.6960597396 -p -0.9869084145 -4.358756585e-017 -0.1963035394 -p -1.818865945 -2.809946771e-021 4.888012291e-011 -p -0.9869084139 4.360184999e-017 0.1963035392 -p -1.680420473 1.544894361e-016 0.6960597407 -p -0.8366495027 1.244525777e-016 0.5590153548 -p -1.286139925 2.839868753e-016 1.286130238 -p -0.559054647 1.935382562e-016 0.8366578999 -p -0.6960591757 3.352535317e-016 1.680385963 -p -0.1378439787 4.118903995e-016 0.9057845227 -p 1.073841842e-015 4.038637772e-016 1.818840756"}; break;
		case "bloatedTriangle": $aDirections = {"curve -d 1 -p -8.439951081e-005 2.394584201e-016 -4.357730348 -p 2.733750797 1.375139807e-015 -3.756657533 -p 4.674855144 2.076052726e-015 -2.521232572 -p 2.973766123 7.354633508e-016 1.965834632 -p -8.439951081e-005 -8.971163865e-016 4.357730348 -p -2.973681724 -1.905734063e-015 1.965834632 -p -4.674855144 -2.076052726e-015 -2.521232572 -p -2.733750797 -1.052918654e-015 -3.756657533 -p -8.439951081e-005 2.394584201e-016 -4.357730348"}; break;
		case "octagonFilled": $aDirections = {"curve -d 1 -p -1.542706563 0 0 -p -1.09085832 0 -1.090858348 -p 2.74106296e-008 0 -1.54270659 -p 1.090858375 0 -1.090858348 -p 1.542706801 0 0 -p 1.090858467 0 1.090858439 -p 2.74106296e-008 0 1.54270659 -p -1.09085832 0 1.090858348 -p -1.542706563 0 0 -p 1.542706801 0 0 -p 2.74106296e-008 0 0 -p 2.74106296e-008 0 1.54270659 -p 2.74106296e-008 0 -1.54270659 -p 2.74106296e-008 0 0 -p -1.09085832 0 -1.090858348 -p 1.090858467 0 1.090858439 -p 2.74106296e-008 0 0 -p -1.09085832 0 1.090858348 -p 1.090858375 0 -1.090858348"}; break;
		case "flattenedCircle": $aDirections = {"curve -d 3 -p -1.893523879 3.626512671e-016 -3.552713679e-015 -p -1.893523879 5.017374973e-016 -0.6263886944 -p -1.008773226 4.521175368e-016 -1.181523364 -p 0 2.518300568e-016 -1.314058341 -p 1.008773226 5.15425768e-017 -1.181523364 -p 1.759554072 -2.235650369e-016 -0.6263886944 -p 1.893523879 -3.626512671e-016 -3.552713679e-015 -p 1.759554072 -5.017374973e-016 0.6263886944 -p 1.008773226 -4.521175368e-016 1.181523364 -p 0 -2.518300568e-016 1.314058341 -p -1.008773226 -5.15425768e-017 1.181523364 -p -1.893523879 2.235650369e-016 0.6263886944 -p -1.893523879 3.626512671e-016 -3.552713679e-015"}; break;
		case "leftEye_1": $aDirections = {"curve -d 3 -p -2.091157218 2.289164591e-017 0.9402978136 -p -2.101509838 3.91332571e-017 0.8728617116 -p -2.108497342 5.520727251e-017 0.8043244846 -p -2.108497342 7.080490942e-017 0.7340789736 -p -2.108497342 2.366937522e-016 -0.01301795638 -p -1.502899941 2.969992602e-016 -0.6186050664 -p -0.7558544658 2.055155967e-016 -0.6186050664 -p -0.008819278815 1.140331933e-016 -0.6186050664 -p 0.5967781202 -9.459600012e-017 -0.01301795638 -p 0.5967781202 -2.604848428e-016 0.7340789736 -p 0.5967781202 -3.230330572e-016 1.01577109 -p 0.5104994282 -3.705414333e-016 1.277313674 -p 0.3630723542 -4.005759447e-016 1.493885135 -p 1.48687705 -4.875660151e-016 1.26585993 -p 3.058112065 -4.038095474e-016 0.02209673762 -p 3.063367034 -4.035294254e-016 0.01793699462 -p 2.506414599 -1.763206388e-016 -0.6981535264 -p 1.3129201 1.465233657e-016 -1.493885136 -p 0.4376400342 2.537107188e-016 -1.493885136 -p -1.471996444 4.875660151e-016 -1.493885136 -p -2.506363144 4.728716376e-016 -0.8572401664 -p -3.063367034 3.114299928e-016 0.1770236286 -p -2.847701171 2.234423385e-016 0.4543421236 -p -2.499982802 1.220483406e-016 0.7192086596 -p -2.091157218 2.289164591e-017 0.9402978136", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[12] #curve#.cv[15] #curve#.cv[22]"}; break;
		case "leftEye_2": $aDirections = {"curve -d 3 -p -1.090492044 -1.548107848e-016 1.494187677 -p -1.241912024 -8.41420248e-017 1.259434028 -p -1.330819785 -1.13035148e-017 0.9804324142 -p -1.330819785 5.53407552e-017 0.6802932992 -p -1.330819785 2.398831652e-016 -0.1508118128 -p -0.6571205822 3.069940652e-016 -0.8246067878 -p 0.1739941098 2.052152352e-016 -0.8246067878 -p 1.00509922 1.034375752e-016 -0.8246067878 -p 1.67879842 -1.286765948e-016 -0.1508118128 -p 1.67879842 -3.132190048e-016 0.6802932992 -p 1.67879842 -3.793018448e-016 0.9779039592 -p 1.59120278 -4.300471348e-016 1.254750639 -p 1.44202392 -4.636364248e-016 1.488297526 -p 2.15725109 -5.078807948e-016 1.293098875 -p 2.82589338 -5.145017848e-016 0.9541518052 -p 3.06336703 -4.078020048e-016 0.3426487672 -p 2.95127219 -1.863968048e-016 -0.5926497658 -p 1.67159616 1.351055452e-016 -1.334808808 -p 0.7609404798 2.611435052e-016 -1.400194278 -p -0.5468454612 4.421665252e-016 -1.494187678 -p -2.318871087 5.145017852e-016 -0.8426603478 -p -3.063367034 4.508057952e-016 -0.1451994078 -p -2.603245667 2.108523452e-016 0.6816916122 -p -1.842659552 -1.706054798e-018 1.21949593 -p -1.090492044 -1.548107848e-016 1.494187677", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[12] #curve#.cv[22]"}; break;
		case "rightEye_1": $aDirections = {"curve -d 3 -p 2.091167507 -4.781952676e-016 0.9402978145 -p 2.101520127 -4.644892336e-016 0.8728617115 -p 2.108497347 -4.501253466e-016 0.8043244855 -p 2.108497347 -4.345277096e-016 0.7340789735 -p 2.108497347 -2.686388666e-016 -0.01301795651 -p 1.502910237 -6.00109336e-017 -0.6186050675 -p 0.7558647566 3.14727304e-017 -0.6186050675 -p 0.008819276593 1.229563934e-016 -0.6186050675 -p -0.5967781234 6.26508854e-017 -0.01301795651 -p -0.5967781234 -1.032379576e-016 0.7340789735 -p -0.5967781234 -1.657861716e-016 1.015771089 -p -0.5104994234 -2.344260356e-016 1.277313673 -p -0.3630723534 -3.005685726e-016 1.493885134 -p -1.486877053 -1.123149696e-016 1.26585993 -p -3.058112063 3.562703764e-016 0.02209673749 -p -3.063367033 3.578375514e-016 0.01793699449 -p -2.506414603 4.486368394e-016 -0.6981535295 -p -1.312909813 4.791673944e-016 -1.493885135 -p -0.4376400334 3.719813014e-016 -1.493885135 -p 1.472006737 1.381247454e-016 -1.493885135 -p 2.506363147 -1.299067786e-016 -0.8572401635 -p 3.063367037 -4.277705246e-016 0.1770236285 -p 2.847701167 -4.629370216e-016 0.4543421235 -p 2.499982807 -4.791673946e-016 0.7192086595 -p 2.091167507 -4.781952676e-016 0.9402978145", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[12] #curve#.cv[15] #curve#.cv[22]"}; break;
		case "rightEye_2": $aDirections = {"curve -d 3 -p 1.090492044 -4.676466964e-016 1.494187677 -p 1.241912026 -4.340639024e-016 1.259434028 -p 1.330819787 -3.830008004e-016 0.9804324151 -p 1.330819787 -3.163565284e-016 0.6802932991 -p 1.330819787 -1.318141224e-016 -0.1508118119 -p 0.6571205855 1.003000496e-016 -0.8246067909 -p -0.1739941045 2.020788826e-016 -0.8246067909 -p -1.005099214 3.038565426e-016 -0.8246067909 -p -1.678798424 2.367456356e-016 -0.1508118119 -p -1.678798424 5.22032296e-017 0.6802932991 -p -1.678798424 -1.38796124e-017 0.9779039591 -p -1.591202774 -8.60789424e-017 1.25475064 -p -1.442023924 -1.562053054e-016 1.488297526 -p -2.157251084 -2.52753254e-017 1.293098875 -p -2.825893384 1.318684036e-016 0.9541518051 -p -3.063367034 2.967305286e-016 0.3426487671 -p -2.951272194 4.906813156e-016 -0.5926497659 -p -1.671596154 4.987637866e-016 -1.334808807 -p -0.7609404845 4.017628046e-016 -1.400194274 -p 0.5468454655 2.624812346e-016 -1.494187677 -p 2.318871088 -9.91902784e-017 -0.8426603429 -p 3.063367034 -3.452291634e-016 -0.1451994079 -p 2.603245668 -4.724890984e-016 0.6816916121 -p 1.842659553 -4.987637864e-016 1.21949593 -p 1.090492044 -4.676466964e-016 1.494187677", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[12] #curve#.cv[22]"}; break;
		case "thinSingleArrow270": $aDirections = {"curve -d 3 -p -0.2579534302 -6.229218624e-016 2.805407016 -p 1.291466876 -8.126648574e-016 2.805407016 -p 2.547512879 -6.875974384e-016 1.549426894 -p 2.547512879 -3.435555564e-016 -1.515121362e-010 -p 2.604829434 -3.505745784e-016 -1.515121362e-010 -p 3.006050478 -3.997083624e-016 -1.515121362e-010 -p 3.063367034 -4.067273834e-016 -1.515121362e-010 -p 2.965776413 -3.642149764e-016 -0.1376363002 -p 2.282633291 -6.66243004e-017 -1.101102786 -p 2.18504267 -2.41118934e-017 -1.238739086 -p 2.08745864 -4.27230884e-017 -1.101102786 -p 1.404361633 -1.730031304e-016 -0.1376363002 -p 1.306777601 -1.916143254e-016 -1.515121362e-010 -p 1.363007864 -1.985003194e-016 -1.515121362e-010 -p 1.756624764 -2.467028954e-016 -1.515121362e-010 -p 1.812855029 -2.535888894e-016 -1.515121362e-010 -p 1.812855029 -5.075309034e-016 1.143653161 -p 0.8857590237 -5.998825974e-016 2.07087434 -p -0.2579534302 -4.598228444e-016 2.07087434 -p -1.401606591 -3.197703514e-016 2.07087434 -p -2.328768477 -3.45057399e-019 1.143653161 -p -2.328768477 2.535969566e-016 -1.515121362e-010 -p -2.328768477 5.075389716e-016 -1.143653161 -p -1.401606591 5.998825976e-016 -2.07087434 -p -0.2579534302 4.598301046e-016 -2.07087434 -p -0.2579534302 4.779520366e-016 -2.152488264 -p -0.2579534302 6.048071906e-016 -2.723793092 -p -0.2579534302 6.229291226e-016 -2.805407016 -p -1.807314444 8.126648576e-016 -2.805407016 -p -3.063367034 6.875967826e-016 -1.549420306 -p -3.063367034 3.435563626e-016 -1.515121362e-010 -p -3.063367034 -4.85519399e-019 1.549426894 -p -1.807314444 -4.331861284e-016 2.805407016 -p -0.2579534302 -6.229218624e-016 2.805407016", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[3] #curve#.cv[6] #curve#.cv[9] #curve#.cv[12] #curve#.cv[15] #curve#.cv[24] #curve#.cv[27] #curve#.cv[31]"}; break;
		case "thinSingleArrow90": $aDirections = {"curve -d 3 -p 1.734283777 1.133729346e-016 -1.186707144 -p 1.821122524 1.027386066e-016 -1.186707144 -p 2.429001559 2.82973536e-017 -1.186707144 -p 2.515840306 1.76630256e-017 -1.186707144 -p 2.367997302 8.20677556e-017 -1.395222825 -p 1.33308297 5.329066626e-016 -2.854851355 -p 1.185239965 5.973113926e-016 -3.063367034 -p 1.037398072 5.691164226e-016 -2.854851355 -p 0.002491502938 3.717490986e-016 -1.395222825 -p -0.1453503921 3.435541286e-016 -1.186707144 -p -0.06016400606 3.331221506e-016 -1.186707144 -p 0.5361483599 2.600973586e-016 -1.186707144 -p 0.6213347449 2.496653796e-016 -1.186707144 -p 0.6213347449 -1.350395764e-016 0.5458499548 -p -0.7831833991 -2.749513924e-016 1.950567716 -p -2.515840306 -6.27691264e-017 1.950567716 -p -2.515840306 -9.02234174e-017 2.074210848 -p -2.515840306 -2.824059214e-016 2.939723902 -p -2.515840306 -3.098602124e-016 3.063367034 -p -0.1685457711 -5.973113924e-016 3.063367034 -p 1.734283777 -4.078311534e-016 1.160587391 -p 1.734283777 1.133729346e-016 -1.186707144", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[3] #curve#.cv[6] #curve#.cv[9] #curve#.cv[12] #curve#.cv[15] #curve#.cv[18] #curve#.cv[19]"}; break;
		case "thinSingleArrow180": $aDirections = {"curve -d 3 -p -0.2579270752 -3.883712454e-016 2.022076347 -p 1.291460285 -5.781102074e-016 2.022076347 -p 2.547479945 -4.530380984e-016 0.7660896358 -p 2.547479945 -1.089976784e-016 -0.7833306722 -p 2.604800155 -1.160171484e-016 -0.7833306722 -p 3.006046825 -1.651540704e-016 -0.7833306722 -p 3.063367035 -1.721735404e-016 -0.7833306722 -p 2.965779345 -1.296613294e-016 -0.9209677042 -p 2.282656715 1.679279756e-016 -1.884439316 -p 2.185069025 2.104401866e-016 -2.022076347 -p 2.087482065 1.918291866e-016 -1.884439316 -p 1.404364565 6.15505176e-017 -0.9209677042 -p 1.306777605 4.29395176e-017 -0.7833306722 -p 1.363007135 3.60536136e-017 -0.7833306722 -p 1.756618915 -1.21483344e-017 -0.7833306722 -p 1.812848445 -1.90342384e-017 -0.7833306722 -p 1.812848445 -2.729747904e-016 0.3603159018 -p 0.8857524348 -3.653279474e-016 1.287543669 -p -0.2579600152 -2.252681934e-016 1.287543669 -p -1.401580235 -8.52197344e-017 1.287543669 -p -2.328768478 2.342102496e-016 0.3603159018 -p -2.328768478 4.881508006e-016 -0.7833306722 -p -2.410389724 4.981461906e-016 -0.7833306722 -p -2.981745791 5.681148176e-016 -0.7833306722 -p -3.063367034 5.781102066e-016 -0.7833306722 -p -3.063367034 2.340697876e-016 0.7660896358 -p -1.807353975 -1.986274434e-016 2.022076347 -p -0.2579270752 -3.883712454e-016 2.022076347", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[3] #curve#.cv[6] #curve#.cv[9] #curve#.cv[15] #curve#.cv[21] #curve#.cv[24] #curve#.cv[25]"}; break;
		case "fourWayArrowCurved": $aDirections = {"curve -d 3 -p 3.063364582 -0.32077111 1.775291025e-010 -p 3.063365399 -0.3207714759 -6.66822471e-007 -p 3.063366217 -0.3207718418 -1.332822471e-006 -p 3.063367034 -0.3207722076 -1.999822471e-006 -p 2.739028555 -0.1755896464 -0.2644722488 -p 2.409455977 -0.06973167215 -0.5332104588 -p 2.07026475 -0.001500219871 -0.8097918488 -p 2.07026475 0.009144996766 -0.6932980888 -p 2.07026475 0.0197902134 -0.5768043188 -p 2.07026475 0.03043543004 -0.4603105488 -p 1.541332535 0.1863273029 -0.4603105488 -p 1.011024365 0.2842469207 -0.4603105488 -p 0.4603305403 0.3207722076 -0.4603105488 -p 0.4603396803 0.2842480032 -1.011004199 -p 0.4603305403 0.1863304192 -1.541312259 -p 0.4603305403 0.03043998666 -2.070244759 -p 0.5768229773 0.01979460375 -2.070244759 -p 0.6933154133 0.009149220839 -2.070244759 -p 0.8098078493 -0.001496162075 -2.070244759 -p 0.5332265573 -0.06972601212 -2.409435859 -p 0.2644883403 -0.1755823759 -2.739008439 -p 1.799532637e-005 -0.3207632574 -3.063347039 -p -0.2644544127 -0.1755812799 -2.739009279 -p -0.5331900237 -0.06972332905 -2.409436519 -p -0.8097718587 -0.001491993067 -2.070244759 -p -0.6932914187 0.009152000177 -2.070244759 -p -0.5768109797 0.01979599342 -2.070244759 -p -0.4603305407 0.03043998666 -2.070244759 -p -0.4603305407 0.1863304192 -1.541312259 -p -0.4603396807 0.2842480032 -1.011004199 -p -0.4603305407 0.3207722076 -0.4603105488 -p -1.011024366 0.2842469207 -0.4603105488 -p -1.541332536 0.1863273029 -0.4603105488 -p -2.070264751 0.03043543004 -0.4603105488 -p -2.070264751 0.0197902134 -0.5768043188 -p -2.070264751 0.009144996766 -0.6932980888 -p -2.070264751 -0.001500219871 -0.8097918488 -p -2.409455978 -0.06973167215 -0.5332104588 -p -2.739028556 -0.1755896464 -0.2644722488 -p -3.063367034 -0.3207722076 -1.999822471e-006 -p -2.739028569 -0.1755894889 0.2644682382 -p -2.409455985 -0.06973136095 0.5332064532 -p -2.070264751 -0.001499756648 0.8097878542 -p -2.070264751 0.009144414626 0.6933087482 -p -2.070264751 0.0197885859 0.5768296422 -p -2.070264751 0.03043275718 0.4603505352 -p -1.541332434 0.1863246969 0.4603505352 -p -1.01102434 0.2842437846 0.4603596752 -p -0.4603305407 0.3207695553 0.4603505352 -p -0.4603305407 0.2842436488 1.011030235 -p -0.4603305407 0.1863264965 1.541325567 -p -0.4603305407 0.03043998666 2.070244757 -p -0.5768109797 0.01979599342 2.070244757 -p -0.6932914187 0.009152000177 2.070244757 -p -0.8097718587 -0.001491993067 2.070244757 -p -0.5331900237 -0.06972332907 2.409436523 -p -0.2644544127 -0.1755812799 2.73900928 -p 1.799532637e-005 -0.3207632574 3.063347039 -p 0.2644883403 -0.1755823759 2.739008444 -p 0.5332265573 -0.06972601212 2.409435856 -p 0.8098078493 -0.001496162075 2.070244757 -p 0.6933154133 0.009149220839 2.070244757 -p 0.5768229773 0.01979460375 2.070244757 -p 0.4603305403 0.03043998666 2.070244757 -p 0.4603305403 0.1863264965 1.541325567 -p 0.4603305403 0.2842436488 1.011030235 -p 0.4603305403 0.3207695553 0.4603505352 -p 1.01102434 0.2842437846 0.4603596752 -p 1.541332433 0.1863246969 0.4603505352 -p 2.07026475 0.03043275718 0.4603505352 -p 2.07026475 0.0197885859 0.5768296422 -p 2.07026475 0.009144414626 0.6933087482 -p 2.07026475 -0.001499756648 0.8097878542 -p 2.409455123 -0.06973118745 0.5332071572 -p 2.739026891 -0.1755889516 0.2644696082 -p 3.063364582 -0.32077111 1.775291025e-010", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[6] #curve#.cv[9] #curve#.cv[12] #curve#.cv[15] #curve#.cv[18] #curve#.cv[21] #curve#.cv[24] #curve#.cv[27] #curve#.cv[30] #curve#.cv[36] #curve#.cv[39] #curve#.cv[42] #curve#.cv[48] #curve#.cv[51] #curve#.cv[54] #curve#.cv[57] #curve#.cv[60] #curve#.cv[63] #curve#.cv[66] #curve#.cv[69] #curve#.cv[72] #curve#.cv[73]"}; break;
		case "fatSingleArrow90": $aDirections = {"curve -d 3 -p -2.326090564 -2.200473137e-011 0.9595917596 -p -2.326090564 -2.200473137e-011 1.193342231 -p -2.326090564 -2.200473137e-011 2.829616563 -p -2.326090564 -2.200473137e-011 3.063367034 -p -0.1887630641 -2.200473137e-011 3.063367034 -p 1.543865736 -2.200473137e-011 1.330820026 -p 1.543865736 -2.200473137e-011 -0.8064983814 -p 1.630778738 -2.200473137e-011 -0.8064983814 -p 2.239177558 -2.200473137e-011 -0.8064983814 -p 2.326090559 -2.200473137e-011 -0.8064983814 -p 2.121616706 -2.200473137e-011 -1.057259061 -p 0.6902813259 -2.200473137e-011 -2.812606361 -p 0.4858074759 -2.200473137e-011 -3.063367031 -p 0.2813336159 -2.200473137e-011 -2.812606361 -p -1.150001764 -2.200473137e-011 -1.057259061 -p -1.354475614 -2.200473137e-011 -0.8064983814 -p -1.266201474 -2.200473137e-011 -0.8064983814 -p -0.6482745541 -2.200473137e-011 -0.8064983814 -p -0.5600004141 -2.200473137e-011 -0.8064983814 -p -0.5600004141 -2.200473137e-011 0.1688425646 -p -1.350740524 -2.200473137e-011 0.9595917596 -p -2.326090564 -2.200473137e-011 0.9595917596", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[3] #curve#.cv[6] #curve#.cv[9] #curve#.cv[12] #curve#.cv[15] #curve#.cv[18] #curve#.cv[19]"}; break;
		case "fatDoubleArrow90": $aDirections = {"curve -d 3 -p -3.060813868 1.179754855e-016 1.432402043 -p -2.838593196 5.052405024e-017 1.613618563 -p -1.283028489 -4.21642067e-016 2.882150513 -p -1.060807817 -4.890935025e-016 3.063367033 -p -1.060807817 -4.718987969e-016 2.985928963 -p -1.060807817 -3.515343103e-016 2.443855513 -p -1.060807817 -3.343396048e-016 2.366417433 -p 0.833415054 -5.66307341e-016 2.366417433 -p 2.3689706 -4.134085079e-016 0.8309424326 -p 2.3689706 7.193461076e-018 -1.063280437 -p 2.445841307 -2.220174335e-018 -1.063280437 -p 2.983943161 -6.811646946e-017 -1.063280437 -p 3.060813868 -7.753010487e-017 -1.063280437 -p 2.879597349 -5.993326253e-018 -1.285510057 -p 1.611065401 4.947705624e-016 -2.841137417 -p 1.429848882 5.66307341e-016 -3.063367037 -p 1.248632363 5.391543426e-016 -2.841137417 -p -0.01989958496 3.490809105e-016 -1.285510057 -p -0.201116105 3.219279122e-016 -1.063280437 -p -0.122725865 3.123281935e-016 -1.063280437 -p 0.426012865 2.451293001e-016 -1.063280437 -p 0.504403105 2.355295816e-016 -1.063280437 -p 0.504403105 4.359347259e-017 -0.1988770474 -p -0.196404428 -2.619572342e-017 0.5019304826 -p -1.060807817 7.965966478e-017 0.5019304826 -p -1.060807817 9.694180139e-017 0.4240986526 -p -1.060807817 2.179183131e-016 -0.1207311174 -p -1.060807817 2.352004496e-016 -0.1985629374 -p -1.283028489 2.221755839e-016 -0.01734641742 -p -2.838593196 1.310003513e-016 1.251185533 -p -3.060813868 1.179754855e-016 1.432402043", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[3] #curve#.cv[6] #curve#.cv[9] #curve#.cv[12] #curve#.cv[15] #curve#.cv[18] #curve#.cv[21] #curve#.cv[24] #curve#.cv[27] #curve#.cv[28]"}; break;
		case "fatSingleArrow270": $aDirections = {"curve -d 3 -p -0.2812141605 -3.148292738e-011 2.782152878 -p 1.25536294 -3.148292738e-011 2.782152878 -p 2.50099752 -3.148292738e-011 1.536577096 -p 2.50099752 -3.148292738e-011 -4.989857416e-010 -p 2.5634824 -3.148292738e-011 -4.989857416e-010 -p 3.00088216 -3.148292738e-011 -4.989857416e-010 -p 3.06336703 -3.148292738e-011 -4.989857416e-010 -p 2.91636515 -3.148292738e-011 -0.1802787595 -p 1.8873387 -3.148292738e-011 -1.442246304 -p 1.74033682 -3.148292738e-011 -1.622525054 -p 1.59333493 -3.148292738e-011 -1.442246304 -p 0.5643084895 -3.148292738e-011 -0.1802787595 -p 0.4173065995 -3.148292738e-011 -4.989857416e-010 -p 0.4807693095 -3.148292738e-011 -4.989857416e-010 -p 0.9250139995 -3.148292738e-011 -4.989857416e-010 -p 0.9884767095 -3.148292738e-011 -4.989857416e-010 -p 0.9884767095 -3.148292738e-011 0.7011994815 -p 0.4199853295 -3.148292738e-011 1.269690867 -p -0.2812141605 -3.148292738e-011 1.269690867 -p -0.9824201705 -3.148292738e-011 1.269690867 -p -1.55090502 -3.148292738e-011 0.7011994815 -p -1.55090502 -3.148292738e-011 -4.989857416e-010 -p -1.55090502 -3.148292738e-011 -0.7012060165 -p -0.9824201705 -3.148292738e-011 -1.269690864 -p -0.2812141605 -3.148292738e-011 -1.269690864 -p -0.2812076205 -3.148292738e-011 -1.269690864 -p -0.2811618905 -3.148292738e-011 -1.269690864 -p -0.2811553505 -3.148292738e-011 -1.269690864 -p -0.2811553505 -3.148292738e-011 -1.437740524 -p -0.2811553505 -3.148292738e-011 -2.614103224 -p -0.2811553505 -3.148292738e-011 -2.782152874 -p -0.2811618905 -3.148292738e-011 -2.782152874 -p -0.2812076205 -3.148292738e-011 -2.782152874 -p -0.2812141605 -3.148292738e-011 -2.782152874 -p -1.81773245 -3.148292738e-011 -2.782152874 -p -3.06336703 -3.148292738e-011 -1.536583624 -p -3.06336703 -3.148292738e-011 -4.989857416e-010 -p -3.06336703 -3.148292738e-011 1.536577096 -p -1.81773245 -3.148292738e-011 2.782152878 -p -0.2812141605 -3.148292738e-011 2.782152878", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[3] #curve#.cv[6] #curve#.cv[9] #curve#.cv[12] #curve#.cv[15] #curve#.cv[24] #curve#.cv[27] #curve#.cv[30] #curve#.cv[33] #curve#.cv[37]"}; break;
		case "fatDoubleArrow180": $aDirections = {"curve -d 3 -p -2.549850278 4.030920297e-016 -0.5313460276 -p -2.549850278 9.044167586e-017 0.8767059824 -p -1.408405248 -3.02780154e-016 2.018097132 -p -0.0004071180271 -4.752045002e-016 2.018097132 -p 1.407644902 -6.476354449e-016 2.018097132 -p 2.549095922 -5.339785154e-016 0.8767059824 -p 2.549095922 -2.213281614e-016 -0.5313460276 -p 2.606236582 -2.283256433e-016 -0.5313460276 -p 3.006226372 -2.77308647e-016 -0.5313460276 -p 3.063367032 -2.843061289e-016 -0.5313460276 -p 2.928660932 -2.311297391e-016 -0.6965389476 -p 1.985706132 1.411097753e-016 -1.852904218 -p 1.851000032 1.942861652e-016 -2.018097128 -p 1.716293932 1.741021639e-016 -1.852904218 -p 0.773339122 3.281233915e-017 -0.6965389476 -p 0.638633032 1.262833797e-017 -0.5313460276 -p 0.696904562 5.492369428e-018 -0.5313460276 -p 1.104810512 -4.446005258e-017 -0.5313460276 -p 1.163082042 -5.159602112e-017 -0.5313460276 -p 1.163082042 -1.942704544e-016 0.1112024924 -p 0.642141412 -2.461477903e-016 0.6321431224 -p -0.0004071180271 -1.674608897e-016 0.6321431224 -p -0.642955638 -8.877398911e-017 0.6321431224 -p -1.163896268 9.069278792e-017 0.1112024924 -p -1.163896268 2.333672212e-016 -0.5313460276 -p -1.105534268 2.262201737e-016 -0.5313460276 -p -0.696995028 1.761901982e-016 -0.5313460276 -p -0.638633028 1.690431507e-016 -0.5313460276 -p -0.773339128 2.222195406e-016 -0.6965389476 -p -1.716293938 5.944590551e-016 -1.852904218 -p -1.851000028 6.476354449e-016 -2.018097128 -p -1.985706128 6.274514436e-016 -1.852904218 -p -2.928660938 4.861616188e-016 -0.6965389476 -p -3.063367038 4.659776176e-016 -0.5313460276 -p -3.006310188 4.589904e-016 -0.5313460276 -p -2.606907128 4.100792474e-016 -0.5313460276 -p -2.549850278 4.030920297e-016 -0.5313460276", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[6] #curve#.cv[9] #curve#.cv[12] #curve#.cv[15] #curve#.cv[18] #curve#.cv[24] #curve#.cv[27] #curve#.cv[30] #curve#.cv[33] #curve#.cv[34]"}; break;
		case "thinDoubleArrow90": $aDirections = {"curve -d 3 -p -3.063367032 4.090907554e-017 1.874772853 -p -2.878441742 -1.085171163e-017 2.005893884 -p -1.583948022 -3.731818804e-016 2.923752912 -p -1.399022722 -4.249426674e-016 3.054873945 -p -1.399022722 -4.082612299e-016 2.979747427 -p -1.399022722 -2.914896647e-016 2.453855052 -p -1.399022722 -2.748082272e-016 2.378728536 -p 0.6826911482 -5.297362304e-016 2.378728536 -p 2.370244298 -3.616928165e-016 0.6912196452 -p 2.370244298 1.005503449e-016 -1.390538484 -p 2.447257168 9.11193003e-017 -1.390538484 -p 2.986354168 2.510113912e-017 -1.390538484 -p 3.063367038 1.567009448e-017 -1.390538484 -p 2.932251898 7.278798285e-017 -1.575462797 -p 2.014434178 4.726183421e-016 -2.869949633 -p 1.883319048 5.297362304e-016 -3.054873945 -p 1.752202938 5.04731347e-016 -2.869949633 -p 0.8343783282 3.296949134e-016 -1.575462797 -p 0.7032622182 3.0469003e-016 -1.390538484 -p 0.7788116382 2.954382e-016 -1.390538484 -p 1.307664388 2.306745567e-016 -1.390538484 -p 1.383213808 2.214227266e-016 -1.390538484 -p 1.383213808 -1.197667172e-016 0.1460421682 -p 0.1375933382 -2.438478911e-016 1.391830813 -p -1.399022722 -5.567291231e-017 1.391830813 -p -1.399022722 -3.847544132e-017 1.314380288 -p -1.399022722 8.190840341e-017 0.7722196512 -p -1.399022722 9.910587441e-017 0.6947691282 -p -1.583948022 9.263962808e-017 0.8258793422 -p -2.878441742 4.737532186e-017 1.743662639 -p -3.063367032 4.090907554e-017 1.874772853", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[3] #curve#.cv[6] #curve#.cv[9] #curve#.cv[12] #curve#.cv[15] #curve#.cv[18] #curve#.cv[21] #curve#.cv[24] #curve#.cv[27] #curve#.cv[28]"}; break;
		case "thinDoubleArrow180": $aDirections = {"curve -d 3 -p -2.591409529 4.273810462e-016 -0.7229918082 -p -2.591409529 1.098415622e-016 0.7070788938 -p -1.432144185 -2.895233229e-016 1.866307753 -p -0.002079563647 -4.646499451e-016 1.866307753 -p 1.427960735 -6.397735887e-016 1.866307753 -p 2.587219999 -5.243367002e-016 0.7070788938 -p 2.587219999 -2.067972163e-016 -0.7229918082 -p 2.640124697 -2.13275959e-016 -0.7229918082 -p 3.010462336 -2.586277418e-016 -0.7229918082 -p 3.063367034 -2.651064846e-016 -0.7229918082 -p 2.973297439 -2.258693272e-016 -0.8500256432 -p 2.34280217 4.879430612e-017 -1.739273918 -p 2.252732575 8.803146352e-017 -1.866307753 -p 2.162662306 7.085434842e-017 -1.739273918 -p 1.532162307 -4.938700328e-017 -0.8500256432 -p 1.442092037 -6.656411839e-017 -0.7229918082 -p 1.493990068 -7.291958422e-017 -0.7229918082 -p 1.857280955 -1.17408417e-016 -0.7229918082 -p 1.909178985 -1.237638829e-016 -0.7229918082 -p 1.909178985 -3.581441145e-016 0.3325629158 -p 1.053505564 -4.433824738e-016 1.18835795 -p -0.002109966647 -3.141111253e-016 1.18835795 -p -1.057634288 -1.848509462e-016 1.18835795 -p -1.913398919 1.099712043e-016 0.3325629158 -p -1.913398919 3.443514361e-016 -0.7229918082 -p -1.86103201 3.379385512e-016 -0.7229918082 -p -1.494458945 2.930477806e-016 -0.7229918082 -p -1.442092038 2.86634896e-016 -0.7229918082 -p -1.532162308 3.258721361e-016 -0.8500256432 -p -2.162662306 6.005363486e-016 -1.739273918 -p -2.252732575 6.397735887e-016 -1.866307753 -p -2.342802171 6.225963908e-016 -1.739273918 -p -2.973297439 5.0235446e-016 -0.8500256432 -p -3.063367034 4.851772621e-016 -0.7229918082 -p -3.010927835 4.787555245e-016 -0.7229918082 -p -2.643848727 4.338027838e-016 -0.7229918082 -p -2.591409529 4.273810462e-016 -0.7229918082", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[6] #curve#.cv[9] #curve#.cv[12] #curve#.cv[15] #curve#.cv[18] #curve#.cv[24] #curve#.cv[27] #curve#.cv[30] #curve#.cv[33] #curve#.cv[34]"}; break;
		case "simpleCurve": $aDirections = {"curve -d 3 -p 3.063367034 -1.709225152e-016 -1.087462368 -p 2.246884025 6.39209748e-017 0.605570247 -p -0.01872220618 1.709225148e-016 1.087462369 -p -2.236037589 6.39209748e-017 0.605570247 -p -3.063367034 -1.670913752e-016 -1.070208424", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[2]"}; break;
		case "thinDoubleArrow270": $aDirections = {"curve -d 3 -p -0.2578941382 -6.229331569e-016 3.061370842 -p 1.291466872 -8.126688911e-016 3.061370842 -p 2.547447002 -6.87593405e-016 1.805390721 -p 2.547447002 -3.435515223e-016 0.2559638256 -p 2.604770872 -3.505714404e-016 0.2559638256 -p 3.006043162 -3.997114994e-016 0.2559638256 -p 3.063367032 -4.067314177e-016 0.2559638256 -p 2.965783002 -3.642198172e-016 0.1183275266 -p 2.282685992 -6.663478861e-017 -0.8451389604 -p 2.185101962 -2.412318822e-017 -0.9827752604 -p 2.087511342 -4.273357672e-017 -0.8451389604 -p 1.404368222 -1.730079712e-016 0.1183275266 -p 1.306777602 -1.916183596e-016 0.2559638256 -p 1.363007862 -1.985043535e-016 0.2559638256 -p 1.756624762 -2.467069293e-016 0.2559638256 -p 1.812855032 -2.535929229e-016 0.2559638256 -p 1.812855032 -5.075349371e-016 1.399616987 -p 0.8857590218 -5.998866317e-016 2.326838166 -p -0.2579600182 -4.598260711e-016 2.326838166 -p -1.401547298 -3.197816461e-016 2.326838166 -p -2.328768478 -3.490913742e-019 1.399616987 -p -2.328768478 2.535929229e-016 0.2559638256 -p -2.328768478 5.075349371e-016 -0.8876893344 -p -1.401547298 5.998713027e-016 -1.814910513 -p -0.2579600182 4.598268779e-016 -1.814910513 -p -0.2579526982 4.598259815e-016 -1.814910513 -p -0.2579014582 4.598197065e-016 -1.814910513 -p -0.2578941382 4.598188099e-016 -1.814910513 -p -0.2578941382 4.472332231e-016 -1.758230068 -p -0.2578941382 3.591329818e-016 -1.361461854 -p -0.2578941382 3.465473948e-016 -1.304781409 -p -0.1202578382 3.513618367e-016 -1.402372029 -p 0.8432086518 3.850633634e-016 -2.085515151 -p 0.9808449518 3.898778053e-016 -2.183105772 -p 0.8432086518 4.284008418e-016 -2.280689804 -p -0.1202578382 6.980655648e-016 -2.963786809 -p -0.2578941382 7.365886015e-016 -3.061370841 -p -0.2578941382 7.239586417e-016 -3.004490561 -p -0.2578941382 6.355477877e-016 -2.606323471 -p -0.2578941382 6.229178282e-016 -2.549443189 -p -1.807380328 8.126688911e-016 -2.549443189 -p -3.063367034 6.875927488e-016 -1.29345648 -p -3.063367034 3.43552329e-016 0.2559638256 -p -3.063367034 -4.895535629e-019 1.805390721 -p -1.807380328 -4.331820939e-016 3.061370842 -p -0.2578941382 -6.229331569e-016 3.061370842", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[3] #curve#.cv[6] #curve#.cv[9] #curve#.cv[12] #curve#.cv[15] #curve#.cv[24] #curve#.cv[27] #curve#.cv[30] #curve#.cv[33] #curve#.cv[39] #curve#.cv[43]"}; break;
		case "fatDoubleArrow270": $aDirections = {"curve -d 3 -p -0.2807658771 -6.169282019e-016 3.063367038 -p 1.253659593 -8.048349204e-016 3.063367038 -p 2.497532308 -6.809651377e-016 1.819494318 -p 2.497532308 -3.402397521e-016 0.2850035977 -p 2.559938601 -3.478820664e-016 0.2850035977 -p 2.99678827 -4.013789545e-016 0.2850035977 -p 3.059194563 -4.090212688e-016 0.2850035977 -p 2.9123929 -3.510684408e-016 0.1049703877 -p 1.884768046 5.460657017e-017 -1.155278282 -p 1.737966383 1.12559398e-016 -1.335311492 -p 1.591171971 9.056053226e-017 -1.155278282 -p 0.5635978629 -6.343350828e-017 0.1049703877 -p 0.4168034529 -8.543237408e-017 0.2850035977 -p 0.4801652229 -9.319169701e-017 0.2850035977 -p 0.9237033329 -1.475076559e-016 0.2850035977 -p 0.9870651029 -1.552669788e-016 0.2850035977 -p 0.9870651029 -3.107524722e-016 0.9852480077 -p 0.4194785329 -3.673039716e-016 1.552965078 -p -0.2807658771 -2.815515963e-016 1.552965078 -p -0.9810102971 -1.957992208e-016 1.552965078 -p -1.548727357 -2.177156812e-019 0.9852480077 -p -1.548727357 1.552677778e-016 0.2850035977 -p -1.548727357 3.107532714e-016 -0.4152408123 -p -0.9810102971 3.672887906e-016 -0.9829578823 -p -0.2807658771 2.815364151e-016 -0.9829578823 -p -0.2807658771 2.676699372e-016 -0.9205088123 -p -0.2807658771 1.706033434e-016 -0.4833597423 -p -0.2807658771 1.567368655e-016 -0.4209106723 -p -0.1007399171 1.672872892e-016 -0.5677123423 -p 1.159458003 2.411412052e-016 -1.595337192 -p 1.339483965 2.51691629e-016 -1.742138852 -p 1.159458003 3.063342397e-016 -1.888940512 -p -0.1007399171 6.888374329e-016 -2.916565372 -p -0.2807658771 7.434800438e-016 -3.063367032 -p -0.2807658771 7.294171818e-016 -3.000033532 -p -0.2807658771 6.309758828e-016 -2.556693342 -p -0.2807658771 6.169130209e-016 -2.493359832 -p -1.815315317 8.048349204e-016 -2.493359832 -p -3.059194567 6.809644878e-016 -1.249480592 -p -3.059194567 3.402405511e-016 0.2850035977 -p -3.059194567 -4.848343614e-019 1.819494318 -p -1.815315317 -4.290063025e-016 3.063367038 -p -0.2807658771 -6.169282019e-016 3.063367038", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[3] #curve#.cv[6] #curve#.cv[9] #curve#.cv[12] #curve#.cv[15] #curve#.cv[24] #curve#.cv[27] #curve#.cv[30] #curve#.cv[33] #curve#.cv[36] #curve#.cv[40]"}; break;
		case "fatSingleArrow180": $aDirections = {"curve -d 3 -p -0.2812141562 -3.85148019e-016 2.202338972 -p 1.255362938 -5.733182263e-016 2.202338972 -p 2.50099752 -4.492860465e-016 0.9567631815 -p 2.50099752 -1.080973925e-016 -0.5798139085 -p 2.563482399 -1.157493302e-016 -0.5798139085 -p 3.000882157 -1.693135825e-016 -0.5798139085 -p 3.063367034 -1.769655201e-016 -0.5798139085 -p 2.916365145 -1.189336497e-016 -0.7600926685 -p 1.887338702 2.872946659e-016 -2.022060208 -p 1.740336816 3.453265364e-016 -2.202338968 -p 1.593334927 3.232985551e-016 -2.022060208 -p 0.5643084848 1.691007033e-016 -0.7600926685 -p 0.4173065978 1.47072722e-016 -0.5798139085 -p 0.4807693088 1.39301038e-016 -0.5798139085 -p 0.9250139978 8.489855108e-017 -0.5798139085 -p 0.9884767088 7.712686716e-017 -0.5798139085 -p 0.9884767088 -7.857069474e-017 0.1213855715 -p 0.4199853248 -1.351833234e-016 0.6898769515 -p -0.2812141562 -4.931398936e-017 0.6898769515 -p -0.9824201722 3.655614479e-017 0.6898769515 -p -1.550905022 2.324036056e-016 0.1213855715 -p -1.550905022 3.881011674e-016 -0.5798139085 -p -1.718954676 4.08680635e-016 -0.5798139085 -p -2.895317379 5.527387589e-016 -0.5798139085 -p -3.063367034 5.733182263e-016 -0.5798139085 -p -3.063367034 2.321295724e-016 0.9567631815 -p -1.81773245 -1.969850124e-016 2.202338972 -p -0.2812141562 -3.85148019e-016 2.202338972", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[3] #curve#.cv[6] #curve#.cv[9] #curve#.cv[12] #curve#.cv[15] #curve#.cv[21] #curve#.cv[24] #curve#.cv[25]"}; break;
		case "gear_1": $aDirections = {"curve -d 3 -p 4.577988718 7.027510647e-018 -9.058539896e-009 -p 4.576689914 7.027510647e-018 -0.1546324616 -p 4.571252203 7.027510647e-018 -0.3598313912 -p 4.551336266 7.027510647e-018 -0.5615153151 -p 4.501390514 7.027510647e-018 -0.8310340231 -p 4.432571096 7.027510647e-018 -0.8448935361 -p 3.950828973 7.027510647e-018 -0.941911367 -p 3.882009555 7.027510647e-018 -0.9557708699 -p 3.785185297 7.027510647e-018 -1.350530015 -p 3.630246863 7.027510647e-018 -1.722490825 -p 3.425872793 7.027510647e-018 -2.061431318 -p 3.465001771 7.027510647e-018 -2.11959941 -p 3.738908133 7.027510647e-018 -2.526781298 -p 3.77803711 7.027510647e-018 -2.58494939 -p 3.620986264 7.027510647e-018 -2.81493398 -p 3.441457543 7.027510647e-018 -3.034251887 -p 3.237338533 7.027510647e-018 -3.238370891 -p 3.036476428 7.027510647e-018 -3.439233004 -p 2.82092555 7.027510647e-018 -3.616080332 -p 2.595028439 7.027510647e-018 -3.771339225 -p 2.536604563 7.027510647e-018 -3.732501637 -p 2.127632171 7.027510647e-018 -3.460635029 -p 2.069208294 7.027510647e-018 -3.42179744 -p 1.730719057 7.027510647e-018 -3.627067484 -p 1.35907217 7.027510647e-018 -3.782901898 -p 0.9645026871 7.027510647e-018 -3.880746389 -p 0.9510413832 7.027510647e-018 -3.949558544 -p 0.8568110432 7.027510647e-018 -4.431249797 -p 0.8433497392 7.027510647e-018 -4.500061952 -p 0.5696781459 7.027510647e-018 -4.551603453 -p 0.2876419308 7.027510647e-018 -4.579764559 -p -0.001032354015 7.027510647e-018 -4.579764559 -p -0.2851155798 7.027510647e-018 -4.579764559 -p -0.5625541958 7.027510647e-018 -4.552368623 -p -0.8320729079 7.027510647e-018 -4.502422873 -p -0.8459316929 7.027510647e-018 -4.433596188 -p -0.9429444348 7.027510647e-018 -3.951803204 -p -0.9568032196 7.027510647e-018 -3.882976519 -p -1.351562361 7.027510647e-018 -3.786158799 -p -1.723457767 7.027510647e-018 -3.631213825 -p -2.062463663 7.027510647e-018 -3.426905151 -p -2.120631756 7.027510647e-018 -3.46603413 -p -2.527813644 7.027510647e-018 -3.739940499 -p -2.585981737 7.027510647e-018 -3.779069467 -p -2.81596633 7.027510647e-018 -3.622018623 -p -3.035284231 7.027510647e-018 -3.442489905 -p -3.239403241 7.027510647e-018 -3.238370891 -p -3.440265346 7.027510647e-018 -3.037508788 -p -3.61711268 7.027510647e-018 -2.821957911 -p -3.772371572 7.027510647e-018 -2.596060803 -p -3.733533985 7.027510647e-018 -2.53763765 -p -3.461667373 7.027510647e-018 -2.128670342 -p -3.422829785 7.027510647e-018 -2.070247199 -p -3.62809983 7.027510647e-018 -1.731751417 -p -3.78393424 7.027510647e-018 -1.360111077 -p -3.881778734 7.027510647e-018 -0.965541592 -p -3.950590886 7.027510647e-018 -0.9520795592 -p -4.43228214 7.027510647e-018 -0.8578441289 -p -4.501094292 7.027510647e-018 -0.844382106 -p -4.552635798 7.027510647e-018 -0.5707170471 -p -4.580223127 7.027510647e-018 -0.2944914699 -p -4.580791493 7.027510647e-018 -0.06727390314 -p -4.580802464 7.027510647e-018 -8.297127473e-009 -p -4.578761162 7.027510647e-018 0.1546324436 -p -4.573323451 7.027510647e-018 0.3598313732 -p -4.553407514 7.027510647e-018 0.5615152971 -p -4.503461762 7.027510647e-018 0.8310340051 -p -4.434642344 7.027510647e-018 0.8448935181 -p -3.952900221 7.027510647e-018 0.941911349 -p -3.884080803 7.027510647e-018 0.9557708519 -p -3.787256545 7.027510647e-018 1.350529997 -p -3.632318111 7.027510647e-018 1.722490807 -p -3.427944041 7.027510647e-018 2.0614313 -p -3.467073019 7.027510647e-018 2.119599392 -p -3.740979381 7.027510647e-018 2.52678128 -p -3.780108358 7.027510647e-018 2.584949372 -p -3.623057512 7.027510647e-018 2.814933962 -p -3.443528791 7.027510647e-018 3.034251869 -p -3.239409781 7.027510647e-018 3.238370873 -p -3.038547676 7.027510647e-018 3.439232986 -p -2.822996798 7.027510647e-018 3.616080314 -p -2.597099687 7.027510647e-018 3.771339207 -p -2.538675811 7.027510647e-018 3.732501619 -p -2.129703419 7.027510647e-018 3.460635011 -p -2.071279542 7.027510647e-018 3.421797422 -p -1.732790305 7.027510647e-018 3.627067466 -p -1.361143418 7.027510647e-018 3.78290188 -p -0.9665739351 7.027510647e-018 3.880746371 -p -0.9531126312 7.027510647e-018 3.949558526 -p -0.8588822912 7.027510647e-018 4.431249779 -p -0.8454209872 7.027510647e-018 4.500061934 -p -0.5717493939 7.027510647e-018 4.551603435 -p -0.2897131788 7.027510647e-018 4.579764541 -p -0.001038893985 7.027510647e-018 4.579764541 -p 0.2830443318 7.027510647e-018 4.579764541 -p 0.5604829478 7.027510647e-018 4.552368605 -p 0.8300016599 7.027510647e-018 4.502422855 -p 0.8438604449 7.027510647e-018 4.43359617 -p 0.9408731868 7.027510647e-018 3.951803186 -p 0.9547319716 7.027510647e-018 3.882976501 -p 1.349491113 7.027510647e-018 3.786158781 -p 1.721386519 7.027510647e-018 3.631213807 -p 2.060392415 7.027510647e-018 3.426905133 -p 2.118560508 7.027510647e-018 3.466034112 -p 2.525742396 7.027510647e-018 3.739940481 -p 2.583910489 7.027510647e-018 3.779069449 -p 2.813895082 7.027510647e-018 3.622018605 -p 3.033212983 7.027510647e-018 3.442489887 -p 3.237331993 7.027510647e-018 3.238370873 -p 3.438194098 7.027510647e-018 3.03750877 -p 3.615041432 7.027510647e-018 2.821957893 -p 3.770300324 7.027510647e-018 2.596060785 -p 3.731462737 7.027510647e-018 2.537637632 -p 3.459596125 7.027510647e-018 2.128670324 -p 3.420758537 7.027510647e-018 2.070247181 -p 3.626028582 7.027510647e-018 1.731751399 -p 3.781862992 7.027510647e-018 1.360111059 -p 3.879707486 7.027510647e-018 0.965541574 -p 3.948519638 7.027510647e-018 0.9520795412 -p 4.430210892 7.027510647e-018 0.8578441109 -p 4.499023044 7.027510647e-018 0.844382088 -p 4.55056455 7.027510647e-018 0.5707170291 -p 4.578151879 7.027510647e-018 0.2944914519 -p 4.578720245 7.027510647e-018 0.06727388514 -p 4.578731216 7.027510647e-018 -9.702872568e-009", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[4] #curve#.cv[7] #curve#.cv[10] #curve#.cv[13] #curve#.cv[19] #curve#.cv[22] #curve#.cv[25] #curve#.cv[28] #curve#.cv[34] #curve#.cv[37] #curve#.cv[40] #curve#.cv[43] #curve#.cv[49] #curve#.cv[52] #curve#.cv[55] #curve#.cv[58] #curve#.cv[66] #curve#.cv[69] #curve#.cv[72] #curve#.cv[75] #curve#.cv[81] #curve#.cv[84] #curve#.cv[87] #curve#.cv[90] #curve#.cv[96] #curve#.cv[99] #curve#.cv[102] #curve#.cv[105] #curve#.cv[111] #curve#.cv[114] #curve#.cv[117] #curve#.cv[120] #curve#.cv[122]"}; break;
		case "gear_2": $aDirections = {"curve -d 3 -p -4.579774414 -2.952374177e-018 -2.906887175e-009 -p -4.57977322 -2.952374177e-018 -0.06173834291 -p -4.579207383 -2.952374177e-018 -0.2703723829 -p -4.553823451 -2.952374177e-018 -0.5239470929 -p -4.506505744 -2.952374177e-018 -0.7751314029 -p -4.399384367 -2.952374177e-018 -0.7961019129 -p -3.64952509 -2.952374177e-018 -0.9428973629 -p -3.542403713 -2.952374177e-018 -0.9638678729 -p -3.459266004 -2.952374177e-018 -1.270049043 -p -3.337426361 -2.952374177e-018 -1.560049373 -p -3.182630635 -2.952374177e-018 -1.828879503 -p -3.243178602 -2.952374177e-018 -1.919962303 -p -3.667019821 -2.952374177e-018 -2.557550013 -p -3.727567789 -2.952374177e-018 -2.648632813 -p -3.585032278 -2.952374177e-018 -2.856017773 -p -3.422677487 -2.952374177e-018 -3.053904383 -p -3.238396003 -2.952374177e-018 -3.238359983 -p -3.050944394 -2.952374177e-018 -3.425751543 -p -2.849539435 -2.952374177e-018 -3.590513943 -p -2.638461995 -2.952374177e-018 -3.734688563 -p -2.547835506 -2.952374177e-018 -3.673730323 -p -1.913441931 -2.952374177e-018 -3.247017163 -p -1.822815442 -2.952374177e-018 -3.186058933 -p -1.553691106 -2.952374177e-018 -3.340380333 -p -1.263456624 -2.952374177e-018 -3.461697633 -p -0.9571013403 -2.952374177e-018 -3.544252953 -p -0.9355244308 -2.952374177e-018 -3.651407013 -p -0.7844841229 -2.952374177e-018 -4.401495113 -p -0.7629072135 -2.952374177e-018 -4.508649183 -p -0.5154754129 -2.952374177e-018 -4.554495903 -p -0.2607127002 -2.952374177e-018 -4.579652763 -p 2.401569678e-005 -2.952374177e-018 -4.579766843 -p 0.2650476046 -2.952374177e-018 -4.579706803 -p 0.524031146 -2.952374177e-018 -4.553793433 -p 0.7752154612 -2.952374177e-018 -4.506475723 -p 0.7961799656 -2.952374177e-018 -4.399347683 -p 0.9429333894 -2.952374177e-018 -3.649441703 -p 0.9638978938 -2.952374177e-018 -3.542313653 -p 1.270079062 -2.952374177e-018 -3.459175943 -p 1.560073384 -2.952374177e-018 -3.337390343 -p 1.828909526 -2.952374177e-018 -3.182540573 -p 1.851270878 -2.952374177e-018 -3.200559333 -p 2.663480871 -2.952374177e-018 -3.762597593 -p 2.648716868 -2.952374177e-018 -3.727537763 -p 2.856101838 -2.952374177e-018 -3.585002263 -p 3.053988435 -2.952374177e-018 -3.422647463 -p 3.238444033 -2.952374177e-018 -3.238359983 -p 3.425781571 -2.952374177e-018 -3.050914373 -p 3.590598011 -2.952374177e-018 -2.849509413 -p 3.734772616 -2.952374177e-018 -2.638425963 -p 3.673815047 -2.952374177e-018 -2.547800153 -p 3.24710656 -2.952374177e-018 -1.913411243 -p 3.186148991 -2.952374177e-018 -1.822785423 -p 3.340410362 -2.952374177e-018 -1.553661083 -p 3.461781687 -2.952374177e-018 -1.263426603 -p 3.544337008 -2.952374177e-018 -0.9570653129 -p 3.561327003 -2.952374177e-018 -0.9354890729 -p 4.501986698 -2.952374177e-018 -0.813135518 -p 4.502831694 -2.952374177e-018 -0.8056815844 -p 4.554579959 -2.952374177e-018 -0.5154453929 -p 4.572866163 -2.952374177e-018 -0.3302615529 -p 4.577892077 -2.952374177e-018 -0.1419180829 -p 4.579083998 -2.952374177e-018 -2.906887175e-009 -p 4.577892077 -5.576777137e-016 0.1419180771 -p 4.572866163 -5.570622168e-016 0.3302615571 -p 4.554579959 -5.548228027e-016 0.5154453971 -p 4.508733239 -5.492081987e-016 0.7628771971 -p 4.401579177 -5.360856108e-016 0.7844534371 -p 3.651491071 -4.442263109e-016 0.9354890771 -p 3.544337008 -4.31103723e-016 0.9570653171 -p 3.461781687 -4.209936121e-016 1.263426607 -p 3.340410362 -4.061299115e-016 1.553661087 -p 3.186148991 -3.872383421e-016 1.822785417 -p 3.24710656 -3.947034914e-016 1.913411247 -p 3.673815047 -4.469602095e-016 2.547800157 -p 3.734772616 -4.544253588e-016 2.638425967 -p 3.590598011 -4.367690619e-016 2.849509407 -p 3.425781571 -4.165848694e-016 3.050914367 -p 3.238444033 -3.936426377e-016 3.238359977 -p 3.053988435 -3.710533419e-016 3.422647467 -p 2.856101838 -3.468192231e-016 3.585002257 -p 2.648716868 -3.214218893e-016 3.727537767 -p 2.557628071 -3.102667289e-016 3.666983127 -p 1.919998323 -2.321796058e-016 3.243095207 -p 1.828909526 -2.210244454e-016 3.182540577 -p 1.560073384 -1.881015133e-016 3.337390337 -p 1.270079062 -1.525874515e-016 3.459175947 -p 0.9638978938 -1.150910729e-016 3.542313647 -p 0.9429333894 -1.125236616e-016 3.649441707 -p 0.7961799656 -9.455155047e-017 4.399347677 -p 0.7752154612 -9.198413915e-017 4.506475717 -p 0.524031146 -6.122293238e-017 4.553793427 -p 0.2650476046 -2.950659588e-017 4.579706797 -p 2.401569678e-005 2.949433102e-018 4.579766837 -p -0.2607127002 3.488047155e-017 4.579652757 -p -0.5154754129 6.607990561e-017 4.554495907 -p -0.7629072135 9.638156188e-017 4.508649187 -p -0.7844841229 9.902397118e-017 4.401495107 -p -0.9355244308 1.175210741e-016 3.651407017 -p -0.9571013403 1.201634834e-016 3.544252957 -p -1.263456624 1.576811852e-016 3.461697637 -p -1.553691106 1.932246582e-016 3.340380337 -p -1.822815442 2.261828838e-016 3.186058937 -p -1.913441931 2.372814278e-016 3.247017167 -p -2.547835506 3.14972234e-016 3.673730327 -p -2.638461995 3.260707779e-016 3.734688557 -p -2.849539435 3.51920309e-016 3.590513947 -p -3.050944394 3.765853028e-016 3.425751547 -p -3.238396003 3.995415042e-016 3.238359977 -p -3.422677487 4.221094772e-016 3.053904377 -p -3.585032278 4.419922047e-016 2.856017777 -p -3.727567789 4.594477704e-016 2.648632817 -p -3.667019821 4.520327829e-016 2.557550017 -p -3.243178602 4.001272036e-016 1.919962297 -p -3.182630635 3.927122162e-016 1.828879497 -p -3.337426361 4.116692253e-016 1.560049367 -p -3.459266004 4.265902781e-016 1.270049037 -p -3.542403713 4.367717111e-016 0.9638678771 -p -3.64952509 4.498902961e-016 0.9428973671 -p -4.399384367 5.417215726e-016 0.7961019171 -p -4.506505744 5.548401578e-016 0.7751314071 -p -4.553823451 5.606349056e-016 0.5239470871 -p -4.579207383 5.637435406e-016 0.2703723771 -p -4.57977322 5.638128357e-016 0.06173834709 -p -4.579774414 5.638129819e-016 -2.906887175e-009", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[4] #curve#.cv[7] #curve#.cv[10] #curve#.cv[13] #curve#.cv[19] #curve#.cv[22] #curve#.cv[25] #curve#.cv[28] #curve#.cv[34] #curve#.cv[37] #curve#.cv[41] #curve#.cv[49] #curve#.cv[52] #curve#.cv[56] #curve#.cv[66] #curve#.cv[69] #curve#.cv[72] #curve#.cv[75] #curve#.cv[81] #curve#.cv[84] #curve#.cv[87] #curve#.cv[90] #curve#.cv[96] #curve#.cv[99] #curve#.cv[102] #curve#.cv[105] #curve#.cv[111] #curve#.cv[114] #curve#.cv[117] #curve#.cv[120] #curve#.cv[122]"}; break;
		case "twister_1": $aDirections = {"curve -d 3 -p -3.882195339 -2.271264228e-018 0.9483681849 -p -3.706821028 -7.43774169e-018 1.654243365 -p -2.8151418 -4.871295972e-017 3.266314405 -p -1.316048505e-015 -4.78563093e-016 4.432384325 -p 3.134169011 0 3.134169015 -p 4.432384322 0 4.866528514e-009 -p 3.125948178 0 -3.111551836 -p 0.2752827464 4.78563093e-016 -4.243907369 -p -3.048807341 4.871295972e-017 -3.475016049 -p -3.706821028 7.43774169e-018 -1.654243365 -p -3.882195339 2.271264228e-018 -0.9483681851 -p -4.119090859 0 -0.9483681851 -p -4.355986379 0 -0.9483681851 -p -4.592881899 0 -0.9483681851 -p -4.65871479 0 -0.6364327951 -p -4.727149358 0 4.866528514e-009 -p -4.65871479 0 0.6364327949 -p -4.592881899 -1.637218657e-018 0.9483681849 -p -4.355986379 0 0.9483681849 -p -4.119090859 0 0.9483681849 -p -3.882195339 0 0.9483681849", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[10] #curve#.cv[13] #curve#.cv[17] #curve#.cv[18]"}; break;
		case "twister_2": $aDirections = {"curve -d 3 -p -4.36119742 6.511254951e-018 -1.753602207 -p -4.521578074 0 -1.188947747 -p -4.692305659 0 3.168800333e-009 -p -4.521578074 0 1.188947743 -p -4.36119742 -6.511254951e-018 1.753602203 -p -4.126670701 0 1.728745493 -p -3.89214398 0 1.705871203 -p -3.657617259 0 1.683696693 -p -3.45902652 -2.424549044e-017 2.116440293 -p -2.580547398 -8.829575284e-017 3.398330293 -p -1.326394178e-015 -4.823251558e-016 4.467228023 -p 3.158807227 0 3.111526511 -p 4.457378137 0 -0.01806781144 -p 3.099673763 0 -3.226348029 -p 0.3162523331 4.823251558e-016 -4.266864265 -p -2.768673784 8.829575284e-017 -3.616424423 -p -3.45902652 2.424549044e-017 -2.116440297 -p -3.657617261 1.331533598e-017 -1.683696697 -p -3.89214398 0 -1.705871207 -p -4.126670701 0 -1.728745497 -p -4.36119742 0 -1.753602197", "hardenPointCurve -ch 1 -rpo 1 -m 1 #curve#.cv[0] #curve#.cv[4] #curve#.cv[7] #curve#.cv[17] #curve#.cv[18]"}; break;
		
	}
	
	if (size($aDirections) > 0){
		
		$directions = $aDirections[0];
		
		if (size($aDirections) >= 2)
			$hardness = $aDirections[1];
		
		string $tWire = eval($directions);
		
		// now do hardness
		if ($hardness != ""){
			$hardness = substituteAllString($hardness, "#curve#", $tWire);
			eval ($hardness);
		}
		
		if ($facingAxis == 0){
			$aRot = {-90, -90, 0};
		}else if ($facingAxis == 2){
			$aRot = {90, -180, 0};
		}else if ($facingAxis == 3){
			$aRot = {-90, 90, 0};
		}else if ($facingAxis == 4){
			$aRot = {-180, 0, 0};
		}else if ($facingAxis == 5){
			$aRot = {-90, 180, 0};
		}
		
		if (size($aRot) == 3){
			
			$spcFlg = ($useWS) ? "-ws" : "-os";
			$cmdStr = "rotate -r "+$spcFlg+" "+$aRot[0]+" "+$aRot[1]+" "+$aRot[2]+" "+$tWire;
			eval($cmdStr);
		}
		
		if ($size != 0){
			
			string $scaleStr = abRTGetGlobal("globalScale");
			
			if ($scaleStr == "")
				$scaleStr = "1";
			
			float $gScale = float($scaleStr);
			float $maxDim = abRTGetMaxDim($tWire);
			float $scale = ($size/$maxDim)*$gScale;
			
			scale -relative $scale $scale $scale $tWire;
		}
		
		if (size($aOffset) == 3){
			
			if ($useWS)
				xform -ws -t $aOffset[0] $aOffset[1] $aOffset[2] $tWire;
			else
				xform -os -t $aOffset[0] $aOffset[1] $aOffset[2] $tWire;
		}
		
		makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $tWire;
		
		if ($getIns){
			$aStr = re_getCurvePointInfo($tWire, true);
			
			delete $tWire;
			
			$directions = $aStr[0];
			$aRet[0] = $directions;
			
			if (size($aStr) >= 2){
				$hardness = $aStr[1];
				$aRet[1] = $hardness;
			}
		}else{
			$aRet[0] = $tWire;
		}
	}
	
	return $aRet;
}


global proc abRTRotateWire(string $wire, float $aRot[]){
	// rotates wire shape by aRot degrees {xRot, yRot, zRot} without actually transforming wire itself
	
	string $aStr[], $tWire, $directions, $hardness, $replaceCmd, $aStr[];
	
	if (size($aRot) != 3)
		return;
	
	// dup wire
	$aStr = `duplicate $wire`;
	$tWire = $aStr[0];
	
	// center the pivot
	xform -centerPivots $tWire;
	
	// rotate it
	abRTShowAttr($tWire, {"rx","ry","rz"});
	float $aCurRot[] = `getAttr ($tWire+".r")`;
	setAttr ($tWire+".r") ($aCurRot[0]+$aRot[0]) ($aCurRot[1]+$aRot[1]) ($aCurRot[2]+$aRot[2]);
	
	// get curve instructions
	$aStr = re_getCurvePointInfo($tWire, true);
	$directions = $aStr[0];
	$hardness = $aStr[1];
	
	delete $tWire;
	
	// build it
	$replaceCmd = `substitute "curve -d" $directions "curve -r -ws -d"`;
	$replaceCmd += " "+$wire;
	eval ($replaceCmd);
	
	// now do hardness
	if ($hardness != ""){
		$hardness = substituteAllString($hardness, "#curve#", $wire);
		eval ($hardness);
	}
	
}


global proc abRTWireReplaceUI(){
	// replace existing wires on a rig
	
	
	if (`window -exists abRTWrRplcWin`)
		deleteUI -window abRTWrRplcWin;
	
	int $width = 168;
	
	window -t "abWireReplace" -w $width -h 634 -minimizeButton false -maximizeButton false abRTWrRplcWin;
	
	int $lmargin = 3;
	int $rmargin = 3;
	int $bnGridSpc = 1;
	
	
	formLayout -numberOfDivisions 100 abTRWrRplcForm;
	
	string $aWireTypes[] = {"flattenedCircle","simpleCurve","fatArrow","medArrow","fatFourWayArrowMed","fatFourWayArrow","fatFoutWayArrowSmall_1","twoWayArrow","medTwoWayArrow","fatCross","medCross","fatDoubleArrow180","fatDoubleArrow90","fatSingleArrow90","fatSingleArrow180","fatSingleArrow270","thinDoubleArrow90","thinDoubleArrow180","thinSingleArrow90","thinSingleArrow180","thinSingleArrow270","thinDoubleArrow270","fatDoubleArrow270","hexagon","pentagon","triangle","square","rightFoot","pyramid","diamond","wedge","cone","cube","circle","sphere","fourWayArrowCurved","leftFoot","eyeHolder_2","leftEye_2","rightEye_2","eyeHolder_1","leftEye_1","rightEye_1","bloatedTriangle","star","star1","star2","star3","twister_1","twister_2","gear_1","gear_2"};
	$aWireTypes = sort($aWireTypes);
	string $wireName;
	
	
	textScrollList -allowMultiSelection false -dcc "abRTServiceWireReplaceUI(\"Replace\");" abRTWRWireTypeTxtScrllLst;
	
	for ($wireName in $aWireTypes)
		textScrollList -e -append $wireName abRTWRWireTypeTxtScrllLst;
	
	textScrollList -e -sii 1 abRTWRWireTypeTxtScrllLst;
	
	button -l "Replace Selected" -h 28 -c "checkBox -e -v true abRTWRReplacedInPlaceChkBx;abRTServiceWireReplaceUI(\"Replace\");" -ann "Replace the selected curves with the style selected in the wire shape list." abRTWRReplaceBn;
	checkBox -manage false -v true abRTWRReplacedInPlaceChkBx; // used to track which replace button was pushed last
	
	separator abRTWRSep;
	
	button -l "Center On Pivot" -c "abRTServiceWireReplaceUI(\"CenterOnPivot\");" -ann "Center the selected wires on their pivots." abRTWRCenterOnPivBn;
	button -l "Center On Object" -c "abRTServiceWireReplaceUI(\"CenterOnObject\");" -ann "Center a single selected wire on the selected target object.  Select the target object first." abRTWRCenterOnObjBn;
	button -l "Make Wire Loc" -c "abRTServiceWireReplaceUI(\"MakeCurveLoc\");" -ann "Creates a loc at each selected wire which can then be used in conjunction with \"Center On Pivot\" to adjust its position." abRTWRMkCrvLocBn;
	
	separator abRTWRSep1;
	
	button -l "Copy From To (Absolute)" -c "abRTServiceWireReplaceUI(\"Copy\");" -ann "Replace the selected wire with selected curve." abRTWRCopyBn;
	button -l "Copy From To (Relative)" -c "abRTServiceWireReplaceUI(\"ObjSpaceCopy\");" -ann "Replace the selected wires with the first control in the selection list using objectSpace.  Use to copy from one custom control to many (with the finger controls, for example)." abRTWRObjSpcCopyBn;
	
	separator abRTWRSep5;
	
	button -l "Mirror From To" -c "abRTServiceWireReplaceUI(\"MirrorFromTo\");" -ann "Mirror from the first selected wire to the second." abRTWRMirrorFromToBn;
	button -l "Mirror Selected" -c "abRTServiceWireReplaceUI(\"Mirror\");" -ann "Mirror the selected wires to their mirror controls." abRTWRMirrorBn;
	
	separator abRTWRSep2;
	
	text -label "Wire Scale" abRTWRScaleTxt;
	string $cmd = "string $abRTTempStr[] = `ls -sl`; string $aScrollListSel[] = `textScrollList -q -si abRTWRWireTypeTxtScrllLst`; if (size($aScrollListSel) > 0 && size($abRTTempStr) > 0) abRTServiceWireReplaceUI(\"ScaleSliderReplace\");";
	floatField -min 1 -v 100 -step .5 -changeCommand $cmd -dragCommand $cmd abRTWRScaleFltFld;
	
	separator abRTWRSep3;
	
	floatFieldGrp -numberOfFields 3 -cw3 51 51 51 -value1 0.0 -value2 0.0 -value3 0.0 abRTWRRotateFltFldGrp;
	button -l "Rotate Selected" -c "abRTServiceWireReplaceUI(\"Rotate\");" abRTWRRotateBn;
	
	separator abRTWRSep4;
	
	text -label "Set Wire Facing Axis" abRTWRFacingTxt;
	button -label "+X" -c "abRTServiceWireReplaceUI(\"SetWireFacingPosX\");" abRTWRFacingXPosBn;
	button -label "+Y" -c "abRTServiceWireReplaceUI(\"SetWireFacingPosY\");" abRTWRFacingYPosBn;
	button -label "+Z" -c "abRTServiceWireReplaceUI(\"SetWireFacingPosZ\");" abRTWRFacingZPosBn;
	button -label "-X" -c "abRTServiceWireReplaceUI(\"SetWireFacingNegX\");" abRTWRFacingXNegBn;
	button -label "-Y" -c "abRTServiceWireReplaceUI(\"SetWireFacingNegY\");" abRTWRFacingYNegBn;
	button -label "-Z" -c "abRTServiceWireReplaceUI(\"SetWireFacingNegZ\");" abRTWRFacingZNegBn;
	
	
	formLayout -e
	
	-af abRTWRFacingXNegBn "bottom" 5
	-af abRTWRFacingXNegBn "left" $lmargin
	-ap abRTWRFacingXNegBn "right" $bnGridSpc 33
	
	-af abRTWRFacingYNegBn "bottom" 5
	-ac abRTWRFacingYNegBn "left" $bnGridSpc abRTWRFacingXNegBn
	-ap abRTWRFacingYNegBn "right" $bnGridSpc 66
	
	-af abRTWRFacingZNegBn "bottom" 5
	-ac abRTWRFacingZNegBn "left" $bnGridSpc abRTWRFacingYNegBn
	-af abRTWRFacingZNegBn "right" $rmargin
	
	-ac abRTWRFacingXPosBn "bottom" 2 abRTWRFacingXNegBn
	-af abRTWRFacingXPosBn "left" $lmargin
	-ap abRTWRFacingXPosBn "right" $bnGridSpc 33
	
	-ac abRTWRFacingYPosBn "bottom" 2 abRTWRFacingYNegBn
	-ac abRTWRFacingYPosBn "left" $bnGridSpc abRTWRFacingXPosBn
	-ap abRTWRFacingYPosBn "right" $bnGridSpc 66
	
	-ac abRTWRFacingZPosBn "bottom" 2 abRTWRFacingZNegBn
	-ac abRTWRFacingZPosBn "left" $bnGridSpc abRTWRFacingYPosBn
	-af abRTWRFacingZPosBn "right" $rmargin
	
	-ac abRTWRFacingTxt "bottom" 7 abRTWRFacingXPosBn
	-af abRTWRFacingTxt "left" $lmargin
	-af abRTWRFacingTxt "right" $rmargin
	
	-ac abRTWRSep4 "bottom" 5 abRTWRFacingTxt
	-af abRTWRSep4 "left" 5
	-af abRTWRSep4 "right" $rmargin
	
	-ac abRTWRRotateBn "bottom" 4 abRTWRSep4
	-af abRTWRRotateBn "left" 5
	-af abRTWRRotateBn "right" $rmargin
	
	-ac abRTWRRotateFltFldGrp "bottom" 4 abRTWRRotateBn
	-af abRTWRRotateFltFldGrp "left" 5
	-af abRTWRRotateFltFldGrp "right" $rmargin
	
	-ac abRTWRSep3 "bottom" 4 abRTWRRotateFltFldGrp
	-af abRTWRSep3 "left" $lmargin
	-af abRTWRSep3 "right" $rmargin
	
	-ac abRTWRScaleTxt "bottom" 7 abRTWRSep3
	-af abRTWRScaleTxt "left" ($lmargin*2)
	
	-ac abRTWRScaleFltFld "bottom" 4 abRTWRSep3
	-ac abRTWRScaleFltFld "left" 5 abRTWRScaleTxt
	-af abRTWRScaleFltFld "right" $rmargin
	
	-ac abRTWRSep2 "bottom" 5 abRTWRScaleFltFld
	-af abRTWRSep2 "left" $lmargin
	-af abRTWRSep2 "right" $rmargin
	
	-ac abRTWRMirrorBn "bottom" 4 abRTWRSep2
	-af abRTWRMirrorBn "left" $lmargin
	-af abRTWRMirrorBn "right" $rmargin
		
	-ac abRTWRMirrorFromToBn "bottom" 4 abRTWRMirrorBn
	-af abRTWRMirrorFromToBn "left" $lmargin
	-af abRTWRMirrorFromToBn "right" $rmargin
	
	-ac abRTWRSep5 "bottom" 5 abRTWRMirrorFromToBn
	-af abRTWRSep5 "left" 5
	-af abRTWRSep5 "right" $rmargin
	
	-ac abRTWRObjSpcCopyBn "bottom" 4 abRTWRSep5
	-af abRTWRObjSpcCopyBn "left" $lmargin
	-af abRTWRObjSpcCopyBn "right" $rmargin
	
	-ac abRTWRCopyBn "bottom" 4 abRTWRObjSpcCopyBn
	-af abRTWRCopyBn "left" $lmargin
	-af abRTWRCopyBn "right" $rmargin
	
	-ac abRTWRSep1 "bottom" 5 abRTWRCopyBn
	-af abRTWRSep1 "left" $lmargin
	-af abRTWRSep1 "right" $rmargin
	
	-ac abRTWRMkCrvLocBn "bottom" 4 abRTWRSep1
	-af abRTWRMkCrvLocBn "left" $lmargin
	-af abRTWRMkCrvLocBn "right" $rmargin
	
	-ac abRTWRCenterOnObjBn "bottom" 4 abRTWRMkCrvLocBn
	-af abRTWRCenterOnObjBn "left" $lmargin
	-af abRTWRCenterOnObjBn "right" $rmargin
	
	-ac abRTWRCenterOnPivBn "bottom" 4 abRTWRCenterOnObjBn
	-af abRTWRCenterOnPivBn "left" $lmargin
	-af abRTWRCenterOnPivBn "right" $rmargin
	
	-ac abRTWRSep "bottom" 5 abRTWRCenterOnPivBn
	-af abRTWRSep "left" $lmargin
	-af abRTWRSep "right" $rmargin
	
	-ac abRTWRReplaceBn "bottom" 4 abRTWRSep
	-af abRTWRReplaceBn "left" $lmargin
	-af abRTWRReplaceBn "right" $rmargin
	
	-af abRTWRWireTypeTxtScrllLst "top" 10
	-af abRTWRWireTypeTxtScrllLst "left" $lmargin
	-af abRTWRWireTypeTxtScrllLst "right" $rmargin
	-ac abRTWRWireTypeTxtScrllLst "bottom" 5 abRTWRReplaceBn
	
	abTRWrRplcForm;
	
	showWindow abRTWrRplcWin;
	
	// mel is dumb
	evalDeferred("window -e -w "+$width+" abRTWrRplcWin;");
	
}


global proc abRTServiceWireReplaceUI(string $caller){
	// $caller can be "Copy", "Replace", "Mirror", "MirrorFromTo", or "Rotate"
	
	int $mods = `getModifiers`;
	// ctrl == 4, shift == 1
	
	string $aStr[], $aCurveShapes[], $curve, $directions, $hardness, $replaceCmd, $cmd, $wireType, $aRel[], $str;
	int $i;
	
	int $ctrlMod = ($mods == 4 || $mods == 5);
	int $shiftMod = ($mods == 1 || $mods == 5);
	
	string $aCurves[] = `ls -sl`;
	
	for ($i=0;$i<size($aCurves);$i++){
		
		$aRel = `listRelatives -c -fullPath -type nurbsCurve $aCurves[$i]`;
		
		if (size($aRel) == 1)
			$aCurveShapes[size($aCurveShapes)] = $aRel[0];
	}
	
	if (size($aCurveShapes) == 0 || (size($aCurveShapes) != 2 && ($caller == "Copy" || $caller == "MirrorFromTo"))){
		
		if ($caller == "Copy" || $caller == "MirrorFromTo")
			warning "Select two control curves: a source and a destination.";
		else
			warning "Select one or more control curves and try again.";
		
		return;
	}
	
	string $aAxesCtrls[], $slAxisCtrl;
	int $slAxis;
	
	if ($caller != "Copy"){
		
		$aStr = `textScrollList -q -si abRTWRWireTypeTxtScrllLst`;
		
		if (size($aStr) > 0)
			$wireType = $aStr[0];
		
		// set the default facing axis
		$slAxis = 1;
	}
	
	if ($caller == "Copy" || $caller == "ObjSpaceCopy"){
		// case "Copy":
		
		if ($caller == "Copy"){
			
			$aStr = re_getCurvePointInfo($aCurves[0], true);
			$directions = $aStr[0];
			$hardness = $aStr[1];
			$replaceCmd = `substitute "curve -d" $directions "curve -r -ws -d"`;
			
		}else{
			
			if (size($aCurves) < 2){
				warning "Select at least two curves: a source and a destination.";
				return;
			}
			
			$aStr = re_getCurvePointInfo($aCurves[0], false);
			$directions = $aStr[0];
			$hardness = $aStr[1];
			$replaceCmd = `substitute "curve -d" $directions "curve -r -os -d"`;
		}
		
		for ($i=1;$i<size($aCurves);$i++){
			
			$cmd = $replaceCmd+" "+$aCurves[$i];
			eval ($cmd);
			
			// now do hardness
			if ($hardness != ""){
				$cmd = substituteAllString($hardness, "#curve#", $aCurves[1]);
				eval ($cmd);
			}
			
			// copy atts
			abRTCopyWireAttributes($aCurves[0], $aCurves[$i]);
		}
		
		select -r $aCurves;
		
	}else if ($caller == "CenterOnPivot"){
		
		for ($curve in $aCurves){
			
			// make sure it's a curve
			$aRel = `listRelatives -c -type nurbsCurve $curve`;
			
			if (size($aRel) > 0)
				abRTCenterWireOnPivot($curve, "");
		}
		
		select -r $aCurves;
		
	}else if ($caller == "CenterOnObject"){
		
		if (size($aCurves) != 2){
			warning "Select a target object and a curve and try again.";
			return;
		}
		
		$aRel = `listRelatives -c -type nurbsCurve $aCurves[0]`;
		
		if (size($aRel) > 0){
			abRTCenterWireOnPivot($aCurves[0], $aCurves[1]);
		}else{
			
			$aRel = `listRelatives -c -type nurbsCurve $aCurves[1]`;
			
			if (size($aRel) > 0)
				abRTCenterWireOnPivot($aCurves[1], $aCurves[0]);
		}
		
		
	}else if ($caller == "Replace" || $caller == "ScaleSliderReplace"){
		// case "Replace":
		
		if ($wireType == ""){
			warning "Select a wire type in the scroll list to replace the current curve with.";
			return;
		}
		
		if ($caller == "ScaleSliderReplace"){
			
			if (`checkBox -q -v abRTWRReplacedInPlaceChkBx` == false)
				$caller = "Replace";
		}
		
		for ($curve in $aCurves){
			
			if ($caller == "Replace"){
				
				// replace in place button (or shift double click in scrollList)
				abRTReplaceWireController($curve, $wireType, $slAxis, false, {false, true, true});
				
			}else if ($caller == "ScaleSliderReplace"){
				
				// respect scale slider but replace in place (need to allow scale to be adjusted) {useInternalWireType, $useInternalFacingAxis, $useInternalSize};
				abRTReplaceWireController($curve, $wireType, $slAxis, true, {true, true, false});
			}
		}
		
		select -r $aCurves;
		
	}else if ($caller == "SetWireFacingPosX" || $caller == "SetWireFacingPosY" || $caller == "SetWireFacingPosZ" || $caller == "SetWireFacingNegX" || $caller == "SetWireFacingNegY" || $caller == "SetWireFacingNegZ"){
		
		string $aFacingCallers[] = {"SetWireFacingPosX", "SetWireFacingPosY", "SetWireFacingPosZ", "SetWireFacingNegX", "SetWireFacingNegY", "SetWireFacingNegZ"};
		
		$slAxis = abRTGetPosInStrArray($caller, $aFacingCallers);
		
		for ($curve in $aCurves)
			abRTReplaceWireController($curve, $wireType, $slAxis, false, {true, false, true});
		
		select -r $aCurves;
	
	}else if ($caller == "MakeCurveLoc"){
		
		float $aWireTrans[], $aBbox[];
		string $tLoc, $aLocs[];
		
		// make locs
		for ($curve in $aCurves){
			
			$aBbox = `xform -q -ws -boundingBox $curve`;
			
			$aWireTrans[0] = ($aBbox[3] + $aBbox[0])/2.0;
			$aWireTrans[1] = ($aBbox[4] + $aBbox[1])/2.0;
			$aWireTrans[2] = ($aBbox[5] + $aBbox[2])/2.0;
			
			//$tLoc = abRTMakeLocatorV2(shortNameOf($curve)+"_pivot_loc", $curve, "");
			$tLoc = abRTMakeLocator(shortNameOf($curve)+"_pivot_loc");
			
			$aStr = `pointConstraint $curve $tLoc`;
			for ($str in $aStr)
				delete $str;
			
			xform -t $aWireTrans[0] $aWireTrans[1] $aWireTrans[2] $tLoc;
			
			$aLocs[size($aLocs)] = $tLoc;
		}
		
		select -r $aLocs;
		
		
	}else if ($caller == "Mirror"){
		// case "Mirror":
		
		string $mCtrl;
		
		for ($curve in $aCurves){
			
			$mCtrl = abRTGetMirrorObj($curve);
			
			if ($mCtrl != ""){
				
				$aStr = re_getCurvePointInfo($curve, true);
				$directions = $aStr[0];
				string $tCrv = eval($directions);
				setAttr ($tCrv+".sx") -1;
				
				$aStr = re_getCurvePointInfo($tCrv, true);
				$directions = $aStr[0];
				$hardness = $aStr[1];
				
				$replaceCmd = `substitute "curve -d" $directions "curve -r -ws -d"`;
				$replaceCmd += " "+$mCtrl;
				
				delete $tCrv;
				
				eval($replaceCmd);
				
				// now do hardness
				if ($hardness != ""){
					$hardness = substituteAllString($hardness, "#curve#", $mCtrl);
					eval ($hardness);
				}
				
				abRTCopyWireAttributes($curve, $mCtrl);
			}
		}
		
		select -r $aCurves;
		
	}else if ($caller == "MirrorFromTo"){
		// case "MirrorFromTo":
		
		string $mCtrl;
		
		if (size($aCurves) == 2)
			$mCtrl = $aCurves[1];
		else
			return;
		
		$aStr = re_getCurvePointInfo($aCurves[0], true);
		$directions = $aStr[0];
		string $tCrv = eval($directions);
		setAttr ($tCrv+".sx") -1;
		
		$aStr = re_getCurvePointInfo($tCrv, true);
		$directions = $aStr[0];
		$hardness = $aStr[1];
		
		$replaceCmd = `substitute "curve -d" $directions "curve -r -ws -d"`;
		$replaceCmd += " "+$mCtrl;
		
		delete $tCrv;
		
		eval($replaceCmd);
		
		select -r $aCurves[0];
		
		// now do hardness
		if ($hardness != ""){
			$hardness = substituteAllString($hardness, "#curve#", $mCtrl);
			eval ($hardness);
		}
		
		abRTCopyWireAttributes($aCurves[0], $aCurves[1]);
		
	}else if ($caller == "Rotate"){
		
		float $aRot[] = `floatFieldGrp -q -value abRTWRRotateFltFldGrp`;
		
		for ($curve in $aCurves)
			abRTRotateWire($curve, $aRot);
		
		select -r $aCurves;
	}
}


global proc abRTCaptureControlCurves(){
	// select the rootCon and run this proc and a shelfButton will be created that can be used to rebuild all of your rig's control curves
	
	int $ok = false;
	int $defIndColor = -1;
	
	string $dataSep = "+";
	string $emptyDataSymbol = "-";
	
	string $rigGrp = abRTGetRigGrpFromSelCtrl("");
	string $aCurves[] = abRTGetRigGrpCtrlCurves($rigGrp);
	string $charName = abRTGetCharNameFromCtrl("", false);
	
	string $curve, $cmd, $colorData, $curveData, $aRel[], $shape, $directions, $hardness, $aStr[], $wireType, $wireSize, $wireFacingAxis, $aCurveData[];
	int $i, $indexColor;
	
	$curveData = "\""+$charName+"\"";
	$colorData = "\"colorData\"";
	
	for ($i=0;$i<size($aCurves);$i++){
		
		clear($aCurveData);
		$curve = shortNameOf($aCurves[$i]);
		
		$aStr = re_getCurvePointInfo($curve, false);
		$directions = $aStr[0];
		$hardness = ($aStr[1] != "") ? $aStr[1] : $emptyDataSymbol;
		
		$wireType = (attributeExists("wireType", $curve)) ? `getAttr ($curve+".wireType")` : $emptyDataSymbol;
		$wireSize = (attributeExists("wireScale", $curve)) ? `getAttr ($curve+".wireScale")` : $emptyDataSymbol;
		$wireFacingAxis = (attributeExists("wireFacingAxis", $curve)) ? `getAttr ($curve+".wireFacingAxis")` : $emptyDataSymbol;
		
		$aCurveData[size($aCurveData)] = $curve;
		$aCurveData[size($aCurveData)] = $directions;
		$aCurveData[size($aCurveData)] = $hardness;
		$aCurveData[size($aCurveData)] = $wireType;
		$aCurveData[size($aCurveData)] = $wireSize;
		$aCurveData[size($aCurveData)] = $wireFacingAxis;
		
		$curveData += ",\n\""+(stringArrayToString($aCurveData, $dataSep))+"\"";
		
		// now add color info; "colorData" is first item that identifies the color, like {"colorData", "curve1:colorIndex1", "curve2:colorIndex2"}
		// get shape
		$aRel = `listRelatives -c -path -type shape $aCurves[$i]`;
		$shape = $aCurves[$i];
		
		if (size($aRel) == 1){
			
			$shape = $aRel[0];
			
			if (attributeExists("overrideColor", $shape))
				$indexColor = `getAttr ($shape+".overrideColor")`;
			else
				$indexColor = $defIndColor;
		}else{
			$indexColor = $defIndColor;
		}
		
		$colorData += ",\n\""+$shape+$dataSep+$indexColor+"\"";
	}
	
	$cmd = "abRTRecallControlCurves({\n"+$curveData+",\n"+$colorData+"\n});";
	
	string $parent = `shelfTabLayout -q -selectTab ShelfLayout`;
	string $charBn = `shelfButton -i "abAutoRigCurve.bmp" -iol $charName -ann "Restore control curves" -parent $parent -c $cmd`;
	
	if (size($aCurves) > 0) print ("Saved "+size($aCurves)+" curves to shelfButton \"crv\"");
	
	select -clear;
	
}


global proc abRTRecallControlCurves(string $aData[]){
	// aData in the form of ["charName","curveName:curveDirections:[curveHardness]","curveName:curveDirections:[curveHardness]"]
	
	if (size($aData) == 0) return;
	
	int $mods = `getModifiers`;
	int $ok = false;
	
	string $dataSep = "+";
	string $oldDataSep = ":";
	string $emptyDataSymbol = "-";
	
	string $aOrigSel[] = `ls -sl`;
	
	// get rigGrp, charName and control curves
	string $rigGrp = abRTGetRigGrpFromSelCtrl("");
	string $aCurves[] = abRTGetRigGrpCtrlCurves($rigGrp);
	string $cCharName = `substitute "_rig_grp" $rigGrp ""`;
	$cCharName = `substitute "^|" $cCharName ""`;
	
	if ($rigGrp == "")
		return;
	
	// break data into two arrays for quick sorting; substitute new char name
	
	// get charName and remove leading pipe (if there is one)
	string $dataCharName = $aData[0];
	$dataCharName = `substitute "^|" $dataCharName ""`;
	
	string $aCurveName[], $aDirections[], $aHardness[], $aWireType[], $aWireSize[], $aWireFacingAxis[], $aStr[], $aColorShapes[], $aPath[], $tData, $tCrvCmd, $tHardenCmd, $tColorInd;
	int $i, $it, $aColorIndex[], $colorIndex;
	
	string $dataType = "curveData";
	int $defColorIndex = 6;
	int $colorData = false;
	int $onlyUpdateColor = $mods % 2;
	
	
	for ($i=1;$i<size($aData);$i++){
		
		if ($aData[$i] == "colorData"){
			$dataType = "colorData";
			$colorData = true;
			continue;
		}
		
		$aStr = stringToStringArray($aData[$i], $dataSep);
		
		// I stupidly used the ":" as a separator, which causes problems when used with referenced characters paths (which also use a ":"), so have to only split the data string using the last separator
		// v. 3.75 and up will use "+" as a data string separator instead
		
		if (size($aStr) == 1){
			
			// $tCrvCmd, $tHardenCmd, $tColorInd;
			
			$aStr = stringToStringArray($aData[$i], $oldDataSep);
			$tData = $aStr[size($aStr)-1];
			
			$tCrvCmd = $tHardenCmd = $tColorInd = "";
			clear($aPath);
			
			if (size($aStr) >= 2){
				
				for ($it=0;$it<size($aStr);$it++){
					
					if (`match "[0-9]+" $aStr[$it]` == $aStr[$it]){
						
						// it's a color index (aStr[1])
						$tColorInd = $aStr[$it];
						
					}else if (startsWith($aStr[$it], "hardenPointCurve")){
						
						// it's a hardenPointCurve Cmd (aStr[2])
						$tHardenCmd = $aStr[$it];
						
					}else if (startsWith($aStr[$it], "curve")){
						
						// it's a curve Cmd (aStr[1])
						$tCrvCmd = $aStr[$it];
						
					}else{
						
						// part of the curve path
						$aPath[size($aPath)] = $aStr[$it];
					}
				}
				
				clear($aStr);
				
				$aStr[0] = stringArrayToString($aPath, $oldDataSep);
				
				if ($dataType == "curveData"){
					
					if ($tCrvCmd != "")
						$aStr[1] = $tCrvCmd;
					
				}else{
					
					if ($tColorInd != "")
						$aStr[1] = $tColorInd;
				}
				
				if ($tHardenCmd != ""){
					$aStr[2] = $tHardenCmd;
				}
			}
		}
		
		// replace emptyDataSymbol with empty data
		for ($k=0;$k<size($aStr);$k++){
			if ($aStr[$k] == $emptyDataSymbol)
				$aStr[$k] = "";
		}
		
		if ($dataType == "curveData"){
			
			$aCurveName[size($aCurveName)] = `substitute ("^"+$dataCharName) $aStr[0] $cCharName`;
			$aDirections[size($aDirections)] = $aStr[1];
			
			if (size($aStr) >= 3)
				$aHardness[size($aHardness)] = $aStr[2];
			else
				$aHardness[size($aHardness)] = "";
			
			if (size($aStr) >= 4)
				$aWireType[size($aWireType)] = $aStr[3];
			else
				$aWireType[size($aWireType)] = "";
			
			if (size($aStr) >= 5)
				$aWireSize[size($aWireSize)] = $aStr[4];
			else
				$aWireSize[size($aWireSize)] = "";
			
			if (size($aStr) >= 6)
				$aWireFacingAxis[size($aWireFacingAxis)] = $aStr[5];
			else
				$aWireFacingAxis[size($aWireFacingAxis)] = "";
			
		}
	}
	
	int $count = 0;
	int $k;
	string $curve, $shortName, $cmd;
	
	for ($k=0;$k<size($aCurves);$k++){
		
		$curve = $aCurves[$k];
		$shortName = shortNameOf($curve);
		
		// if the control key is pressed restore only the selected curves
		if ($mods / 4 % 2){
			$aStr = `ls -sl $curve`;
			if (size($aStr) == 0)
				continue;
		}
		
		// search for $shortName and, if found, apply curve directions to $curve
		for ($i=0;$i<size($aCurveName);$i++){
			
			if ($shortName == $aCurveName[$i]){
				
				if (!$onlyUpdateColor){
					
					// if shift key is pressed only restore color, don't rebuild curves
					// curve stuff
					//$cmd = `substitute "curve -d" $aDirections[$i] "curve -r -ws -d"`;
					$cmd = `substitute "curve -d" $aDirections[$i] "curve -r -os -d"`;
					$cmd += " "+$curve;
					eval ($cmd);
										
					if ($aHardness[$i] != ""){
						$cmd = substituteAllString($aHardness[$i], "#curve#", $curve);
						eval ($cmd);
					}
					
					// set original wire attributes
					abRTSetWireAttributes($curve, {"wireScale", $aWireSize[$i], "wireType", $aWireType[$i], "wireFacingAxis", $aWireFacingAxis[$i]});
				}
				
				$count ++;
				break;
			}
		}
	}
	
	if ($count > 0){
		print ("Restored "+$count+" curve(s)");
	}else{
		print "\n\n";
	}
	
	select -r $aOrigSel;
	
}


global proc float abRTGetMaxDim(string $obj){
	// returns the max dimension of $obj boundingBox
	
	float $aBBox[] = `xform -q -ws -boundingBox $obj`;
	float $aDim[] = {abs($aBBox[3]-$aBBox[0]),abs($aBBox[4]-$aBBox[1]),abs($aBBox[5]-$aBBox[2])};
	float $flt;
	float $max = 0;
	
	for ($flt in $aDim) if ($flt > $max) $max = $flt;
	
	return $max;
}


global proc string abRTGetMirrorObj(string $obj){
	// returns name of same type of object on other side of yz axis or an empty string if none (or multiple in same position)
	
	if (!objExists($obj)) return "";
	
	string $nodeType, $tObj, $ret, $transform, $aRetObj[], $aStr[];
	float $xForm[];
	float $tol = .001;
	int $posXObj; // true if $obj is on the x+ side of the YZ plane
	
	string $tLoc = abRTMakeLocator("abRTGetMirror_loc");
	
	select -r $obj $tLoc;
	abRTPointOrient(1);
	
	float $objXform[] = `xform -q -ws -t $tLoc`;
	
	if ($objXform[0] > $tol){
		$posXObj = true;
	}else if ($objXform[0] < -$tol){
		$posXObj = false;
	}else{
		// $obj is on the x origin -- it will have no mirror
		$posXObj = -1;
	}
	
	if ($posXObj != -1){
		
		string $aStr[] = `listRelatives -shapes $obj`;
		int $useShape = (size($aStr) > 0);
		$nodeType = ($useShape) ? `nodeType $aStr[0]` : `nodeType $obj`;
		
		string $aObj[] = `ls -type $nodeType`;
		
		for ($tObj in $aObj){
			
			// if the node is a locator don't include our tLoc in the matching
			
			if ($useShape){
				// get transform
				$aStr = `listRelatives -p -type transform $tObj`;
				if (size($aStr) == 1) $transform = $aStr[0];
				else continue;
			}else{
				$transform = $tObj;
			}
			
			if (shortNameOf($transform) == shortNameOf($tLoc)) continue;
			
			if (catchQuiet(`select -r $transform $tLoc`)) continue;
			abRTPointOrient(1);
			
			$xForm = `xform -q -ws -t $tLoc`;
			
			if (abs($objXform[0] + $xForm[0]) < $tol){
				if (abs($objXform[1] - $xForm[1]) < $tol){
					if (abs($objXform[2] - $xForm[2]) < $tol){
						$aRetObj[size($aRetObj)] = $transform;
					}
				}
			}
		}
		
		
		if (size($aRetObj) == 1){
			$ret = $aRetObj[0];
		}else if (size($aRetObj) > 1){
			
			// try to guess mirror object based on name match
			
			string $mObjGuess;
			string $prefix = abRTGetObjSide($obj);
			string $lfPrefix = "_"+abRTGetGlobal("leftPrefix");
			string $rtPrefix = "_"+abRTGetGlobal("rightPrefix");
			
			if ($prefix == "l"){
				$mObjGuess = abRTSubstituteAll($lfPrefix, $obj, $rtPrefix);
			}else{
				$mObjGuess = abRTSubstituteAll($rtPrefix, $obj, $lfPrefix);
			}
			
			for ($tObj in $aRetObj){
				if (longNameOf($tObj) == longNameOf($mObjGuess)){
					$ret = $mObjGuess;
					break;
				}
			}
			
			// if that doesn't work, ask the user
			if ($ret == ""){
				string $bnStr, $aStrippedBns[];
				for ($tObj in $aRetObj){
					$aStrippedBns[size($aStrippedBns)] = abRTStripPath($tObj);
					$bnStr += " -button \""+($aStrippedBns[size($aStrippedBns)-1])+"\"";
				}
				
				string $shortNameObj = abRTStripPath($obj);
				string $cmd = "confirmDialog -title \"Multiple Mirror Objects\" -message \"Select the mirror object of "+$shortNameObj+".\" "+$bnStr+" -button \"Cancel\" -defaultButton \"Cancel\" -cancelButton \"Cancel\" -dismissString \"Cancel\"";
				
				string $chosenObj = eval($cmd);
				if ($chosenObj != "Cancel"){
					int $arrayPos = abRTGetPosInStrArray($chosenObj, $aStrippedBns);
					if ($arrayPos >= 0) $ret = $aRetObj[$arrayPos];
				}else{
					error "Operation cancelled.";
				}
			}
		}
	}
	
	select -clear;
	delete $tLoc;
	
	return $ret;
	
}


global proc abRTRigRemover(){
	// shows a UI to remove parts of the rig.
	
	string $node;
	string $aNodes[] = `ls -type geometryVarGroup "*_charVars"`;
	
	if (size($aNodes) == 0){
		warning "There are no valid CharVar nodes in the scene.";
		return;
	}
	
	if (`window -exists abRTRigRemoverWin`){
		deleteUI -window abRTRigRemoverWin;
	}
	window -t "abRigRemover" -w 156 -h 254 -menuBar true -minimizeButton false -maximizeButton false abRTRigRemoverWin;
		
	formLayout -numberOfDivisions 100 abRTRRForm;
	
	// populate option menu
	optionMenu -changeCommand "abRTRRPopulateScrollList();" abRTRRCharOpMn;
	for ($node in $aNodes) menuItem -label $node -p abRTRRCharOpMn;
	
	textScrollList -allowMultiSelection true abRTRRTxtScrollList;
	
	button -label "Refresh" -command "abRTRRPopulateScrollList();" abRTRRRefBn;
	button -label "Remove Selected" -command "abRTRRDeleteRig();" abRTRRDelBn;
	
	int $lmargin = 3;
	int $rmargin = 3;
	
	formLayout -e
	
	-af abRTRRDelBn "bottom" 4
	-af abRTRRDelBn "left" $lmargin
	-af abRTRRDelBn "right" $rmargin
	
	-af abRTRRRefBn "left" $lmargin
	-af abRTRRRefBn "right" $rmargin
	-ac abRTRRRefBn "bottom" 5 abRTRRDelBn
	
	-ac abRTRRTxtScrollList "top" 4 abRTRRCharOpMn
	-af abRTRRTxtScrollList "left" $lmargin
	-af abRTRRTxtScrollList "right" $rmargin
	-ac abRTRRTxtScrollList "bottom" 5 abRTRRRefBn
	
	-af abRTRRCharOpMn "top" 5
	-af abRTRRCharOpMn "left" $lmargin
	-af abRTRRCharOpMn "right" $rmargin
	
	abRTRRForm
	;
	
	// populate textScrollList
	abRTRRPopulateScrollList();
	
	// showWindow
	showWindow abRTRigRemoverWin;
}


global proc abRTRRPopulateScrollList(){
	// refreshes the RigRemover scrollList
	
	if (!`window -ex abRTRigRemoverWin`) return;
	if (!`window -ex abRTWin`){
		deleteUI -window abRTRigRemoverWin;
		return;
	}
	
	// populate textScrollList
	string $att, $part;
	string $aRigParts[] = {"spine","head","leftLeg","rightLeg","leftArm","rightArm","leftHand","rightHand"};
	string $aSceneCharVars[] = `ls -type geometryVarGroup "*_charVars"`;
	
	
	if (size($aSceneCharVars) == 0){
		// There are no charvars in the scene
		deleteUI -window abRTRigRemoverWin;
		return;
	}
	
	
	// update option menu
	string $menuItem, $option;
	string $aOptionMenuItems[] = `optionMenu -q -itemListLong abRTRRCharOpMn`;
	
	// getSelected Item
	int $selMenuItem = `optionMenu -q -select abRTRRCharOpMn`;
	
	// empty and rebuild the option menu
	for ($menuItem in $aOptionMenuItems) deleteUI -menuItem $menuItem;
	for ($option in $aSceneCharVars) menuItem -label $option -p abRTRRCharOpMn;
	
	// reselect $selMenuItem
	if (size($aSceneCharVars) >= $selMenuItem) optionMenu -e -select $selMenuItem abRTRRCharOpMn;
	
	
	string $selCharVars = `optionMenu -q -v abRTRRCharOpMn`;
	
	// clear textScrollList
	textScrollList -e -ra abRTRRTxtScrollList;
	
	if ($selCharVars != ""){
		
		string $aCharVarAtts[] = `listAttr -userDefined $selCharVars`;
		
		for ($att in $aCharVarAtts){
			for ($part in $aRigParts){
				
				if (startsWith($att, $part)){
					textScrollList -e -append $part abRTRRTxtScrollList;
					$aRigParts = stringArrayRemove({$part}, $aRigParts);
					break;
				}
			}
		}
	}
	
}


global proc abRTRRDeleteRig(){
	// deletes part of rig specified in abRTRRTxtScrollList
	
	if (!`window -ex abRTWin`){
		deleteUI -window abRTRigRemoverWin;
		return;
	}
	
	string $item, $rigGrpAtt, $rigGrp, $nodesStr, $aNodes[], $node, $jntGrpAtt, $jntGrp, $jntStr, $aJnts[], $jnt, $nodeGrpAtt, $transGrpAtt, $attGrpAtt, $attStr, $aAtts[], $att, $aStr[], $transStr, $aTrans[];
	
	string $charVarsNode = `optionMenu -q -v abRTRRCharOpMn`;
	string $aDelRigItems[] = `textScrollList -q -si abRTRRTxtScrollList`;
	
	// check items marked for deletion.  All items after them must be removed as well (must be rigged in order)
	string $aRigAllItems[] = `textScrollList -q -allItems abRTRRTxtScrollList`;
	int $ind = 0;
	int $counter = 0;
	int $warning = false;
	int $i, $min;
	
	for ($i=size($aRigAllItems)-1;$i>=0;$i--){
		
		$ind = abRTGetPosInStrArray($aRigAllItems[$i], $aDelRigItems);
		
		if ($ind == -1){
			
			if (size($aDelRigItems) != $counter)
				$warning = true;
			break;
		}
		$counter ++;
	}
	
	if ($warning){
		
		string $result = `confirmDialog -title "Confirm"
		-messageAlign "center"
		-message "The rig must be removed in the order it was built, otherwise\n some features may not work as expected.  Do you want to remove\n all of the rig groups below the topmost currently selected?"
		-button "Yes" -button "No" -defaultButton "Yes"
		-cancelButton "No" -dismissString "No"`;
		
		if ($result == "Yes"){
			// add all rig groups beyond min selected to $aDelRigItems
			// get min sel
			$ind = size($aRigAllItems);
			for ($i=0;$i<size($aDelRigItems);$i++){
				
				$min =abRTGetPosInStrArray($aDelRigItems[$i], $aRigAllItems);
				if ($min != -1)
					$ind = int(`min (float($min)) (float($ind))`);
			}
			
			// add all items beyond min to $aDelRigItems
			for ($i=$min;$i<size($aRigAllItems);$i++){
				if (abRTGetPosInStrArray($aRigAllItems[$i], $aDelRigItems) == -1)
					$aDelRigItems[size($aDelRigItems)] = $aRigAllItems[$i];
			}
			
		}else{
			return;
		}
	}
	
	
	for ($item in $aDelRigItems){
		
		$rigGrpAtt = $item+"RigGrp";
		$jntGrpAtt = $item+"Jnts";
		$nodeGrpAtt = $item+"Nodes";
		$transGrpAtt = $item+"Trans";
		$attGrpAtt = $item+"Atts";
		
		if (attributeExists($rigGrpAtt, $charVarsNode)){
			
			// break joint connections
			// first retrieve joints
			if (attributeExists($jntGrpAtt, $charVarsNode)){
				
				$jntStr = `getAttr ($charVarsNode+"."+$jntGrpAtt)`;
				$aJnts = stringToStringArray($jntStr, ",");
				
				// now break'em
				for ($jnt in $aJnts){
					
					gmDeleteConnection($jnt+".tx");
					gmDeleteConnection($jnt+".ty");
					gmDeleteConnection($jnt+".tz");
					gmDeleteConnection($jnt+".rx");
					gmDeleteConnection($jnt+".ry");
					gmDeleteConnection($jnt+".rz");
					gmDeleteConnection($jnt+".sx");
					gmDeleteConnection($jnt+".sy");
					gmDeleteConnection($jnt+".sz");
					
					// reset joint scale and rotation
					setAttr ($jnt+".r") 0 0 0;
					setAttr ($jnt+".s") 1 1 1;
				}
				
				// remove attributes
				deleteAttr -at $jntGrpAtt $charVarsNode;
			}
			
			// get array of nodes out of charVars for this item
			if (attributeExists($nodeGrpAtt, $charVarsNode)){
				$nodesStr = `getAttr ($charVarsNode+"."+$nodeGrpAtt)`;
				$aNodes = stringToStringArray($nodesStr, ",");
				for ($node in $aNodes) if (`objExists $node`) delete $node;
				// remove attributes
				deleteAttr -at $nodeGrpAtt $charVarsNode;
			}
			
			// get rid of stray attributes
			if (attributeExists($attGrpAtt, $charVarsNode)){
				$attStr = `getAttr ($charVarsNode+"."+$attGrpAtt)`;
				$aAtts = stringToStringArray($attStr, ",");
				for ($att in $aAtts){
					$aStr = stringToStringArray($att, ".");
					if (`objExists $aStr[0]` && attributeExists($aStr[1], $aStr[0])){
						setAttr -lock 0 $att;
						deleteAttr $att;
					}
				}
				// remove attributes
				deleteAttr -at $attGrpAtt $charVarsNode;
			}
			
			// remove any random transforms
			if (attributeExists($transGrpAtt, $charVarsNode)){
				$transStr = `getAttr ($charVarsNode+"."+$transGrpAtt)`;
				$aTrans = stringToStringArray($transStr, ",");
				for ($node in $aTrans) if (`objExists $node`) delete $node;
				// remove attributes
				deleteAttr -at $transGrpAtt $charVarsNode;
			}
			
			
			// delete rig group
			if (attributeExists($rigGrpAtt, $charVarsNode)){
				$rigGrp = `getAttr ($charVarsNode+"."+$rigGrpAtt)`;
				if (`objExists $rigGrp`) delete $rigGrp;
				// remove attributes
				deleteAttr -at $rigGrpAtt $charVarsNode;
			}
			
		}else{
			warning ("Unable to remove "+$item);
		}
		
		// remove the item from the scrollList
		textScrollList -e -ri $item abRTRRTxtScrollList;
		
	}
	
	// if there are no items left, delete the rigGrp
	if (`textScrollList -q -numberOfItems abRTRRTxtScrollList` == 0){
		string $mainRigGrp = firstParentOf($charVarsNode);
		if (objExists($mainRigGrp) && endsWith($mainRigGrp, "_rig_grp")) delete $mainRigGrp;
	}
	
	// update RigRemover UI
	abRTRRPopulateScrollList();
	
	// update UI textfields
	abRTCheckUIItems("");
	
}


global proc int abRTCheckJointOrient(string $aJnts[], string $name){
	// checks all joints in $aJnts to make sure the rotate values are zero.  If not, it offers to zero them.
	// $name is the name of the hierarchy (leg, arm)
	// returns 1 if joints don't need to be zeroed, 0 if there are nonzeroed joints that were zeroed, -1 if user declined to zero, or -2 if one or more of the joint's r is already connected
	
	string $jnt, $confirm, $srcX, $srcY, $srcZ;
	float $flt, $xForm[];
	
	int $ret = 1;
	int $okToResetJointRot = -1;
	float $jointRotTol = .000000001;
	
	// make sure there are no incoming connections
	for ($jnt in $aJnts){
		$srcX = `connectionInfo -sourceFromDestination ($jnt+".rx")`;
		$srcY = `connectionInfo -sourceFromDestination ($jnt+".ry")`;
		$srcZ = `connectionInfo -sourceFromDestination ($jnt+".rz")`;
		if ($srcX != "" || $srcY != "" || $srcZ != "") return -2;
	}
	
	// check aJnt joint rotations
	for ($jnt in $aJnts){
		
		if ($okToResetJointRot == -1){
			$xForm = `getAttr ($jnt+".r")`;
			for ($flt in $xForm){
				if (abs($flt) > $jointRotTol){
					// unset, see if user wants to reset r to 0 0 0
					$confirm = `confirmDialog -title "Confirm" -message ("There are one or more joints in your "+$name+" hierarchy\nwith non zero rotations.  Do you want them reset\nto zero before rigging?") -messageAlign "center" -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;
					if ($confirm == "No"){
						$okToResetJointRot = false;
						$ret = -1;
					}else{
						$okToResetJointRot = true;
						$ret = 0;
					}
					break;
				}
			}
		}
		
		if ($okToResetJointRot){
			setAttr ($jnt+".r") 0 0 0;
		}else if ($okToResetJointRot == 0){
			break;
		}
	}
	
	return $ret;
	
}


global proc abRTChangeRotOrderWindow(){
	// creates window for changing rotation order on selected objects
	
	if (`window -exists abRTChngROWin`)
		deleteUI -window abRTChngROWin;
	
	window -t "abChangeRotationOrder" -w 280 -h 33 -menuBar false -minimizeButton false -maximizeButton false abRTChngROWin;
		
	formLayout -numberOfDivisions 100 abRTChngROForm;
	
	optionMenu abRTChngROOptionMn;
	menuItem -label "xyz" -p abRTChngROOptionMn;
	menuItem -label "yzx" -p abRTChngROOptionMn;
	menuItem -label "zxy" -p abRTChngROOptionMn;
	menuItem -label "xzy" -p abRTChngROOptionMn;
	menuItem -label "yxz" -p abRTChngROOptionMn;
	menuItem -label "zyx" -p abRTChngROOptionMn;
	
	button -label "  Change Rotation Order On Selected To:  " -h 25 -command "abRTChangeRotationOrder((`ls -sl`), ((`optionMenu -q -select abRTChngROOptionMn`)-1));" abRTChngROChangeROBn;
	
	int $lmargin = 2;
	int $rmargin = 2;
	
	formLayout -e
	
	-af abRTChngROOptionMn "top" 5
	-af abRTChngROOptionMn "bottom" 5
	-af abRTChngROOptionMn "right" $rmargin
	
	-af abRTChngROChangeROBn "top" 4
	-af abRTChngROChangeROBn "bottom" 4
	-af abRTChngROChangeROBn "left" $lmargin
	-ac abRTChngROChangeROBn "right" 4 abRTChngROOptionMn
	
	
	abRTChngROForm
	;
	
	showWindow abRTChngROWin;
	
}


global proc abRTChangeRotationOrder(string $aSel[], int $newRO){
	// changes the rotation order on the selected transforms in $aObj to $newRo:
	// 0:xyz, 1:yzx, 2:zxy, 3:xzy, 4:yxz, 5:zyx
	
	string $obj, $aLocs[], $aObj[], $aRel[], $tDup, $aStr[];
	float $aKeyTimes[], $aFlt[], $aRot[];
	int $i, $k;
	
	int $objCounter = 0;
	int $keyCounter = 0;
	int $lockedCounter = 0;
	
	string $locRootName = "abChangeRotOrderLoc_";
	
	float $initTime = `currentTime -q`;
	string $aInitSel[] = `ls -sl`;
	
	// get transforms for aSel
	for ($obj in $aSel){
		
		if (nodeType($obj) == "transform"){
			$aObj[size($aObj)] = $obj;
		}else{
			$aRel = `listRelatives -p -f -type transform $obj`;
			if (size($aRel) == 1) $aObj[size($aObj)] = $aRel[0];
		}
		
	}
	
	if (size($aObj) == 0) return;
	
	for ($obj in $aObj){
		
		// skip this object if it already has the desired RO
		if ($newRO == `getAttr ($obj+".ro")`) continue;
		
		if (!`getAttr -settable ($obj+".r")` || !`getAttr -settable ($obj+".rx")` || !`getAttr -settable ($obj+".ry")` || !`getAttr -settable ($obj+".rz")`){
			$lockedCounter++;
			continue;
		}
		
		// get keyframes for $obj (need to remove duplicates)
		$aFlt = sort(`keyframe -q $obj`);
		for ($i=0;$i<size($aFlt);$i++){
			
			if ($i == 0){
				$aKeyTimes[size($aKeyTimes)] = $aFlt[$i];
				continue;
			}
			
			if ($aFlt[$i] != $aFlt[$i-1]) $aKeyTimes[size($aKeyTimes)] = $aFlt[$i];
			
		}
		
		// create a loc for each keytime and snap it to the obj (will snap back to this after RO is changed)
		for ($k=0;$k<size($aKeyTimes);$k++){
			
			currentTime $aKeyTimes[$k];
			
			// make loc
			$aLocs[size($aLocs)] = abRTMakeLocator($locRootName+$k);
			
			// snap loc
			abRTSnapToPosition($obj, $aLocs[$k]);
			
		}
		
		// change RO
		setAttr ($obj+".ro") $newRO;
		
		// can't snap obj to loc (anim curve connections) so have to snap a duplicated obj to loc and copy those values to the existing obj over keytimes
		for ($k=0;$k<size($aKeyTimes);$k++){
			
			currentTime $aKeyTimes[$k];
			
			// dup obj
			$aStr = `duplicate $obj`;
			$tDup = $aStr[0];
			
			abRTShowAttr($tDup, {"tx","ty","tz","rx","ry","rz"});
			
			// snap obj
			abRTSnapToPosition($aLocs[$k], $tDup);
			
			$aRot = `getAttr ($tDup+".r")`;
			setAttr ($obj+".r") $aRot[0] $aRot[1] $aRot[2];
			
			delete $tDup;
			
			$keyCounter++;
			
		}
		
		// cleanup
		
		// delete locs
		if (size($aLocs) > 0) for ($obj in $aLocs) delete $obj;
		
		// clear arrays
		clear($aLocs);
		clear($aKeyTimes);
		
		$objCounter++;
		
	}
	
	// reset time and sel
	currentTime $initTime;
	select -r $aInitSel;
	
	string $lockedStr = ($lockedCounter > 0) ? "  Unable to operate on "+$lockedCounter+" locked or connected object(s)." : "";
	print ("Reset the rotation order on "+$objCounter+" transform(s) and a total of "+$keyCounter+" key(s)."+$lockedStr);
	
}


global proc abRTRotateOrientUI(){
	// opens joint orient UI
	
	if (`window -exists abRTROWin`){
		deleteUI -window abRTROWin;
	}
	window -t "abRotateOrient" -w 260 -h 190 -menuBar false -minimizeButton false -maximizeButton false abRTROWin;
		
	formLayout -numberOfDivisions 100 abRTROForm;
	
	// populate option menu
	button -label "+90 X" -c "abRTRORotateJointLA(0,0.0,`checkBox -q -v abRTROMirrorRotChkBx`);" abRTEOXPos90Bn;
	button -label "+90 Y" -c "abRTRORotateJointLA(1,0.0,`checkBox -q -v abRTROMirrorRotChkBx`);" abRTEOYPos90Bn;
	button -label "+90 Z" -c "abRTRORotateJointLA(2,0.0,`checkBox -q -v abRTROMirrorRotChkBx`);" abRTEOZPos90Bn;
	button -label "-90 X" -c "abRTRORotateJointLA(3,0.0,`checkBox -q -v abRTROMirrorRotChkBx`);" abRTEOXNeg90Bn;
	button -label "-90 Y" -c "abRTRORotateJointLA(4,0.0,`checkBox -q -v abRTROMirrorRotChkBx`);" abRTEOYNeg90Bn;
	button -label "-90 Z" -c "abRTRORotateJointLA(5,0.0,`checkBox -q -v abRTROMirrorRotChkBx`);" abRTEOZNeg90Bn;
	
	separator abRTROSep1;
	floatField -v 0.0 abRTROCustRotFltFld;
	button -label "+/-" -c "floatField -e -v (0 - (`floatField -q -v abRTROCustRotFltFld`)) abRTROCustRotFltFld;" abRTROCustRotNegateValBn;
	button -label "X" -c "abRTRORotateJointLA(6,`floatField -q -v abRTROCustRotFltFld`,`checkBox -q -v abRTROMirrorRotChkBx`);" abRTROCustRotXBn;
	button -label "Y" -c "abRTRORotateJointLA(7,`floatField -q -v abRTROCustRotFltFld`,`checkBox -q -v abRTROMirrorRotChkBx`);" abRTROCustRotYBn;
	button -label "Z" -c "abRTRORotateJointLA(8,`floatField -q -v abRTROCustRotFltFld`,`checkBox -q -v abRTROMirrorRotChkBx`);" abRTROCustRotZBn;
	separator abRTROSep2;
	checkBox -l "Apply All Rotations To Mirror Joint" -v true abRTROMirrorRotChkBx;
	separator abRTROSep3;
	
	button -label "Toggle Selected Local Axes" -c "abRTROToggleLRA(true);" abRTEOToggleSelLRA0Bn;
	button -label "Toggle Hierarchy Local Axes" -c "abRTROToggleLRA(false);" abRTEOToggleHierarchyLRA0Bn;
	
	int $lmargin = 3;
	int $rmargin = 3;
	int $tmargin = 5;
	
	formLayout -e
	
	-af abRTEOXPos90Bn "top" $tmargin
	-af abRTEOXPos90Bn "left" $lmargin
	-ap abRTEOXPos90Bn "right" $rmargin 33
	
	-af abRTEOYPos90Bn "top" $tmargin
	-ac abRTEOYPos90Bn "left" $lmargin abRTEOXPos90Bn
	-ap abRTEOYPos90Bn "right" $rmargin 66
	
	-af abRTEOZPos90Bn "top" $tmargin
	-ac abRTEOZPos90Bn "left" $lmargin abRTEOYPos90Bn
	-af abRTEOZPos90Bn "right" $rmargin
	
	-ac abRTEOXNeg90Bn "top" $tmargin abRTEOXPos90Bn
	-af abRTEOXNeg90Bn "left" $lmargin
	-ap abRTEOXNeg90Bn "right" $rmargin 33
	
	-ac abRTEOYNeg90Bn "top" $tmargin abRTEOYPos90Bn
	-ac abRTEOYNeg90Bn "left" $lmargin abRTEOXNeg90Bn
	-ap abRTEOYNeg90Bn "right" $rmargin 66
	
	-ac abRTEOZNeg90Bn "top" $tmargin abRTEOZPos90Bn
	-ac abRTEOZNeg90Bn "left" $lmargin abRTEOYNeg90Bn
	-af abRTEOZNeg90Bn "right" $rmargin
	
	-ac abRTROSep1 "top" $tmargin abRTEOZNeg90Bn
	-af abRTROSep1 "left" $lmargin
	-af abRTROSep1 "right" $rmargin
	
	-ac abRTROCustRotFltFld "top" ($tmargin+1) abRTROSep1
	-af abRTROCustRotFltFld "left" $lmargin
	-ap abRTROCustRotFltFld "right" $rmargin 30
	
	-ac abRTROCustRotNegateValBn "top" $tmargin abRTROSep1
	-ac abRTROCustRotNegateValBn "left" $lmargin abRTROCustRotFltFld
	-ap abRTROCustRotNegateValBn "right" $rmargin 40
	
	-ac abRTROCustRotXBn "top" $tmargin abRTROSep1
	-ac abRTROCustRotXBn "left" $lmargin abRTROCustRotNegateValBn
	-ap abRTROCustRotXBn "right" $rmargin 60
	
	-ac abRTROCustRotYBn "top" $tmargin abRTROSep1
	-ac abRTROCustRotYBn "left" $lmargin abRTROCustRotXBn
	-ap abRTROCustRotYBn "right" $rmargin 80
	
	-ac abRTROCustRotZBn "top" $tmargin abRTROSep1
	-ac abRTROCustRotZBn "left" $lmargin abRTROCustRotYBn
	-af abRTROCustRotZBn "right" $rmargin
	
	-ac abRTROSep2 "top" $tmargin abRTROCustRotYBn
	-af abRTROSep2 "left" $lmargin
	-af abRTROSep2 "right" $rmargin
	
	-ac abRTROMirrorRotChkBx "top" $tmargin abRTROSep2
	-af abRTROMirrorRotChkBx "left" $lmargin
	-af abRTROMirrorRotChkBx "right" $rmargin
	
	-ac abRTROSep3 "top" $tmargin abRTROMirrorRotChkBx
	-af abRTROSep3 "left" $lmargin
	-af abRTROSep3 "right" $rmargin
	
	-ac abRTEOToggleSelLRA0Bn "top" $tmargin abRTROSep3
	-af abRTEOToggleSelLRA0Bn "left" $lmargin
	-af abRTEOToggleSelLRA0Bn "right" $rmargin
	
	-ac abRTEOToggleHierarchyLRA0Bn "top" $tmargin abRTEOToggleSelLRA0Bn
	-af abRTEOToggleHierarchyLRA0Bn "left" $lmargin
	-af abRTEOToggleHierarchyLRA0Bn "right" $rmargin
	
	
	abRTROForm
	;
	
	// showWindow
	showWindow abRTROWin;
}


global proc abRTRORotateJointLA(int $axis, float $custVal, int $mirrorRot){
	// rotates the selected joint(s) LRA positive 90 degrees around X, Y, Z ($axis: 0,1,2) axes or negative 90 degrees around X, Y, Z ($axis: 3,4,5).  For these operations, custVal is ignored
	// if $axis value is 6,7, or 8, will rotate in the appropriate axis $custVal degrees
	// if $mirrorRot, then rotations will be mirrored to the mirror joint, if any.
	
	float $aRot[] = {0, 0, 0};
	
	switch ($axis){
		case 0: $aRot[0] = 90; break;
		case 1: $aRot[1] = 90; break;
		case 2: $aRot[2] = 90; break;
		case 3: $aRot[0] = -90; break;
		case 4: $aRot[1] = -90; break;
		case 5: $aRot[2] = -90; break;
		case 6: $aRot[0] = $custVal; break;
		case 7: $aRot[1] = $custVal; break;
		case 8: $aRot[2] = $custVal; break;
	}
	
	xform -r -os -ra $aRot[0] $aRot[1] $aRot[2];
	joint -e -zso;
	makeIdentity -apply true;
	
	if ($mirrorRot){
		
		// mirror rotation to joint
		
		string $mJnt;
		int $i, $mirroredBehavior;
		
		string $aJntSel[] = `ls -sl -type joint`;
		int $unMirroredCount = 0;
		
		for ($i=0;$i<size($aJntSel);$i++){
			
			$mJnt = abRTGetMirrorObj($aJntSel[$i]);
			
			if ($mJnt == ""){
				$unMirroredCount++;
				continue;
			}
			
			select -r $mJnt;
			
			xform -r -os -ra $aRot[0] $aRot[1] $aRot[2];
			joint -e -zso;
			makeIdentity -apply true;
		}
		
		select -r $aJntSel;
	}
	
}


global proc abRTROToggleLRA(int $selected){
	// toggles selected joint LRAs if $selected is true, otherwises toggles all children joints
	
	string $aJnts[] = `ls -sl -type joint`;
	string $aRel[], $jnt;
	
	// if no joints are selected, toggle them all
	if (size($aJnts) == 0) $aJnts = `ls -type joint`;
	
	if (size($aJnts) > 0){
		
		int $targVal = 1-(`toggle -q -la $aJnts[0]`);
		
		if (!$selected){
			$aRel = `listRelatives -ad -fullPath -type joint $aJnts`;
			$aJnts = stringArrayCatenate($aJnts, $aRel);
		}
		
		for ($jnt in $aJnts) if (`toggle -q -la $jnt` != $targVal) toggle -la $jnt;
	}
	
}


global proc string abRTGetRigGrpFromSelCtrl(string $selCtrl){
	// attempts to return the rigGrp from a selected control curve on the rig or $selCtrl if not ""
	
	string $rigGrp, $ctrl, $aParents[], $aSel[];
	int $i;
	
	if ($selCtrl == ""){
		
		//$aSel = `ls -sl "*_ctrl"`;
		$aSel = abRTStringArrayMatch(`ls -sl`, ".+_ctrl$");
		
		if (size($aSel) == 0){
			warning "Select at least one control on your character and try again.";
			return "";
		}
		
		$ctrl = $aSel[0];
	}else{
		$ctrl = $selCtrl;
	}
	
	// find rigGrp
	while ($ctrl != ""){
		$aParents[size($aParents)] = $ctrl;
		$ctrl = firstParentOf($ctrl);
	}
	
	// now sort through aParents in reverse order to get master rig_grp
	for ($i=size($aParents)-1;$i>=0;$i--){
		if (endsWith($aParents[$i], "rig_grp")){
			$rigGrp = $aParents[$i];
			break;
		}
	}
	
	if ($rigGrp == "") warning "Unable to determine character rigGrp.";
	
	return $rigGrp;
}


global proc abRTResetCharPose(int $resetAll){
	// called from UI to reset the pose of the selected character (select rootCon)
	// if $resetAll, it will reset all of the controls for the character, otherwise it will only reset the selected controls
	
	string $rigGrp = abRTGetRigGrpFromSelCtrl("");
	
	if ($rigGrp == "") return; 
	else abRTQuickCharDefaultPose($rigGrp, $resetAll);
	
}


global proc abRTQuickCharDefaultPose(string $rigGrp, int $resetAll){
	// quick and dirty way to reset character to default pose -- if $resetAll, all controls will be reset; otherwise only selected
	
	if (!objExists($rigGrp)) return;
	
	string $aCtrlCrvs[] = abRTGetRigGrpCtrlCurves($rigGrp);
	string $ctrl, $attType, $att, $aAtts[], $aAttTable[], $aValueTable[], $aCBSelAtt[], $myIntersector;
	int $i, $attInd;
	int $useCBSel = false;
	
	// if using selection in channelBox, create an intersector to quickly suss which atts need to be reset
	if (!$resetAll){
		$aCBSelAtt = `channelBox -q -sma mainChannelBox`;
		if (size($aCBSelAtt) > 0){
			$useCBSel = true;
			$myIntersector = `stringArrayIntersector`;
			print "Resetting channelBox selection";
		}
	}
	
	string $aDef[] = {"tx","0","ty","0","tz","0","rx","0","ry","0","rz","0","ikFkBlend","1","ikVis","0","fkVis","0","ikCtrlVis","0","legStretch","0","kneeStretch","0","ankleStretch","0","armStretch","0","elbowStretch","0","wristStretch","0","armTwist","0","pvControl","1","maxStretch","3","legTwist","0","footRoll","0","footBreak","40","ballRaise","0","toeRaise","0","toeRoll","0","toeTwist","0","ballTwist","0","heelTwist","0","stretchyLeg","1","rootCtrl","1","cogCtrl","0","lowSpineCtrl","0","hiSpineCtrl","0","masterSpineCtrl","0","headCtrl","0","head","0","lfArmIkCtrl","0","rtArmIkCtrl","0","snapElbow","0","snapKnee","0","align","0","useRootSpace","0","useCogSpace","0","spineShaper","1","masterScale","1","skeletonVis","1","ikSpineVis","0","rigSettingsCtrlVis","1","fkAlign","0","masterCup","0","masterFist","0","masterSpread","0","thumbFistDamp","0.3","midCurlAmt","1","tipCurlAmt","1.4","thumbCurl","0","indexCurl","0","middleCurl","0","ringCurl","0","pinkyCurl","0","thumbBase","0","thumbMid","0","thumbTip","0","thumbSpread","0","thumbRoll","0","thumbIK","0","indexBase","0","indexMid","0","indexTip","0","indexSpread","0","indexRoll","0","indexIK","0","middleBase","0","middleMid","0","middleTip","0","middleSpread","0","middleRoll","0","middleIK","0","ringBase","0","ringMid","0","ringTip","0","ringSpread","0","ringRoll","0","ringIK","0","pinkyBase","0","pinkyMid","0","pinkyTip","0","pinkySpread","0","pinkyRoll","0","pinkyIK","0","fkFingerCtrlVis","1","fingerMasterCtrlVis","1","neckCtrlsVis","1","lowLegTwistCtrl","0","forearmTwistCtrl","0","upArmTwistCtrl","0","wristTwistCtrl","0"};
	
	// put $aDef info into two arrays
	for ($i=0;$i<size($aDef);$i+=2){
		$aAttTable[size($aAttTable)] = $aDef[$i];
		$aValueTable[size($aValueTable)] = $aDef[$i+1];
	}
	
	for ($ctrl in $aCtrlCrvs){
		
		if (!$resetAll && size(`ls -sl $ctrl`) == 0) continue; // if this control isn't selected and resetAll is false, then skip it
		
		$aAtts = `listAttr -k -sn $ctrl`;
		
		if ($useCBSel){
			stringArrayIntersector -edit -reset $myIntersector;
			stringArrayIntersector -edit -intersect $aAtts $myIntersector;
			stringArrayIntersector -edit -intersect $aCBSelAtt $myIntersector;
			$aAtts = `stringArrayIntersector -query $myIntersector`;
		}
		
		for ($att in $aAtts){
			$attInd = abRTGetPosInStrArray($att, $aAttTable);
			
			if ($attInd > -1 && attributeExists($att, $ctrl)){
				
				$attType = `getAttr -type ($ctrl+"."+$att)`;
				
				if ($attType == "float" || $attType == "double" || $attType == "doubleLinear" || $attType == "doubleAngle"){
					setAttr ($ctrl+"."+$att) (float($aValueTable[$attInd]));
				}else if($attType == "string"){
					setAttr -type "string" ($ctrl+"."+$att) ($aValueTable[$attInd]);
				}else if($attType == "int" || $attType == "enum" || $attType == "short" || $attType == "long" || $attType == "bool"){
					setAttr ($ctrl+"."+$att) (int($aValueTable[$attInd]));
				}
			}
		}
	}
	
	if ($myIntersector != "") deleteUI $myIntersector;
	
	// hide "some objects can't be rotated" warning
	if ($resetAll) print "\n";
}


global proc abRTSelWeightJntsUI(){
	// builds UI used for easy selection of weight joints
	
	if (`window -exists abRTSWJWin`){
		deleteUI -window abRTSWJWin;
	}
	window -t "abSelectWeightJnts" -w 180 -h 405 -menuBar false -minimizeButton false -maximizeButton false abRTSWJWin;
		
	formLayout -numberOfDivisions 100 abRTSWJForm;
	
	optionMenu abRTSWJCharOpMn;
	
	string $aSkeletons[] = `ls -type transform "*keleton_grp"`;
	
	if (size($aSkeletons) == 0){
		// There are no skeletons in the scene
		deleteUI -window abRTSWJWin;
		warning "There are no valid skeletons in the scene.";
		return;
	}
	
	button -label "Refresh" -h 28 -c "deleteUI -window abRTSWJWin; abRTSelWeightJntsUI();" abRTSWJRefreshBn;
	
	button -label "Head/Neck" -c "abRTSelWeightJnts(\"headNeck\");" abRTSWJHeadNeckBn;
	
	button -label "Left Eye" -c "abRTSelWeightJnts(\"lfEye\");" abRTSWJLfEyeBn;
	button -label "Right Eye" -c "abRTSelWeightJnts(\"rtEye\");" abRTSWJRtEyeBn;
	button -label "Jaw" -c "abRTSelWeightJnts(\"jaw\");" abRTSWJJawBn;
	
	button -label "Spine" -c "abRTSelWeightJnts(\"spine\");" abRTSWJSpineBn;
	
	button -label "Left Leg" -c "abRTSelWeightJnts(\"lfLeg\");" abRTSWJLfLegBn;
	button -label "Right Leg" -c "abRTSelWeightJnts(\"rtLeg\");" abRTSWJRtLegBn;
	
	button -label "Left Arm" -c "abRTSelWeightJnts(\"lfArm\");" abRTSWJLfArmBn;
	button -label "Right Arm" -c "abRTSelWeightJnts(\"rtArm\");" abRTSWJRtArmBn;
	
	button -label "Left Hand" -c "abRTSelWeightJnts(\"lfHand\");" abRTSWJLfHandBn;
	
	button -label "T" -c "abRTSelWeightJnts(\"lfThumb\");" abRTSWJLfThumbBn;
	button -label "I" -c "abRTSelWeightJnts(\"lfIndex\");" abRTSWJLfIndexBn;
	button -label "M" -c "abRTSelWeightJnts(\"lfMiddle\");" abRTSWJLfMiddleBn;
	button -label "R" -c "abRTSelWeightJnts(\"lfRing\");" abRTSWJLfRingBn;
	button -label "P" -c "abRTSelWeightJnts(\"lfPinky\");" abRTSWJLfPinkyBn;
	
	button -label "Right Hand" -c "abRTSelWeightJnts(\"rtHand\");" abRTSWJRtHandBn;
	
	button -label "T" -c "abRTSelWeightJnts(\"rtThumb\");" abRTSWJRtThumbBn;
	button -label "I" -c "abRTSelWeightJnts(\"rtIndex\");" abRTSWJRtIndexBn;
	button -label "M" -c "abRTSelWeightJnts(\"rtMiddle\");" abRTSWJRtMiddleBn;
	button -label "R" -c "abRTSelWeightJnts(\"rtRing\");" abRTSWJRtRingBn;
	button -label "P" -c "abRTSelWeightJnts(\"rtPinky\");" abRTSWJRtPinkyBn;
	
	button -label "All Default Weight Jnts" -h 28 -c "abRTSelWeightJnts(\"allDefault\");" abRTSWJAllBn;
	
	separator abRTSWJHeadSep1;
	separator abRTSWJHeadSep2;
	separator abRTSWJSep1;
	separator abRTSWJSep2;
	separator abRTSWJSep3;
	separator abRTSWJSep4;
	
	int $lmargin = 2;
	int $rmargin = 2;
	int $tmargin = 2;
	int $sepMargin = 5;
	
	formLayout -e
	
	-af abRTSWJCharOpMn "top" 5 
	-af abRTSWJCharOpMn "left" $lmargin
	-af abRTSWJCharOpMn "right" $rmargin
	
	-ac abRTSWJSep1 "top" $sepMargin abRTSWJCharOpMn
	-af abRTSWJSep1 "left" $lmargin
	-af abRTSWJSep1 "right" $rmargin
	
	-ac abRTSWJAllBn "top" $sepMargin abRTSWJSep1
	-af abRTSWJAllBn "left" $lmargin
	-af abRTSWJAllBn "right" $rmargin
	
	-ac abRTSWJHeadSep1 "top" $sepMargin abRTSWJAllBn
	-af abRTSWJHeadSep1 "left" $lmargin
	-af abRTSWJHeadSep1 "right" $rmargin
	
	-ac abRTSWJHeadNeckBn "top" $sepMargin abRTSWJHeadSep1
	-af abRTSWJHeadNeckBn "left" $lmargin
	-af abRTSWJHeadNeckBn "right" $rmargin
	
	-ac abRTSWJLfEyeBn "top" $tmargin abRTSWJHeadNeckBn
	-af abRTSWJLfEyeBn "left" $lmargin
	-ap abRTSWJLfEyeBn "right" $rmargin 50
	
	-ac abRTSWJRtEyeBn "top" $tmargin abRTSWJHeadNeckBn
	-ac abRTSWJRtEyeBn "left" $lmargin abRTSWJLfEyeBn
	-af abRTSWJRtEyeBn "right" $rmargin
	
	-ac abRTSWJJawBn "top" $tmargin abRTSWJLfEyeBn
	-af abRTSWJJawBn "left" $lmargin
	-af abRTSWJJawBn "right" $rmargin
	
	-ac abRTSWJHeadSep2 "top" $sepMargin abRTSWJJawBn
	-af abRTSWJHeadSep2 "left" $lmargin
	-af abRTSWJHeadSep2 "right" $rmargin
	
	-ac abRTSWJSpineBn "top" $sepMargin abRTSWJHeadSep2
	-af abRTSWJSpineBn "left" $lmargin
	-af abRTSWJSpineBn "right" $rmargin
	
	-ac abRTSWJLfArmBn "top" $tmargin abRTSWJSpineBn
	-af abRTSWJLfArmBn "left" $lmargin
	-ap abRTSWJLfArmBn "right" $rmargin 50
	
	-ac abRTSWJRtArmBn "top" $tmargin abRTSWJSpineBn
	-ac abRTSWJRtArmBn "left" $lmargin abRTSWJLfArmBn
	-af abRTSWJRtArmBn "right" $rmargin
	
	-ac abRTSWJLfLegBn "top" $tmargin abRTSWJLfArmBn
	-af abRTSWJLfLegBn "left" $lmargin
	-ap abRTSWJLfLegBn "right" $rmargin 50
	
	-ac abRTSWJRtLegBn "top" $tmargin abRTSWJRtArmBn
	-ac abRTSWJRtLegBn "left" $lmargin abRTSWJLfLegBn
	-af abRTSWJRtLegBn "right" $rmargin
	
	-ac abRTSWJSep2 "top" $sepMargin abRTSWJLfLegBn
	-af abRTSWJSep2 "left" $lmargin
	-af abRTSWJSep2 "right" $rmargin
	
	-ac abRTSWJLfHandBn "top" $sepMargin abRTSWJSep2
	-af abRTSWJLfHandBn "left" $lmargin
	-af abRTSWJLfHandBn "right" $rmargin
	
	-ac abRTSWJLfThumbBn "top" $tmargin abRTSWJLfHandBn
	-af abRTSWJLfThumbBn "left" $lmargin
	-ap abRTSWJLfThumbBn "right" $rmargin 20
	
	-ac abRTSWJLfIndexBn "top" $tmargin abRTSWJLfHandBn
	-ac abRTSWJLfIndexBn "left" $lmargin abRTSWJLfThumbBn
	-ap abRTSWJLfIndexBn "right" $rmargin 40
	
	-ac abRTSWJLfMiddleBn "top" $tmargin abRTSWJLfHandBn
	-ac abRTSWJLfMiddleBn "left" $lmargin abRTSWJLfIndexBn
	-ap abRTSWJLfMiddleBn "right" $rmargin 60
	
	-ac abRTSWJLfRingBn "top" $tmargin abRTSWJLfHandBn
	-ac abRTSWJLfRingBn "left" $lmargin abRTSWJLfMiddleBn
	-ap abRTSWJLfRingBn "right" $rmargin 80
	
	-ac abRTSWJLfPinkyBn "top" $tmargin abRTSWJLfHandBn
	-ac abRTSWJLfPinkyBn "left" $lmargin abRTSWJLfRingBn
	-af abRTSWJLfPinkyBn "right" $rmargin
	
	-ac abRTSWJSep3 "top" $sepMargin abRTSWJLfPinkyBn
	-af abRTSWJSep3 "left" $lmargin
	-af abRTSWJSep3 "right" $rmargin
	
	-ac abRTSWJRtHandBn "top" $sepMargin abRTSWJSep3
	-af abRTSWJRtHandBn "left" $lmargin
	-af abRTSWJRtHandBn "right" $rmargin
	
	-ac abRTSWJRtThumbBn "top" $tmargin abRTSWJRtHandBn
	-af abRTSWJRtThumbBn "left" $lmargin
	-ap abRTSWJRtThumbBn "right" $rmargin 20
	
	-ac abRTSWJRtIndexBn "top" $tmargin abRTSWJRtHandBn
	-ac abRTSWJRtIndexBn "left" $lmargin abRTSWJRtThumbBn
	-ap abRTSWJRtIndexBn "right" $rmargin 40
	
	-ac abRTSWJRtMiddleBn "top" $tmargin abRTSWJRtHandBn
	-ac abRTSWJRtMiddleBn "left" $lmargin abRTSWJRtIndexBn
	-ap abRTSWJRtMiddleBn "right" $rmargin 60
	
	-ac abRTSWJRtRingBn "top" $tmargin abRTSWJRtHandBn
	-ac abRTSWJRtRingBn "left" $lmargin abRTSWJRtMiddleBn
	-ap abRTSWJRtRingBn "right" $rmargin 80
	
	-ac abRTSWJRtPinkyBn "top" $tmargin abRTSWJRtHandBn
	-ac abRTSWJRtPinkyBn "left" $lmargin abRTSWJRtRingBn
	-af abRTSWJRtPinkyBn "right" $rmargin
	
	-ac abRTSWJSep4 "top" $sepMargin abRTSWJRtPinkyBn
	-af abRTSWJSep4 "left" $lmargin
	-af abRTSWJSep4 "right" $rmargin
	
	-ac abRTSWJRefreshBn "top" $sepMargin abRTSWJSep4
	-af abRTSWJRefreshBn "left" $lmargin
	-af abRTSWJRefreshBn "right" $rmargin
	
	abRTSWJForm
	;
	
	// update option menu
	string $skeleton;
	for ($skeleton in $aSkeletons) menuItem -label $skeleton -p abRTSWJCharOpMn;
	
	
	// showWindow
	showWindow abRTSWJWin;
	
}


global proc abRTSelWeightJnts(string $selKey){
	// selects weight joint sets for cur character (services abRTSelWeightJntsUI())
	
	int $mods = `getModifiers`;
	
	if (!`window -exists abRTSWJWin`) return;
	
	string $skeletonGrp = `optionMenu -q -v abRTSWJCharOpMn`;
	
	if (!objExists($skeletonGrp) || $skeletonGrp == ""){
		deleteUI -window abRTSWJWin;
		warning "Selected skeleton no longer exists.";
		return;
	}
	
	string $aSelJnts[], $aJnts[], $jnt, $jntSuffix;
	string $skelSuffix = "_skeleton_grp"; // suffix used in global naming convention
	int $addSpineJnts = false;
	
	string $charName = substring($skeletonGrp, 1, (size($skeletonGrp)-size($skelSuffix)));
	
	switch($selKey){
		
		case "allDefault":
			$aJnts = {"_spine_end_jnt","_lf_upLegWeight_jnt","_lf_kneeWeight_jnt","_lf_ankleWeight_jnt","_lf_upLegWeightSplit_1_jnt","_lf_upLegWeightSplit_2_jnt","_lf_upLegWeightSplit_3_jnt","_lf_upLegWeightSplit_4_jnt","_lf_upLegWeightSplit_5_jnt","_lf_upLegWeightSplit_6_jnt","_lf_kneeWeightSplit_1_jnt","_lf_kneeWeightSplit_2_jnt","_lf_kneeWeightSplit_3_jnt","_lf_kneeWeightSplit_4_jnt","_lf_kneeWeightSplit_5_jnt","_lf_kneeWeightSplit_6_jnt","_lf_ball_jnt","_rt_upLegWeight_jnt","_rt_kneeWeight_jnt","_rt_ankleWeight_jnt","_rt_upLegWeightSplit_1_jnt","_rt_upLegWeightSplit_2_jnt","_rt_upLegWeightSplit_3_jnt","_rt_upLegWeightSplit_4_jnt","_rt_upLegWeightSplit_5_jnt","_rt_upLegWeightSplit_6_jnt","_rt_kneeWeightSplit_1_jnt","_rt_kneeWeightSplit_2_jnt","_rt_kneeWeightSplit_3_jnt","_rt_kneeWeightSplit_4_jnt","_rt_kneeWeightSplit_5_jnt","_rt_kneeWeightSplit_6_jnt","_rt_ball_jnt","_lf_upArmWeight_jnt","_lf_elbowWeight_jnt","_lf_upArmWeightSplit_1_jnt","_lf_upArmWeightSplit_2_jnt","_lf_upArmWeightSplit_3_jnt","_lf_upArmWeightSplit_4_jnt","_lf_upArmWeightSplit_5_jnt","_lf_upArmWeightSplit_6_jnt","_lf_elbowWeightSplit_1_jnt","_lf_elbowWeightSplit_2_jnt","_lf_elbowWeightSplit_3_jnt","_lf_elbowWeightSplit_4_jnt","_lf_elbowWeightSplit_5_jnt","_lf_elbowWeightSplit_6_jnt","_lf_wristWeight_jnt","_rt_upArmWeight_jnt","_rt_elbowWeight_jnt","_rt_wristWeight_jnt","_rt_upArmWeightSplit_1_jnt","_rt_upArmWeightSplit_2_jnt","_rt_upArmWeightSplit_3_jnt","_rt_upArmWeightSplit_4_jnt","_rt_upArmWeightSplit_5_jnt","_rt_upArmWeightSplit_6_jnt","_rt_elbowWeightSplit_1_jnt","_rt_elbowWeightSplit_2_jnt","_rt_elbowWeightSplit_3_jnt","_rt_elbowWeightSplit_4_jnt","_rt_elbowWeightSplit_5_jnt","_rt_elbowWeightSplit_6_jnt","_lf_hand_jnt","_lf_thumb_a_jnt","_lf_thumb_b_jnt","_lf_thumb_c_jnt","_lf_index_a_jnt","_lf_index_b_jnt","_lf_index_c_jnt","_lf_middle_a_jnt","_lf_middle_b_jnt","_lf_middle_c_jnt","_lf_ringCup_jnt","_lf_ring_a_jnt","_lf_ring_b_jnt","_lf_ring_c_jnt","_lf_pinkyCup_jnt","_lf_pinky_a_jnt","_lf_pinky_b_jnt","_lf_pinky_c_jnt","_rt_hand_jnt","_rt_thumb_a_jnt","_rt_thumb_b_jnt","_rt_thumb_c_jnt","_rt_index_a_jnt","_rt_index_b_jnt","_rt_index_c_jnt","_rt_middle_a_jnt","_rt_middle_b_jnt","_rt_middle_c_jnt","_rt_ringCup_jnt","_rt_ring_a_jnt","_rt_ring_b_jnt","_rt_ring_c_jnt","_rt_pinkyCup_jnt","_rt_pinky_a_jnt","_rt_pinky_b_jnt","_rt_pinky_c_jnt","_neck_jnt","_neck_1_jnt","_neck_2_jnt","_neck_3_jnt","_neck_4_jnt","_head_a_jnt","_hip_jnt"};
			//$aJnts = {"_spine_end_jnt","_neck_jnt","_neck_1_jnt","_neck_2_jnt","_neck_3_jnt","_neck_4_jnt","_head_a_jnt","_lf_clavicle_jnt","_lf_upArm_jnt","_lf_elbow_jnt","_lf_hand_jnt","_lf_thumb_a_jnt","_lf_thumb_b_jnt","_lf_thumb_c_jnt","_lf_index_a_jnt","_lf_index_b_jnt","_lf_index_c_jnt","_lf_middle_a_jnt","_lf_middle_b_jnt","_lf_middle_c_jnt","_lf_ringCup_jnt","_lf_ring_a_jnt","_lf_ring_b_jnt","_lf_ring_c_jnt","_lf_pinkyCup_jnt","_lf_pinky_a_jnt","_lf_pinky_b_jnt","_lf_pinky_c_jnt","_rt_clavicle_jnt","_rt_upArm_jnt","_rt_elbow_jnt","_rt_hand_jnt","_rt_thumb_a_jnt","_rt_thumb_b_jnt","_rt_thumb_c_jnt","_rt_index_a_jnt","_rt_index_b_jnt","_rt_index_c_jnt","_rt_middle_a_jnt","_rt_middle_b_jnt","_rt_middle_c_jnt","_rt_ringCup_jnt","_rt_ring_a_jnt","_rt_ring_b_jnt","_rt_ring_c_jnt","_rt_pinkyCup_jnt","_rt_pinky_a_jnt","_rt_pinky_b_jnt","_rt_pinky_c_jnt","_hip_jnt","_lf_upLeg_jnt","_lf_knee_jnt","_lf_ankle_jnt","_lf_ball_jnt","_rt_upLeg_jnt","_rt_knee_jnt","_rt_ankle_jnt","_rt_ball_jnt"};
			$addSpineJnts = true;
			break;
		case "headNeck":
			$aJnts = {"_head_a_jnt","_neck_jnt","_neck_1_jnt","_neck_2_jnt","_neck_3_jnt","_neck_4_jnt"};
			break;
		case "lfEye":
			$aJnts = {"_lf_eye_jnt"};
			break;
		case "rtEye":
			$aJnts = {"_rt_eye_jnt"};
			break;
		case "jaw":
			$aJnts = {"_jaw_b_jnt"};
			break;	
		case "spine":
			$aJnts = {"_spine_end_jnt","_hip_jnt"};
			$addSpineJnts = true;
			break;
		case "lfLeg":
			$aJnts = {"_lf_upLegWeight_jnt","_lf_kneeWeight_jnt","_lf_ankleWeight_jnt","_lf_upLegWeightSplit_1_jnt","_lf_upLegWeightSplit_2_jnt","_lf_upLegWeightSplit_3_jnt","_lf_upLegWeightSplit_4_jnt","_lf_upLegWeightSplit_5_jnt","_lf_upLegWeightSplit_6_jnt","_lf_kneeWeightSplit_1_jnt","_lf_kneeWeightSplit_2_jnt","_lf_kneeWeightSplit_3_jnt","_lf_kneeWeightSplit_4_jnt","_lf_kneeWeightSplit_5_jnt","_lf_kneeWeightSplit_6_jnt","_lf_ball_jnt"};
			break;		
		case "rtLeg":
			$aJnts = {"_rt_upLegWeight_jnt","_rt_kneeWeight_jnt","_rt_ankleWeight_jnt","_rt_upLegWeightSplit_1_jnt","_rt_upLegWeightSplit_2_jnt","_rt_upLegWeightSplit_3_jnt","_rt_upLegWeightSplit_4_jnt","_rt_upLegWeightSplit_5_jnt","_rt_upLegWeightSplit_6_jnt","_rt_kneeWeightSplit_1_jnt","_rt_kneeWeightSplit_2_jnt","_rt_kneeWeightSplit_3_jnt","_rt_kneeWeightSplit_4_jnt","_rt_kneeWeightSplit_5_jnt","_rt_kneeWeightSplit_6_jnt","_rt_ball_jnt"};
			break;		
		case "lfArm":
			$aJnts = {"_lf_upArmWeight_jnt","_lf_elbowWeight_jnt","_lf_upArmWeightSplit_1_jnt","_lf_upArmWeightSplit_2_jnt","_lf_upArmWeightSplit_3_jnt","_lf_upArmWeightSplit_4_jnt","_lf_upArmWeightSplit_5_jnt","_lf_upArmWeightSplit_6_jnt","_lf_elbowWeightSplit_1_jnt","_lf_elbowWeightSplit_2_jnt","_lf_elbowWeightSplit_3_jnt","_lf_elbowWeightSplit_4_jnt","_lf_elbowWeightSplit_5_jnt","_lf_elbowWeightSplit_6_jnt","_lf_wristWeight_jnt"};
			break;		
		case "rtArm":
			$aJnts = {"_rt_upArmWeight_jnt","_rt_elbowWeight_jnt","_rt_wristWeight_jnt","_rt_upArmWeightSplit_1_jnt","_rt_upArmWeightSplit_2_jnt","_rt_upArmWeightSplit_3_jnt","_rt_upArmWeightSplit_4_jnt","_rt_upArmWeightSplit_5_jnt","_rt_upArmWeightSplit_6_jnt","_rt_elbowWeightSplit_1_jnt","_rt_elbowWeightSplit_2_jnt","_rt_elbowWeightSplit_3_jnt","_rt_elbowWeightSplit_4_jnt","_rt_elbowWeightSplit_5_jnt","_rt_elbowWeightSplit_6_jnt"};
			break;
		case "lfHand":
			$aJnts = {"_lf_hand_jnt","_lf_thumb_a_jnt","_lf_thumb_b_jnt","_lf_thumb_c_jnt","_lf_index_a_jnt","_lf_index_b_jnt","_lf_index_c_jnt","_lf_middle_a_jnt","_lf_middle_b_jnt","_lf_middle_c_jnt","_lf_ringCup_jnt","_lf_ring_a_jnt","_lf_ring_b_jnt","_lf_ring_c_jnt","_lf_pinkyCup_jnt","_lf_pinky_a_jnt","_lf_pinky_b_jnt","_lf_pinky_c_jnt"};
			break;		
		case "rtHand":
			$aJnts = {"_rt_hand_jnt","_rt_thumb_a_jnt","_rt_thumb_b_jnt","_rt_thumb_c_jnt","_rt_index_a_jnt","_rt_index_b_jnt","_rt_index_c_jnt","_rt_middle_a_jnt","_rt_middle_b_jnt","_rt_middle_c_jnt","_rt_ringCup_jnt","_rt_ring_a_jnt","_rt_ring_b_jnt","_rt_ring_c_jnt","_rt_pinkyCup_jnt","_rt_pinky_a_jnt","_rt_pinky_b_jnt","_rt_pinky_c_jnt"};
			break;
		case "lfThumb":
			$aJnts = {"_lf_thumb_a_jnt","_lf_thumb_b_jnt","_lf_thumb_c_jnt"};
			break;		
		case "lfIndex":
			$aJnts = {"_lf_index_a_jnt","_lf_index_b_jnt","_lf_index_c_jnt"};
			break;	
		case "lfMiddle":
			$aJnts = {"_lf_middle_a_jnt","_lf_middle_b_jnt","_lf_middle_c_jnt"};
			break;		
		case "lfRing":
			$aJnts = {"_lf_ringCup_jnt","_lf_ring_a_jnt","_lf_ring_b_jnt","_lf_ring_c_jnt"};
			break;	
		case "lfPinky":
			$aJnts = {"_lf_pinkyCup_jnt","_lf_pinky_a_jnt","_lf_pinky_b_jnt","_lf_pinky_c_jnt"};
			break;		
		case "rtThumb":
			$aJnts = {"_rt_thumb_a_jnt","_rt_thumb_b_jnt","_rt_thumb_c_jnt"};
			break;		
		case "rtIndex":
			$aJnts = {"_rt_index_a_jnt","_rt_index_b_jnt","_rt_index_c_jnt"};
			break;	
		case "rtMiddle":
			$aJnts = {"_rt_middle_a_jnt","_rt_middle_b_jnt","_rt_middle_c_jnt"};
			break;		
		case "rtRing":
			$aJnts = {"_rt_ringCup_jnt","_rt_ring_a_jnt","_rt_ring_b_jnt","_rt_ring_c_jnt"};
			break;	
		case "rtPinky":
			$aJnts = {"_rt_pinkyCup_jnt","_rt_pinky_a_jnt","_rt_pinky_b_jnt","_rt_pinky_c_jnt"};
			break;		
			
	}
	
	// add those joints that exist to $aSelJnts
	for ($jntSuffix in $aJnts){
		$jnt = $charName + $jntSuffix;
		if (objExists($jnt))
			$aSelJnts[size($aSelJnts)] = $jnt;
	}
	
	// add weight spine jnts
	if ($addSpineJnts){
		
		string $weightSpineGrp = $skeletonGrp+"|"+"weightSpine_grp";
		string $aWeightSpineJnts[];
		
		if (objExists($weightSpineGrp) && nodeType($weightSpineGrp) == "transform"){
			$aWeightSpineJnts = `listRelatives -c -type joint $weightSpineGrp`;
			$aSelJnts = stringArrayCatenate($aSelJnts, $aWeightSpineJnts);
		}
		
	}
	
	if ($mods == 4){
		// ctrl -- subtract
		select -deselect $aSelJnts;
	}else if ($mods == 1){
		// shift -- add
		select -add $aSelJnts;
	}else{
		select -r $aSelJnts;
	}
	
}


global proc string[] abRTDuplicateJointHierarchy(string $aTargets[], string $aNames[], string $grp){
	// will create joint chain based on location of objects in $aTargets, rename them the names in $aNames, and place the result in the existing group $grp
	// returns new pathNames
	
	string $jnt, $aRet[], $aRel[], $aStr[];
	float $xForm[], $jointXform[], $radius;
	int $aIsJnt[], $i; // tracks non joints so they can be aligned after the chain has been created
	
	if (size($aTargets) > size($aNames))
		return $aRet;
	
	string $tLoc = abRTMakeLocator("abRTDupJntHierarchy_loc");
	
	for ($i=0;$i<size($aTargets);$i++){
		
		if (`nodeType $aTargets[$i]` == "joint"){
			// duplicate the joint
			
			$aStr = `duplicate -po -name $aNames[$i] $aTargets[$i]`;
			//$aStr = `duplicate -rr -name $aNames[$i] $aTargets[$i]`;
			//$aRel = `listRelatives -c -fullPath $aStr[0]`;
			//if (size($aRel) > 0)
			//	delete $aRel;
			
			$jnt = $aStr[0];
			$aIsJnt[$i] = true;
		}else{
			
			abRTSnapToPosition($aTargets[$i], $tLoc);
			
			$xForm = `xform -q -ws -t $tLoc`;
			
			$jnt = `joint -p $xForm[0] $xForm[1] $xForm[2] -n $aNames[$i]`;
			$aIsJnt[$i] = false;
		}
		
		if ($i == 0){
			
			if ($grp != "" && `objExists $grp`)
				$jnt = abRTParent($jnt, $grp);
			else if (firstParentOf($jnt) != "")
				$jnt = `parent -w $jnt`;
			
		}else{
			$jnt = abRTParent($jnt, $aRet[$i-1]);
		}
		
		$aRet[$i] = $jnt;
	}
	
	delete $tLoc;
	
	for ($i=0;$i<size($aIsJnt);$i++){
		if (!$aIsJnt[$i]) joint -e -zso -oj xyz -sao yup $aRet[$i];
	}
	
	select -clear;
	
	return $aRet;
	
}


global proc string abRTRigRootFolder(){
	// makes the root folder for all the riggery or returns it's path if it already exists
	
	string $charName = abRTGetGlobal("name");
	string $folderName = $charName+"_rig_grp";
	if (!`objExists $folderName`) group -em -name $folderName;
	return $folderName;
	
}


global proc abRTColorObj(string $obj, string $indexKey, int $indexVal){
	// sets $obj color to $indexKey (which must be a global key, like "rootCtrlColor" that shows up in globals)
	// or to $indexVal if $indexVal > -1
	
	string $transform = $obj;
	string $colorIndexKeyAttName = "colorIndexKey";
	string $colorIndexValAttName = "colorIndexVal";
	int $index;
	
	if ($indexVal <= -1){
		if ($indexKey != ""){
			$index = abRTGetGlobal($indexKey);
		}else{
			return;
		}
	}else{
		$index = $indexVal;
	}
	
	string $aRel[] = `listRelatives -c -fullPath -type shape $obj`;
	if (size($aRel) == 1){
		// obj is transform, need to find its shape
		$obj = $aRel[0];
	}else{
		// obj is a shape, need to find transform
		$transform = firstParentOf($obj);
	}
	
	if (`attributeExists "overrideColor" $obj`){
		if (!`getAttr ($obj+".overrideEnabled")`) setAttr ($obj+".overrideEnabled") true;
		
		if (`getAttr -settable ($obj+".overrideColor")`){
			setAttr ($obj+".overrideColor") $index;
			
			// store index for this control attribute to transform
			if ($indexKey != ""){
				if (!attributeExists($colorIndexKeyAttName, $transform))
					addAttr -ln $colorIndexKeyAttName -dt "string" -hidden true $transform;
				setAttr -type "string" ($transform+"."+$colorIndexKeyAttName) $indexKey;
			}
			
			if (!attributeExists($colorIndexValAttName, $transform))
				addAttr -ln $colorIndexValAttName -at "byte" -hidden true $transform;
			setAttr ($transform+"."+$colorIndexValAttName) $index;
			
		}else{
			print ("\nUnable to set color on "+(abRTStripPath($obj))+".  Ignored and moving on.");
		}
	}
}


global proc string[] abRTMassOrientConstraint(string $aParent[], string $aChildren[], string $aNames[]){
	// $aParent[0] is constrained to $aChildren[0], $aParent[1] to $aChildren[1], etc -- named to $aNames[n]
	// array of constraint.weight returned
	
	string $aRet[], $aStr[], $constraint, $weightAtt, $aConsName[], $baseName, $prefix;
	int $i;
	
	if (size($aNames) < size($aParent)){
		
		// use the first item in aNames as the name
		if (size($aNames) >= 1)
			$baseName = $aNames[0];
		else
			$baseName = "massOrient";
			
		for ($i=0;$i<size($aParent);$i++){
			$prefix = abRTGetObjSide($aParent[$i]);
			$aConsName[$i] = abRTRigNamer(($baseName+"_"+$i), $prefix, "orCons");
		}
		
	}else{
		$aConsName = $aNames;
	}
	
	if (size($aParent) <= size($aChildren) && size($aParent) <= size($aConsName)){
		
		int $i;
		for ($i=0;$i<size($aParent);$i++){
			
			$aStr = `orientConstraint -name $aConsName[$i] $aParent[$i] $aChildren[$i]`;
			$constraint = $aStr[0];
			$aStr = `orientConstraint -q -wal $constraint`;
			$weightAtt = $aStr[size($aStr)-1];
			$aRet[size($aRet)] = $constraint+"."+$weightAtt;
			
		}
	}
	
	return $aRet;
	
}


global proc abRTAddSplitAttsToRigSettingsCrv(string $ctrl, float $aSplitRatios[], string $aSplitRotMultDiv[], string $attLabel, string $attBaseName, string $prefix, string $limbName, string $firstSplitAttName, string $lastSplitAttName){
	
	// adds attributes for split joint rotation ratios to $ctrl.  $aSplitRatios is an array of ratios for split joints; $splitRotMultDiv array of nodes where final joint rx is determined (with open input2);
	// $attLabel is category name for atts eg "________LEFT_UPARM___"
	// $attBaseName is name to use for the attributes (splitJoint rotations) eg "Uparm"
	// $limbName used to record atts on spineCurve for later rig removal
	// $firstSplitAttName (if not empty) will be used to name the first attribute -- used when setting up an upArm to name the upJnt twist contribution att
	// $lastSplitAttName (if not empty) will be used to name the last attribute -- used when setting up a forearm to name the wrist twist contribution att
	
	string $tSplitRotMultDiv, $attBNm;
	string $longPrefix = ($prefix == "l") ? "left" : "right";
	string $aAxes[] = {"X","Y","Z"};
	string $att, $aAtts[];
	
	// exit if the $ctrl object doesn't exist or size($aSplitRatios) > 3
	if (!`objExists $ctrl` || size($aSplitRatios) == 0) return;
	
	int $i, $mod_i;
	
	// add att label
	if ($attLabel != ""){
		if (!attributeExists($attLabel, $ctrl)){
			addAttr -ln $attLabel -at bool -dv 0 -keyable true $ctrl;
			setAttr -lock true ($ctrl+"."+$attLabel);
			
			// record atts to charVars
			$aAtts[size($aAtts)] = ($ctrl+"."+$attLabel);
		}
	}
	
	// add atts
	for ($i=0;$i<size($aSplitRatios);$i++){
		
		$mod_i = $i%3;
		
		if ($firstSplitAttName != "" && $i == 0){
			$att = $longPrefix+(capitalizeString($firstSplitAttName));
		}else if ($lastSplitAttName != "" && $i == (size($aSplitRatios)-1)){
			$att = $longPrefix+(capitalizeString($lastSplitAttName));
		}else{
			$att = $longPrefix+(capitalizeString($attBaseName))+"_"+($i+1);
		}
		
		if ($mod_i == 0)
			$tSplitRotMultDiv = $aSplitRotMultDiv[int($i/3)];
		
		if (!attributeExists($att, $ctrl))
			addAttr -ln $att -at double -min -1 -max 1 -dv $aSplitRatios[$i] -keyable true $ctrl;
		
		connectAttr ($ctrl+"."+$att) ($tSplitRotMultDiv+".input2"+$aAxes[$mod_i]);
		
		// record atts to charVars
		$aAtts[size($aAtts)] = ($ctrl+"."+$att);
	}
	
	abRTSaveToCharVars($aAtts, $limbName);
}


global proc abRTConnectToMasterScale(string $grp){
	// connects rig and space switching groups (or any transform) to masterScale
	
	string $rootCtrl = abRTGetFromUI("rootCtrl");
	
	if ($rootCtrl == "" || `nodeType $grp` != "transform") return;
	
	// add masterScale if it doesn't exist
	if (!(`attributeExists "masterScale" $rootCtrl`)) addAttr -ln "masterScale" -at double -dv 1 -keyable true -min .001 -max 10 $rootCtrl;
	
	if (!(`isConnected ($rootCtrl+".masterScale") ($grp+".sx")`)) connectAttr ($rootCtrl+".masterScale") ($grp+".sx");
	if (!(`isConnected ($rootCtrl+".masterScale") ($grp+".sy")`)) connectAttr ($rootCtrl+".masterScale") ($grp+".sy");
	if (!(`isConnected ($rootCtrl+".masterScale") ($grp+".sz")`)) connectAttr ($rootCtrl+".masterScale") ($grp+".sz");
	
}


global proc int abRTSetRootJntAtt(string $attName, string $attVal, string $charName){
	// sets value of attName on charName's rootJoint to attVal
	// returns success or failure
	
	string $rootJnt = $charName+"_spine_low_jnt";
	
	if (!`objExists $rootJnt`)
		return false;
	
	if (!attributeExists($attName, $rootJnt))
		addAttr -ln $attName -dt "string" -keyable false -hidden true $rootJnt;
	
	setAttr -type "string" ($rootJnt+"."+$attName) $attVal;
	
	return true;
}


global proc string abRTGetRootJntAtt(string $attName, string $charName){
	// returns value of attName from rootJoint of charName (or nothing if doesn't exist)
	
	string $ret;
	string $rootJnt = $charName+"_spine_low_jnt";
	
	if (!`objExists $rootJnt`)
		return "";
	
	if (attributeExists($attName, $rootJnt))
		$ret = `getAttr ($rootJnt+"."+$attName)`;
	
	return $ret;
}


global proc int abRTRigSpine(string $rootJnt, string $hipJnt){
	// creates a spine rig -- returns 1 on success, -1 on failure
	
	int $ret = -1;
	
	if ($rootJnt == "" || $hipJnt == "")
		return $ret;
	
	string $aStr[], $aRel[], $rel, $str, $aNames[], $spineCurve, $tLoc, $axis, $tPlsMns, $tMltDiv, $tPlsMns, $name, $jnt;
	int $i, $k, $deg, $spans, $numCvs, $int, $int2, $colorIndex ;
	float $aTrans[], $aTrans2[], $float, $floatSum;
	string $aAxes[] = {"X","Y","Z"};
	
	string $charName = abRTGetGlobal("name");
	//string $addSpineShaper = abRTGetGlobal("addSpineShaper");
	int $spineJntNum = int(abRTGetGlobal("spineJntNum"));
	//int $addSquashStretch = int(abRTGetGlobal("squashStretchSpine"));
	string $limbName = "spine";
	
	int $makeMasterSpineCtrl = true;
	
	// set the scale
	abRTSetScale($rootJnt);
	
	// get back joints
	$aRel = `listRelatives -c -fullPath -type joint $rootJnt`;
	if (size($aRel) != 2){
		warning "Root joint needs to be parent to both the hip joint and the mid spine joint";
		return $ret;
	}
	
	// get midJoint
	string $aMidJnts[];
	$aMidJnts[size($aMidJnts)] = ($aRel[0] == $hipJnt) ? $aRel[1] : $aRel[0];
	
	$aRel = `listRelatives -c -fullPath -type joint $aMidJnts[size($aMidJnts)-1]`;
	if (size($aRel) != 1){
		warning "Mid spine joint should only have one child joint.";
		return $ret;
	}
	
	string $hiJnt = $aRel[0];
	
	$aRel = `listRelatives -c -fullPath -type joint $hiJnt`;
	if (size($aRel) != 1){
		warning "High spine joint should only have one child joint.";
		return $ret;
	}
	string $endJnt = $aRel[0];
	
	
	// make rootCon
	abRTMakeRootCon($rootJnt);
	string $rootCtrl = abRTGetFromUI("rootCtrl");
	
	// create spine rig group
	string $rigRootFolder = abRTRigRootFolder();
	string $spineGrp = (abRTRigNamer("spine", "", "rigGrp"));
	if (!`objExists ($rigRootFolder+"|"+$spineGrp)`){
		$spineGrp = `group -em -name $spineGrp`;
		$spineGrp = abRTParent($spineGrp, $rigRootFolder);
	}else{
		warning "This part of the character has already been rigged.  You must remove the current rig before you can continue.";
		return $ret;
	}
	
	abRTConnectToMasterScale($spineGrp);
	
	// create non scaling group inside of spine rig group to place ikCurve, clusters, ikhandle
	string $spineNSGrp = `group -em -p $spineGrp -name (abRTRigNamer("spineNoScale", "", "rigGrp"))`;
	setAttr ($spineNSGrp+".inheritsTransform") 0;
	
	// get skeleton group
	string $skeletonGrp = firstParentOf($rootJnt);
	
	// connect rootCon masterScale att skeletonGrp and rigGroup
	connectAttr ($rootCtrl+".masterScale") ($rootCtrl+".sx");
	connectAttr ($rootCtrl+".masterScale") ($rootCtrl+".sy");
	connectAttr ($rootCtrl+".masterScale") ($rootCtrl+".sz");
	
	if ($skeletonGrp != ""){
		connectAttr ($rootCtrl+".masterScale") ($skeletonGrp+".sx");
		connectAttr ($rootCtrl+".masterScale") ($skeletonGrp+".sy");
		connectAttr ($rootCtrl+".masterScale") ($skeletonGrp+".sz");
	}
	
	abRTHideAttr($rootCtrl, {"sx","sy","sz"});
	
	// save spineGrp to charVars
	abRTSaveRigGrpToCharVars($spineGrp, $limbName);
	abRTSaveToCharVars({$rootCtrl}, $limbName);
	
	// create curve for ikSpline
	// need to place shaper_loc
	
	int $makeSpineShaper = true;
	
	string $aBackRigCtrlJnts[];
	$aBackRigCtrlJnts = {$hipJnt,$rootJnt};
	$aBackRigCtrlJnts = stringArrayCatenate($aBackRigCtrlJnts, $aMidJnts);
	$aBackRigCtrlJnts[size($aBackRigCtrlJnts)] = $hiJnt;
	$aBackRigCtrlJnts[size($aBackRigCtrlJnts)] = $endJnt;
	
	string $aSpineData[] = abRTMakeSpine($aBackRigCtrlJnts, $spineJntNum, $makeSpineShaper, $spineNSGrp, $spineGrp, true);
	
	if (size($aSpineData) == 0){
		// failed -- undo
		evalDeferred("undo");
		return $ret;
	}
	
	// parse return array
	
	// $aRet = {
	// 0 - $spineCurve
	// 1 - $shaperJnt
	// 2 - $aBackRigJnts0 & $aBackRigJnts1 & ...
	// 3 - $aCtrlSpineJnts0 & $aCtrlSpineJnts1 & ...
	// 4 - $aWeightSpineJnts0 & $aWeightSpineJnts1 & ...
	
	string $spineCurve, $shaperJnt, $aCtrlSpineJnts[], $aRefSpineJnts[], $aWeightSpineJnts[];
	clear($aBackRigCtrlJnts);
	
	$spineCurve = $aSpineData[0];
	$shaperJnt = $aSpineData[1];
	
	$aStr = stringToStringArray($aSpineData[2], "&");
	for ($str in $aStr)
		if ($str != "")	$aBackRigCtrlJnts[size($aBackRigCtrlJnts)] = $str;
	
	$aStr = stringToStringArray($aSpineData[3], "&");
	for ($str in $aStr)
		if ($str != "")	$aCtrlSpineJnts[size($aCtrlSpineJnts)] = $str;
	
	$aStr = stringToStringArray($aSpineData[4], "&");
	for ($str in $aStr)
		if ($str != "")	$aWeightSpineJnts[size($aWeightSpineJnts)] = $str;
	
	// done parsing
	
	
	// reconnect skeletonVis to skeleton
	for ($i=0;$i<size($aWeightSpineJnts);$i++){
		
		parentConstraint $aCtrlSpineJnts[$i] $aWeightSpineJnts[$i];
		//if (`attributeExists "skeletonVis" $rootCtrl` && !`isConnected ($rootCtrl+".skeletonVis") ($aWeightSpineJnts[$i]+".v")`)
		//	connectAttr -f ($rootCtrl+".skeletonVis") ($aWeightSpineJnts[$i]+".v");
	}
	
	// done
	
	
	// make curve stretch reader
	string $spineStretchVal = abRTMakeCurveStretchReader($spineCurve, $limbName, "");
	
	
	// make spine controls
	string $midCtrlCrv, $midCtrlCrvFrzGrp;
	string $hipCtrlCrv, $cogCtrlCrv, $lowCtrlCrv, $aMidCtrlCrvs[], $shaperCtrlCrv, $hiCtrlCrv;
	int $tCv;
	int $spineHidJntCv = size($aMidJnts) + 2;
	
	if ($makeSpineShaper)
		$spineHidJntCv += 1;
	
	$hipCtrlCrv = abRTMakeWireController("pyramid", 4, {}, 25);
	abRTMoveWireRelativeToPivot($hipCtrlCrv, 0, -.8, 0, true);
	$cogCtrlCrv = abRTMakeWireController("circle", 1, {}, 60);
	$lowCtrlCrv = abRTMakeWireController("flattenedCircle", 1, {}, 45);
	$hiCtrlCrv = abRTMakeWireController("flattenedCircle", 1, {}, 45);
	
	if ($makeSpineShaper){
		
		$shaperCtrlCrv = abRTMakeWireController("flattenedCircle", 1, {}, 45);
		addAttr -ln "spineShaper" -at bool -dv 1 -keyable true $cogCtrlCrv;
		
		// rename and place in grp
		$aStr = abRTRename($shaperCtrlCrv, (abRTRigNamer("spineShaper", "", "ctrl")));
		$shaperCtrlCrv = $aStr[0];
		$shaperCtrlCrv = abRTParent($shaperCtrlCrv, $spineGrp);
		
		// position
		$tCv = size($aMidJnts) + 2;
		$aTrans = `xform -q -ws -t ($spineCurve+".cv["+$tCv+"]")`;
		xform -ws -t $aTrans[0] $aTrans[1] $aTrans[2] $shaperCtrlCrv;
	}
	
	for ($i=0;$i<size($aMidJnts);$i++){
		
		$aMidCtrlCrvs[$i] = abRTMakeWireController("flattenedCircle", 1, {}, 45);
		
		// rename and place in grp
		$aStr = abRTRename($aMidCtrlCrvs[$i], (abRTRigNamer("spineMid_"+($i+1), "", "ctrl")));
		$aMidCtrlCrvs[$i] = $aStr[0];
		$aMidCtrlCrvs[$i] = abRTParent($aMidCtrlCrvs[$i], $spineGrp);
		
		// position
		$tCv = $i + 2;
		$aTrans = `xform -q -ws -t ($spineCurve+".cv["+$tCv+"]")`;
		xform -ws -t $aTrans[0] $aTrans[1] $aTrans[2] $aMidCtrlCrvs[$i];
		
		// orient curves if UI says to
		if (int(abRTGetGlobal("alignCtrlCrvsToSpine"))){
			$aStr = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "none" $hiJnt $aMidCtrlCrvs[$i]`;
			delete $aStr[0];
			
			// store the att on the skeleton
			abRTSetRootJntAtt("alignCtrlCrvsToSpine", "1", $charName);
		}else{
			abRTSetRootJntAtt("alignCtrlCrvsToSpine", "0", $charName);
		}
		
		// groupFreeze mid and hi spine ctrl curves to zero out transforms
		$aMidCtrlCrvs[$i] = abRTGroupFreezeReturnObj($aMidCtrlCrvs[$i], 1);
		// add a second frzGrp if making masterSpineCtrl
		if ($makeMasterSpineCtrl)
			$aMidCtrlCrvs[$i] = abRTGroupFreezeReturnObj($aMidCtrlCrvs[$i], 1);
		
		// set hidden ui text fields for space parenting
		abRTSetUITxtFld("midSpineCtrl_"+($i+1), $aMidCtrlCrvs[$i]);
	}
	
	// add attributes now to preserve attribute position
	addAttr -ln "stretchValue" -at double -keyable false $cogCtrlCrv;      
	setAttr -cb true ($cogCtrlCrv+".stretchValue");
	
	// rename
	$aStr = abRTRename($hipCtrlCrv, (abRTRigNamer("hip", "", "ctrl")));
	$hipCtrlCrv = $aStr[0];
	$aStr = abRTRename($cogCtrlCrv, (abRTRigNamer("cog", "", "ctrl")));
	$cogCtrlCrv = $aStr[0];
	$aStr = abRTRename($lowCtrlCrv, (abRTRigNamer("spineLow", "", "ctrl")));
	$lowCtrlCrv = $aStr[0];
	$aStr = abRTRename($hiCtrlCrv, (abRTRigNamer("spineHigh", "", "ctrl")));
	$hiCtrlCrv = $aStr[0];
	
	// place in spineGrp
	$hipCtrlCrv = abRTParent($hipCtrlCrv, $spineGrp);
	$cogCtrlCrv = abRTParent($cogCtrlCrv, $spineGrp);
	$lowCtrlCrv = abRTParent($lowCtrlCrv, $spineGrp);
	$hiCtrlCrv = abRTParent($hiCtrlCrv, $spineGrp);
	
	// position curves
	$aTrans = `xform -q -ws -t ($spineCurve+".cv[1]")`;
	xform -ws -t $aTrans[0] $aTrans[1] $aTrans[2] $hipCtrlCrv;
	xform -ws -t $aTrans[0] $aTrans[1] $aTrans[2] $cogCtrlCrv;
	xform -ws -t $aTrans[0] $aTrans[1] $aTrans[2] $lowCtrlCrv;
	
	$aTrans = `xform -q -ws -t ($spineCurve+".cv["+$spineHidJntCv+"]")`;
	xform -ws -t $aTrans[0] $aTrans[1] $aTrans[2] $hiCtrlCrv;
	
	// orient hi spine ctrls (if necessary)
	if (int(abRTGetGlobal("alignCtrlCrvsToSpine"))){
		$aStr = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "none" $endJnt $hiCtrlCrv`;
		delete $aStr[0];
	}
	
	// groupFreeze ctrl curves to zero out transforms
	$hipCtrlCrv = abRTGroupFreezeReturnObj($hipCtrlCrv, 1);
	$cogCtrlCrv = abRTGroupFreezeReturnObj($cogCtrlCrv, 1);
	$lowCtrlCrv = abRTGroupFreezeReturnObj($lowCtrlCrv, 1);
	$hiCtrlCrv = abRTGroupFreezeReturnObj($hiCtrlCrv, 1);
	
	if ($makeMasterSpineCtrl){
		$hipCtrlCrv = abRTGroupFreezeReturnObj($hipCtrlCrv, 1);
		$cogCtrlCrv = abRTGroupFreezeReturnObj($cogCtrlCrv, 1);
		$lowCtrlCrv = abRTGroupFreezeReturnObj($lowCtrlCrv, 1);
		$hiCtrlCrv = abRTGroupFreezeReturnObj($hiCtrlCrv, 1);
	}
	
	// freeze three low curves' transforms
	makeIdentity -apply true -t 1 -r 0 -s 0 $hipCtrlCrv;
	makeIdentity -apply true -t 1 -r 0 -s 0 $cogCtrlCrv;
	makeIdentity -apply true -t 1 -r 0 -s 0 $lowCtrlCrv;
	
	// set hidden ui text fields for space parenting
	abRTSetUITxtFld("hipCtrl", $hipCtrlCrv);
	abRTSetUITxtFld("cogCtrl", $cogCtrlCrv);
	abRTSetUITxtFld("lowSpineCtrl", $lowCtrlCrv);
	abRTSetUITxtFld("hiSpineCtrl", $hiCtrlCrv);
	
	
	// make rigSettings control curve
	string $rigSettingsCtrlCrv = abRTMakeWireController("gear_1", 1, {}, 10);
	
	$aStr = abRTRename($rigSettingsCtrlCrv, ($charName+"_rigSettings_ctrl"));
	$rigSettingsCtrlCrv = $aStr[1];
	
	select -r $rootCtrl $rigSettingsCtrlCrv;
	abRTPointOrient(1);
	
	$float = abRTGetMaxDim($rootCtrl);
	setAttr ($rigSettingsCtrlCrv+".tx") ($float * .4);
	setAttr ($rigSettingsCtrlCrv+".tz") ($float * -.4);
	
	//$rigSettingsCtrlCrv = abRTParent($rigSettingsCtrlCrv, $rootCtrl);
	$rigSettingsCtrlCrv = abRTParent($rigSettingsCtrlCrv, $spineGrp);
	parentConstraint -mo $rootCtrl $rigSettingsCtrlCrv;
	
	// color it
	abRTColorObj($rigSettingsCtrlCrv, "rootCtrlColor", -1);
	
	// update UI with rigSettings ctrl
	abRTSetUITxtFld("rigSettingsCtrl", $rigSettingsCtrlCrv);
	
	// done
	
	
	// make the arrays to constrain the control curves
	
	string $aTempCtrls[], $aTempParents[], $tNode, $aSpaceParCons[], $aSpaceParConsWeightAtt[], $tFrzGrp, $tJnt;
	
	$aTempCtrls = {$hipCtrlCrv, $lowCtrlCrv};
	$aTempCtrls = stringArrayCatenate($aTempCtrls, $aMidCtrlCrvs);
	$aTempCtrls[size($aTempCtrls)] = $hiCtrlCrv;
	
	$aTempParents = {$cogCtrlCrv, $cogCtrlCrv, $lowCtrlCrv};
	for ($i=0;$i<size($aMidCtrlCrvs);$i++)
		$aTempParents[size($aTempParents)] = $aMidCtrlCrvs[$i];
	
	int $counter = 0;
	
	
	for ($i=0;$i<size($aTempCtrls);$i++){
		
		if ($i % 3 == 0){
			$counter ++;
			$tNode = abRTCreateNode("reverse", "spineSpace_"+$counter, "", $limbName);
		}
		
		if (!$makeMasterSpineCtrl)
			$tFrzGrp = firstParentOf($aTempCtrls[$i]);
		else
			$tFrzGrp = firstParentOf(firstParentOf($aTempCtrls[$i]));
		
		// add spaces for root and upJnt
		if ($aTempParents[$i] == $cogCtrlCrv){
			$aSpaceParCons = `parentConstraint -mo $cogCtrlCrv $tFrzGrp`;
			continue;
		}
		
		$aSpaceParCons = `parentConstraint -mo $cogCtrlCrv $aTempParents[$i] $tFrzGrp`;
		//$aSpaceParCons = `parentConstraint -mo $rootCtrl $aTempParents[$i] $tFrzGrp`;
		$aSpaceParConsWeightAtt = `parentConstraint -q -wal $aSpaceParCons[0]`;
		
		addAttr -ln "useCogSpace" -at double -min 0 -max 1 -dv 0 -keyable true $aTempCtrls[$i];
		
		connectAttr -f ($aTempCtrls[$i]+".useCogSpace") ($tNode+".input"+$aAxes[$i%3]);
		connectAttr -f ($tNode+".output"+$aAxes[$i%3]) ($aSpaceParCons[0]+"."+$aSpaceParConsWeightAtt[1]);
		connectAttr -f ($aTempCtrls[$i]+".useCogSpace") ($aSpaceParCons[0]+"."+$aSpaceParConsWeightAtt[0]);
		
	}
	
	// lastly, parent cog to rootCtrl
	if (!$makeMasterSpineCtrl)
		$tFrzGrp = firstParentOf($cogCtrlCrv);
	else
		$tFrzGrp = firstParentOf(firstParentOf($cogCtrlCrv));
	
	parentConstraint -mo $rootCtrl $tFrzGrp;
	
	// make masterSpineCtrl
	string $masterSpineCtrl, $ctrl, $nameStr, $spineSpineSplitAtt, $spineSpineSplitAttName, $spineSpltMCRotLabel, $tTransMltDiv, $aParCons[];
	float $aDefRotValues[], $maxDim;
	
	if ($makeMasterSpineCtrl){
		
		// get rid of hipCtrl (first item) in aTempCtrls
		clear($aTempCtrls);
		$aTempCtrls = stringArrayCatenate({$lowCtrlCrv}, $aMidCtrlCrvs);
		$aTempCtrls = stringArrayCatenate($aTempCtrls, {$hiCtrlCrv});
		// get rid of hipCtrl and lowSpine (first and second items) in aTempCtrls
		//$aTempCtrls = stringArrayCatenate($aMidCtrlCrvs, {$hiCtrlCrv});
		
		// create master ctrl and place it
		$masterSpineCtrl = abRTMakeWireController("circle", 1, {}, 8);
		$aStr = abRTRename($masterSpineCtrl, abRTRigNamer("masterSpine", "", "ctrl"));
		$masterSpineCtrl = $aStr[1];
		
		$aParCons = `parentConstraint $aMidCtrlCrvs[0] $aMidCtrlCrvs[size($aMidCtrlCrvs)-1] $masterSpineCtrl`;
		for ($str in $aParCons) delete $str;
		
		// move it X+
		$maxDim = abRTGetMaxDim($cogCtrlCrv);
		abRTMoveWireRelativeToPivot($masterSpineCtrl, ($maxDim*.25), 0, 0, true);
		
		$masterSpineCtrl = abRTParent($masterSpineCtrl, $spineGrp);
		$masterSpineCtrl = abRTGroupFreezeReturnObj($masterSpineCtrl, true);
		
		$tFrzGrp = firstParentOf($masterSpineCtrl);
		parentConstraint -mo $cogCtrlCrv $tFrzGrp;
		//parentConstraint -mo $rootJnt $tFrzGrp;
		
		abRTColorObj($masterSpineCtrl, "ctrMasterCtrlColor", -1);
		
		abRTHideAttr($masterSpineCtrl, {"sx","sy","sz","v"});
		
		for ($i=0;$i<size($aTempCtrls);$i++){
			
			$ctrl = $aTempCtrls[$i];
			
			if ($i == 0){
				$nameStr = "spineLow_Ctrl";
			}else if ($i < size($aTempCtrls)-1){
				$nameStr = "spineMid_"+$i+"_Ctrl";
			}else{
				$nameStr = "spineHigh_Ctrl";
			}
				
			// connect masterSpineCtrl
			if ($masterSpineCtrl != ""){
				
				$tFrzGrp = firstParentOf($ctrl);
				$tMltDiv = abRTCreateNode("multiplyDivide", "masterSpineRot_"+$i, "", $limbName);
				connectAttr ($masterSpineCtrl+".r") ($tMltDiv+".input1");
				
				if ($i == 0){
					
					// get def values
					$float = 1.0/(float(size($aTempCtrls)));
					for ($k=0;$k<size($aTempCtrls);$k++)
						$aDefRotValues[$k] = $float;
				}
				
				// add atts
				if ($rigSettingsCtrlCrv != ""){
					
					if ($i == 0){
						// add label
						$spineSpltMCRotLabel = "Spine_Master_Control_______";
						addAttr -ln $spineSpltMCRotLabel -at bool -dv 0 -keyable true $rigSettingsCtrlCrv;
						setAttr  -lock true ($rigSettingsCtrlCrv+"."+$spineSpltMCRotLabel);
						abRTSaveToCharVars({($rigSettingsCtrlCrv+"."+$spineSpltMCRotLabel)}, $limbName);
					}
					
					$spineSpineSplitAttName = $nameStr+"_Rotation";
					$spineSpineSplitAtt = $rigSettingsCtrlCrv+"."+$spineSpineSplitAttName;
					
					addAttr -ln $spineSpineSplitAttName -at double -min 0 -max 1 -dv $aDefRotValues[$i] -keyable true $rigSettingsCtrlCrv;
					abRTSaveToCharVars({$spineSpineSplitAtt}, $limbName);
					
					// connect mltDiv
					connectAttr $spineSpineSplitAtt ($tMltDiv+".input2X");
					connectAttr $spineSpineSplitAtt ($tMltDiv+".input2Y");
					connectAttr $spineSpineSplitAtt ($tMltDiv+".input2Z");
					
					connectAttr ($tMltDiv+".output") ($tFrzGrp+".r");
					
					$tTransMltDiv = abRTCreateNode("multiplyDivide", "masterSpineTrans_"+$i, "", $limbName);
					
					connectAttr ($masterSpineCtrl+".t") ($tTransMltDiv+".input1");
					connectAttr $spineSpineSplitAtt ($tTransMltDiv+".input2X");
					connectAttr $spineSpineSplitAtt ($tTransMltDiv+".input2Y");
					connectAttr $spineSpineSplitAtt ($tTransMltDiv+".input2Z");
					
					connectAttr ($tTransMltDiv+".output") ($tFrzGrp+".t");
					
				}else{
					
					// connect mltDiv
					setAttr ($tMltDiv+".input2") $aDefRotValues[$i] $aDefRotValues[$i] $aDefRotValues[$i];
					connectAttr ($tMltDiv+".output") ($tFrzGrp+".r");
				}
			}
		}
		
		abRTSetUITxtFld("masterSpineCtrl", $masterSpineCtrl);
	}
	
	
	string $aShaperGrpFrz[];
	
	if ($makeSpineShaper){
		
		// set up shaperCtrl
		$shaperCtrlCrv = abRTGroupFreezeReturnObj($shaperCtrlCrv, 1);
		$shaperCtrlCrv = abRTGroupFreezeReturnObj($shaperCtrlCrv, 1);
		$str = firstParentOf($shaperCtrlCrv);
		$str = firstParentOf($str);
		$aShaperGrpFrz = {$str};
		$aShaperGrpFrz[1] = firstParentOf($shaperCtrlCrv);
		parentConstraint -mo $aMidCtrlCrvs[size($aMidCtrlCrvs)-1] $aShaperGrpFrz[0];
		$aStr = `parentConstraint -mo $aMidCtrlCrvs[size($aMidCtrlCrvs)-1] $hiCtrlCrv $aShaperGrpFrz[1]`;
		
		// set the interp type on the shaper curve parentConstraint to no flip
		setAttr ($aStr[0]+".interpType") 0;
		
		// constrain and hide
		parentConstraint -mo $shaperCtrlCrv $shaperJnt;
		setAttr ($shaperJnt+".v") 0;
	}
	
	// constrain loRes spine joints to ctrl curves
	parentConstraint -mo $hipCtrlCrv $hipJnt;
	parentConstraint -mo $lowCtrlCrv $rootJnt;
	parentConstraint -mo $hiCtrlCrv $hiJnt;
	
	for ($i=0;$i<size($aMidCtrlCrvs);$i++){
		
		parentConstraint -mo $aMidCtrlCrvs[$i] $aMidJnts[$i];
		setAttr ($aMidCtrlCrvs[$i]+".rotateOrder") 3;
	}
	
	// set rotate order on ctrls
	setAttr ($cogCtrlCrv+".rotateOrder") 2; //zxy
	setAttr ($hipCtrlCrv+".rotateOrder") 2;
	setAttr ($lowCtrlCrv+".rotateOrder") 3; //xzy
	setAttr ($hiCtrlCrv+".rotateOrder") 3;
	
	
	// rubberhose stuff
	
	string $refCrv, $ribbon, $ribbonShape, $aCmd1[], $aCmd2[], $cmd, $cluster, $spineCurveCluster, $cv, $cv1, $cv2;
	float $dist, $gScale, $ribbonWidth;
	
	$gScale = float(abRTGetGlobal("globalScale"));
	$ribbonWidth = $gScale*.5;
	
	
	// rebuild the curve to make it a nice cubic curve
	$aStr = `duplicate $spineCurve`;
	$refCrv = $aStr[0];
	
	rebuildCurve -ch 0 -rpo 1 -rt 2 -end 1 -kr 0 -kcp 1 -kep 1 -kt 0 -d 3 -tol 0.01 $spineCurve $refCrv;
	delete $refCrv;
	
	
	// extrude it 
	$aStr = `extrude -ch false -rn false -po 0 -et 0 -upn 1 -length $ribbonWidth -rotation 0 -scale 1 -dl 3 -n (abRTRigNamer("spine_ribbon", "", "surf")) $spineCurve`;
	$ribbon = $aStr[0];
	$aStr = `listRelatives -c -type shape $ribbon`;
	$ribbonShape = $aStr[0];
	
	// move along normal
	select -r ($ribbon+".cv[*][*]");
	$aStr = `filterExpand -sm 28`;
	
	$dist = -($ribbonWidth/2.0);
	
	for ($i=0;$i<size($aStr);$i++){
		$aCmd1[size($aCmd1)] = "-v "+$dist;
		$aCmd2[size($aCmd2)] = $aStr[$i];
	}
	
	$cmd = "moveVertexAlongDirection " + stringArrayToString($aCmd1, " ") + " " + stringArrayToString($aCmd2, " ") + ";";
	eval($cmd);
	
	$ribbon = abRTParent($ribbon, $spineNSGrp);
	
	
	// bind and weight the ribbon to the control jnts
	// use temp array to add surface to end of joints for binding
	$aStr = stringArrayCatenate($aBackRigCtrlJnts, {$ribbon});
	
	$aStr = `skinCluster -toSelectedBones -maximumInfluences 2 -dropoffRate 4 $aStr`;
	$cluster = $aStr[0];
	
	// and temp array to bind spine curve (used to determine stretch)
	$aStr = stringArrayCatenate($aBackRigCtrlJnts, {$spineCurve});
	$aStr = `skinCluster -toSelectedBones -maximumInfluences 2 -dropoffRate 4 $aStr`;
	$spineCurveCluster = $aStr[0];
	
	int $aboveVer2010 = (`getApplicationVersionAsFloat` > 2010);
	
	// now adjust weights
	for ($i=0;$i<size($aBackRigCtrlJnts);$i++){
		
		// ribbon
		$cv1 = $ribbon+".cv["+$i+"][0]";
		$cv2 = $ribbon+".cv["+$i+"][1]";
		
		// spine curve
		$cv = $spineCurve+".cv["+$i+"]";
		
		if ($aboveVer2010){
			skinPercent -transformValue $aBackRigCtrlJnts[$i] 1.0 -zeroRemainingInfluences 1 $cluster $cv1 $cv2;
			skinPercent -transformValue $aBackRigCtrlJnts[$i] 1.0 -zeroRemainingInfluences 1 $spineCurveCluster $cv;
		}else{
			skinPercent -transformValue $aBackRigCtrlJnts[$i] 1.0 $cluster $cv1 $cv2;
			skinPercent -transformValue $aBackRigCtrlJnts[$i] 1.0 $spineCurveCluster $cv;
		}
			
	}
	
	// attach the split joints to the ribbon
	// place the follicles
	
	string $tFollShape, $tFoll, $follicleGrp;
	string $rxReverseMltDiv, $upFrzGrp, $dnFrzGrp, $tLoc;
	float $v, $u;
	int $conCounter, $upJntCounter, $dnJntCounter, $isUpJnt, $isUpMidDnJnt;
	
	$conCounter = $upJntCounter = $dnJntCounter = $isUpJnt = $isUpMidDnJnt = 0;
	
	$follicleGrp = `group -em -p $spineNSGrp -name (abRTRigNamer("spineRhFollicles", "", "grp"))`;
	$v = .5;
	
	for ($i=0;$i<size($aCtrlSpineJnts);$i++){
		
		// create follicle
		$tFollShape = `createNode -n (abRTRigNamer("spineRhFollicle"+$i, "", "fol")) follicle`;
		$aStr = `listRelatives -p -type transform $tFollShape`;
		$tFoll = $aStr[0];
		
		$tFoll = abRTParent($tFoll, $follicleGrp);
		
		// connect it
		connectAttr -f ($tFollShape+".outTranslate") ($tFoll+".translate");
		connectAttr -f ($tFollShape+".outRotate") ($tFoll+".rotate");
		
		connectAttr ($ribbonShape+".worldMatrix[0]") ($tFollShape+".inputWorldMatrix");
		connectAttr ($ribbonShape+".local") ($tFollShape+".inputSurface");
		
		// position it
		$u = abRTGetClosestParamOnSurface($ribbon, `joint -q -a -p $aCtrlSpineJnts[$i]`, 1);
		
		setAttr ($tFollShape+".parameterV") $v;
		setAttr ($tFollShape+".parameterU") $u;
		
		// hide it
		setAttr ($tFoll+".v") 0;
		
		// put split joint in frzGrp and parent frzGrp to follicle (so we can negate RH twist add our own x twist later)
		$aCtrlSpineJnts[$i] = abRTGroupFreezeReturnObj($aCtrlSpineJnts[$i], 1);
		
		// constrain the frzGrp to the follicle
		parentConstraint -mo $tFoll (firstParentOf($aCtrlSpineJnts[$i]));
	}
	
	
	// hide stuff no one wants to see
	setAttr ($ribbon+".v") 0;
	setAttr ($spineCurve+".v") 0;
	
	for ($jnt in $aCtrlSpineJnts)
		setAttr ($jnt+".v") 0;
	
	// connect rigSettingsAdjuster
	addAttr -ln "rigSettingsCtrlVis" -at bool -dv 1 -keyable true $rootCtrl;
	connectAttr ($rootCtrl+".rigSettingsCtrlVis") ($rigSettingsCtrlCrv+".v");
	
	// connect masterSpineCtrlVis
	if ($makeMasterSpineCtrl){
		if (!attributeExists("masterSpineCtrlVis", $rootCtrl))
			addAttr -ln "masterSpineCtrlVis" -at bool -dv 1 -keyable true $rootCtrl;
		connectAttr -f ($rootCtrl+".masterSpineCtrlVis") ($masterSpineCtrl+".v");
	}
	
	// connect stretch value
	connectAttr $spineStretchVal ($cogCtrlCrv+".stretchValue");
	
	// connect attributes
	if ($makeSpineShaper) connectAttr ($cogCtrlCrv+".spineShaper") ($shaperCtrlCrv+".v");
	
	// hide undesired attributes
	abRTHideAttr($cogCtrlCrv, {"sx","sy","sz","v"});
	abRTHideAttr($hipCtrlCrv, {"sx","sy","sz","v"});
	abRTHideAttr($lowCtrlCrv, {"sx","sy","sz","v"});
	//abRTHideAttr($lowCtrlCrv, {"tx","ty","tz","sx","sy","sz","v"});
	if ($makeSpineShaper)
		abRTHideAttr($shaperCtrlCrv, {"rx","ry","rz","sx","sy","sz","v"});
	abRTHideAttr($hiCtrlCrv, {"sx","sy","sz","v"});
	abRTHideAttr($rigSettingsCtrlCrv, {"tx","ty","tz","rx","ry","rz","sx","sy","sz","v"});
	
	// color the ctrls
	abRTColorObj($cogCtrlCrv, "cogCtrlColor", -1);
	abRTColorObj($hipCtrlCrv, "ctrCtrlColor", -1);
	abRTColorObj($lowCtrlCrv, "ctrCtrlColor", -1);
	if ($makeSpineShaper) abRTColorObj($shaperCtrlCrv, "ctrCtrlColor", -1);
	abRTColorObj($hiCtrlCrv, "ctrCtrlColor", -1);
	
	for ($i=0;$i<size($aMidCtrlCrvs);$i++){
		abRTHideAttr($aMidCtrlCrvs[$i], {"sx","sy","sz","v"});
		abRTColorObj($aMidCtrlCrvs[$i], "ctrCtrlColor", -1);
	}
	
	$ret = 1;
	return $ret;
}


global proc string abRTMakeCurveStretchReader(string $curve, string $limbName, string $prefix){
	// attaches a curve info node to a curve and returns an objAtt (obj.att) that will give the stretch amount of the curve with 1 being no stretch
	
	string $curveInfoNode = abRTCreateNode("curveInfo", $limbName, $prefix, $limbName);
	
	connectAttr ($curve +".worldSpace")  ($curveInfoNode+".inputCurve");
	
	int $deg = `getAttr ($curve+".degree")`;
	int $spans = `getAttr ($curve+".spans")`;
	int $numCvs = $deg+$spans;
	
	string $rootCtrl = abRTGetFromUI("rootCtrl");
	string $limbStretchVal;
	
	// make spine stretch value
	if ($rootCtrl != "" && objExists($rootCtrl)){
		
		// adjust for scale
		string $limbDefArcLenMltDiv = abRTCreateNode("multiplyDivide", "scaleAdjustedDefaultArcLen", $prefix, $limbName);
		setAttr ($limbDefArcLenMltDiv+".input1X") (`getAttr ($curveInfoNode+".arcLength")`);
		connectAttr ($rootCtrl+".masterScale") ($limbDefArcLenMltDiv+".input2X");
		string $scaleAdjustedDefArcLen = $limbDefArcLenMltDiv+".outputX";
		
		string $limbStretchValMltDiv = abRTCreateNode("multiplyDivide", $limbName+"Stretch", $prefix, $limbName);
		setAttr ($limbStretchValMltDiv+".operation") 2;
		connectAttr ($curveInfoNode+".arcLength") ($limbStretchValMltDiv+".input1X");
		connectAttr $scaleAdjustedDefArcLen ($limbStretchValMltDiv+".input2X");
		$limbStretchVal = $limbStretchValMltDiv+".outputX";
		
	}else{
		// no rootCon, so no compensating for scale
		string $limbStretchValMltDiv = abRTCreateNode("multiplyDivide", $limbName+"Stretch", $prefix, $limbName);
		setAttr ($limbStretchValMltDiv+".operation") 2;
		connectAttr ($curveInfoNode+".arcLength") ($limbStretchValMltDiv+".input1X");
		setAttr ($limbStretchValMltDiv+".input2X") (`getAttr ($curveInfoNode+".arcLength")`);;
		$limbStretchVal = $limbStretchValMltDiv+".outputX";
	}
	
	return $limbStretchVal;
}


global proc string[] abRTMakeSpine(string $aSpineRigCtrlJnts[], int $spineJntNum, int $makeSpineShaper, string $spineNSGrp, string $spineGrp, int $createCtrlJnts){
	// creates spine joints and weightSpine joints
	// $aSpineRigCtrlJnts = joints on base skeleton to which the spline curve clusters will be parented (no shaper, will be added in this fn)
	// $aSpineRigCtrlJnts = {$hipJnt, $rootJnt, $midJnt1, [$midJnt2, $midJnt3, ...], $hiJnt, $endJnt}
	// $spineJntNum is number of spine jnts to create
	// $spineNSGrp is the non scaling spine grp
	// $makeSpineShaper will create a spineShaper if true
	// if $createCtrlJnts == false, ctrl joints will be deleted and only weight jnts will be created (used for skeleton building)
	// $spineNSGrp and $spineGrp can be empty if $createCtrlJnts is false
	// see fn end for return array info
	
	string $curveStr, $shaperLoc, $aBackRigCtrlJnts[], $str, $aStr[], $jnt, $aRet[], $shaperJnt;
	float $aTrans[], $aTrans2[];
	int $i, $k;
	
	string $charName = abRTGetGlobal("name");
	string $alpha = "abcdefghijklmnopqrstuvwxyz";	
		
	string $endJnt = $aSpineRigCtrlJnts[size($aSpineRigCtrlJnts)-1];	
	string $hiJnt = $aSpineRigCtrlJnts[size($aSpineRigCtrlJnts)-2];
	string $lastMidJnt = $aSpineRigCtrlJnts[size($aSpineRigCtrlJnts)-3];
	string $rootJnt = $aSpineRigCtrlJnts[1];
	
	string $skeletonGrp = firstParentOf($rootJnt);
	
	
	if (!$createCtrlJnts){
		// make temp spineGrps
		$spineGrp = `group -em -name "tSpineGrp"`;
		$spineNSGrp = `group -em -name "tSpineNSGrp"`;
	}
	
	if ($makeSpineShaper){
		
		$shaperLoc = abRTMakeLocator("shaper_loc");
		parentConstraint $lastMidJnt $hiJnt $shaperLoc;
		
		// need to add $shaperLoc to aBackRigCtrlJnts
		for ($i=0;$i<size($aSpineRigCtrlJnts)-2;$i++)
			$aBackRigCtrlJnts[$i] = $aSpineRigCtrlJnts[$i];
		
		$aBackRigCtrlJnts[size($aBackRigCtrlJnts)] = $shaperLoc;
		$aBackRigCtrlJnts[size($aBackRigCtrlJnts)] = $hiJnt;
		$aBackRigCtrlJnts[size($aBackRigCtrlJnts)] = $endJnt;	
		
		abRTSetRootJntAtt("addSpineShaper", "1", $charName);
		
	}else{
		
		// no spineShaper; use aSpineRigCtrlJnts
		$aBackRigCtrlJnts = $aSpineRigCtrlJnts;
		
		abRTSetRootJntAtt("addSpineShaper", "0", $charName);
	}
	
	string $tLoc = abRTMakeLocator("abRTSkeletonizeTemp_loc");
	
	float $aBRJntTrans[];
	string $curveStr = "curve -d 3";
	
	for ($i=0;$i<size($aBackRigCtrlJnts);$i++){
		
		abRTSnapToPosition($aBackRigCtrlJnts[$i], $tLoc);
		
		$aTrans = `xform -q -ws -t $tLoc`;
		$curveStr += " -p "+$aTrans[0]+" "+$aTrans[1]+" "+$aTrans[2];
		
		// add trans to aBRJntTrans if we're making a spineShaper
		if ($makeSpineShaper){
			$aBRJntTrans[size($aBRJntTrans)] = $aTrans[0];
			$aBRJntTrans[size($aBRJntTrans)] = $aTrans[1];
			$aBRJntTrans[size($aBRJntTrans)] = $aTrans[2];
		}
	}
	
	$curveStr += " -n "+(abRTRigNamer("ikSpline", "", "crv"));
	string $spineCurve = eval($curveStr);
	
	// parent curve
	$spineCurve = abRTParent($spineCurve, $spineNSGrp);
	
	delete $tLoc;
	if (`objExists $shaperLoc`)
		delete $shaperLoc;
	
	select -clear;
	
	// now make shaperJnt
	if ($makeSpineShaper){
		
		string $aSpineShaperJntChain[];
		
		select -clear;
		
		for ($i=0;$i<size($aBRJntTrans);$i+=3){
			
			$aTrans[0] = $aBRJntTrans[$i];
			$aTrans[1] = $aBRJntTrans[$i+1];
			$aTrans[2] = $aBRJntTrans[$i+2];
			
			$aSpineShaperJntChain[size($aSpineShaperJntChain)] = `joint -p $aTrans[0] $aTrans[1] $aTrans[2]`;
		}
		
		$aStr = `duplicate -po -n (abRTRigNamer("spineShaper", "", "jnt")) $aSpineShaperJntChain[size($aSpineShaperJntChain)-3]`;
		$shaperJnt = $aStr[0];
		$shaperJnt = abRTParent($shaperJnt, $spineGrp);
		
		// ok, got the shaper jnt, now delete the joints
		delete $aSpineShaperJntChain[0];
		
		select -clear;
		
		// replace shaperLoc with shaperJnt in $aBackRigCtrlJnts
		for ($i=0;$i<size($aBackRigCtrlJnts);$i++){
			if ($aBackRigCtrlJnts[$i] == $shaperLoc)
				$aBackRigCtrlJnts[$i] = $shaperJnt;
		}
	}
	
	
	// fill aSpineJntNames
	int $spineJntNum = int(abRTGetGlobal("spineJntNum"));
	string $aSpineJntNames[];
	
	for ($i=0;$i<$spineJntNum;$i++){
		$str = "spineRig_"+(substring($alpha, ($i+1), ($i+1)));
		$aSpineJntNames[size($aSpineJntNames)] = abRTRigNamer($str, "", "jnt");
	}
	
	
	// create spine joints
	$aStr = `rebuildCurve -ch 1 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.01 $spineCurve`;
	string $rebuiltSpineCurve = $aStr[0];
	string $aRigSpineJnts[] = abRTMakeSpineJntsFromCurve($rebuiltSpineCurve, $aSpineJntNames, $spineGrp, false);
	delete $rebuiltSpineCurve;
	
	// done with back
	abRTOrientJoints($aRigSpineJnts, "xyz", "zdown");
	
	// make control and weight joints
	// dup from second rig spine joint to next to last rig spine joint to make binding joints (which have to be unparented from each other to do the twist)
	string $aCroppedRigSpineJnts[], $aWtJntNames[], $aCtrlJntNames[];
	string $tmpJntSuf = "abTmpJnt";
	
	for ($i=1;($i<size($aRigSpineJnts)-1);$i++){
		$str = substring($alpha, ($i+1), ($i+1));
		$aWtJntNames[size($aWtJntNames)] = abRTRigNamer(("weightSpine_"+$str), "", $tmpJntSuf);
		$aCtrlJntNames[size($aCtrlJntNames)] = abRTRigNamer(("ctrlSpine_"+$str), "", $tmpJntSuf);
		$aCroppedRigSpineJnts[size($aCroppedRigSpineJnts)] = $aRigSpineJnts[$i];
	}
	
	// make rigCtrlJnts
	string $aCtrlSpineJnts[] = abRTDuplicateJointHierarchy($aCroppedRigSpineJnts, $aCtrlJntNames, $spineGrp);
	string $ctrlSpineGrp = `group -em -p $spineGrp -name (abRTRigNamer("ctrlSpine", "", "rigGrp"))`;
	
	// create weight spine group rootDir first, then move it to skelWSGrp if needed
	string $weightSpineGrp = `group -em -name (abRTRigNamer("weightSpine", "", "rigGrp"))`;
	string $aWeightSpineJnts[] = abRTDuplicateJointHierarchy($aCroppedRigSpineJnts, $aWtJntNames, $weightSpineGrp);
	
	// unparent joints from heirarchy and group freeze them
	for ($i=(size($aWeightSpineJnts)-1);$i>=0;$i--){
		$aWeightSpineJnts[$i] = abRTParent($aWeightSpineJnts[$i], $weightSpineGrp);
		
		// replace temp suffix (if I didn't do it this way I'd get names ending in _jnt1 due to the way duplicateJointHierarchy works when aNames matches the existing hierarchy's names)
		$aStr = abRTRename($aWeightSpineJnts[$i], substitute($tmpJntSuf, abRTStripPath($aWeightSpineJnts[$i]), "jnt"));
		$aWeightSpineJnts[$i] = $aStr[1];
		
		// do the same for the ctrl joints
		$aCtrlSpineJnts[$i] = abRTParent($aCtrlSpineJnts[$i], $ctrlSpineGrp);
		$aStr = abRTRename($aCtrlSpineJnts[$i], substitute($tmpJntSuf, abRTStripPath($aCtrlSpineJnts[$i]), "jnt"));
		$aCtrlSpineJnts[$i] = $aStr[1];
	}
	
	// The skeleton group should already have a weight spine group if it's been rigged before.  If it does, the freezeGrp positions will be matched against the positions in the $weightSpineGrp.  If they don't match, these will be substituted.
	// If there is no existing weight spine group (in the skeleton group) then $weightSpineGrp will be moved into it
	
	string $skelWeightSpineGroupName = "weightSpine_grp";
	string $skelWSGrp = $skeletonGrp+"|"+$skelWeightSpineGroupName;
	
	if (objExists($skelWSGrp)){
		// group exists.  if the number and positions of the members match up with the joints in $weightSpineGrp, then leave them, otherwise delete the group and it will be recreated
		
		int $delOldWghtGrp = false;
		float $matchTol = .005;
		
		$aStr = sort(`listRelatives -c -fullPath -type joint $skelWSGrp`); // sort it -- otherwise order of joints in skelWSGrp would matter
		
		if (size($aStr) == size($aWeightSpineJnts)){
			
			// check to make sure positions are the same
			
			string $aExistingWeightSpineJnts[];
			string $aPosMatchTracker[] = $aWeightSpineJnts;
			int $posMatch;
			
			for ($i=0;$i<size($aStr);$i++){
				
				$aExistingWeightSpineJnts[$i] = $aStr[$i];
				
				$aTrans = `joint -q -p -a $aStr[$i]`;
				$posMatch = false;
				
				for ($k=0;$k<size($aWeightSpineJnts);$k++){
					
					if ($aPosMatchTracker[$k] == "m") continue; // make sure we don't match the same joint more than once
					
					$aTrans2 = `joint -q -p -a $aWeightSpineJnts[$k]`;
					
					if (abs($aTrans[0]-$aTrans2[0]) < $matchTol && abs($aTrans[1]-$aTrans2[1]) < $matchTol && abs($aTrans[2]-$aTrans2[2]) < $matchTol){
						$aPosMatchTracker[$k] = "m";
						$posMatch = true;
						break;
					}
				}
				if (!$posMatch){
					// there was no match for current $aStr joint in $aWeightSpineJnts -- delete it all
					$delOldWghtGrp = true;
					break;
				}
				
			}
			if ($posMatch){
				// we're using the existing weightjnts and frzGrp so we need to update the arrays
				$aWeightSpineJnts = $aExistingWeightSpineJnts;
			}
		}else{
			$delOldWghtGrp = true;
		}
		
		if ($delOldWghtGrp){
			$str = `confirmDialog -title "Confirm" -message "This character's existing skeleton group\nweight joints don't match the newly created\nweight joints and will have to be deleted." -button "Ok" -button "Cancel" -defaultButton "Ok" -cancelButton "Cancel" -dismissString "Cancel"`;
			
			if ($str == "Cancel")
				return $aRet;
			
			delete $skelWSGrp;
		}
	}
	
	if (!objExists($skelWSGrp)){
		// create the weight joints in $skelWSGrp by moving contents of weightSpineGrp to skelGrp
		
		group -em -name $skelWeightSpineGroupName -parent $skeletonGrp;
		for ($i=0;$i<size($aWeightSpineJnts);$i++){
			// move freezGrp to skelWSGrp
			$aWeightSpineJnts[$i] = abRTParent($aWeightSpineJnts[$i], $skelWSGrp);
		}
	}
	
	delete $weightSpineGrp;
	delete $aRigSpineJnts[0];
	
	
	if (!$createCtrlJnts){
		
		// delete everything but the weightJnts
		delete $spineGrp;
		delete $spineNSGrp;
		
		clear($aRigSpineJnts);
		$spineCurve = $shaperLoc = "";
	}
	
	// shrink rigJnts (all but first and last)
	for ($i=1;$i<size($aSpineRigCtrlJnts)-1;$i++)
		setAttr ($aSpineRigCtrlJnts[$i]+".radius") .01;
	
	// update rootJnt with att for number of spineJnts
	abRTSetRootJntAtt("spineJntNum", string($spineJntNum), $charName);
	
	// $aRet = {
	// 0 - $spineCurve
	// 1 - $shaperJnt
	// 2 - $aBackRigCtrlJnts0 & $aBackRigCtrlJnts1 & ...
	// 3 - $aCtrlSpineJnts0 & $aCtrlSpineJnts1 & ...
	// 4 - $aWeightSpineJnts0 & $aWeightSpineJnts1 & ...
	
	
	$aRet[0] = $spineCurve;
	$aRet[1] = $shaperJnt;
	$aRet[2] = stringArrayToString($aBackRigCtrlJnts, "&");
	$aRet[3] = stringArrayToString($aCtrlSpineJnts, "&");
	$aRet[4] = stringArrayToString($aWeightSpineJnts, "&");
	
	return $aRet;
	
}


global proc int abRTRigHead(string $neck, string $head){
	// rigs head and neck -- returns 1 on success, -1 on failure
	
	int $ret = -1;
	
	if ($neck == "" || $head == "")
		return $ret;
	
	string $aStr[], $aRel[], $aTempJnts[], $aNames[], $jnt, $str;
	float $float, $aTrans[];
	int $i, $k, $aInt[];
	
	string $charName = abRTGetGlobal("name");
	string $rootCtrl = abRTGetFromUI("rootCtrl");
	string $rigSettingsCtrl = abRTGetFromUI("rigSettingsCtrl");
	int $includeHeadNeckTransAtts = int(abRTGetGlobal("includeHeadNeckTransAtts"));
	
	abRTSetScale($neck);
	
	// get and sort neck joints
	string $aNeckJnts[], $aNeckCtrls[];
	
	$jnt = abRTGetFromUI("neck_2");
	
	if ($jnt != "" && `objExists $jnt`){
		
		string $confirm = `confirmDialog -messageAlign center -title "Shameless Shill" -message "The skeleton has more neck joints than this version of abAutoRig is able to rig.\n\nUpgrade to abAutoRig Premium to rig characters with up to three neck joints." -button "OK"`;
		return $ret;
	}
	
	$aNeckJnts[0] = $neck;
	
	// create head rig group
	string $headGrp = (abRTRigNamer("head", "", "rigGrp"));
	
	if (!`objExists ((abRTRigRootFolder())+"|"+$headGrp)`){
		$headGrp = `group -em -name $headGrp`;
		$headGrp = abRTParent($headGrp, abRTRigRootFolder());
	}else{
		warning "This part of the character has already been rigged.  You must remove the current rig before you can continue.";
		return $ret;
	}
	
	abRTConnectToMasterScale($headGrp);
	
	string $limbName = "head";
	
	// save headGrp to charVars
	abRTSaveRigGrpToCharVars($headGrp, $limbName);
	
	$aRel = `listRelatives -p -fullPath -type joint $aNeckJnts[0]`;
	
	if (size($aRel) == 0){
		warning "Neck joint needs to be child of another joint";
		return $ret;
	}
	
	// get last spine jnt
	string $lastSpineJnt = firstParentOf($aNeckJnts[0]);
	
	$aTempJnts = {$neck, $head};
	$aNames = {"neck","head"};
	
	// add align att to first and last joints
	$aInt[size($aInt)] = 0;
	$aInt[size($aInt)] = size($aNames)-1;
	if (size($aNames) > 2)
		$aInt[size($aInt)] = size($aNames)-2;
	
	string $aNeckCtrls[], $headCtrl, $nameStr, $neckCtrl, $ctrl, $aTempCtrls[], $masterNeckCtrl, $tFrzGrp, $aParCons[], $neckSpineSplitAttName, $neckSpineSplitAtt, $tMltDiv, $neckCtrlsVisAttName, $tNode, $aParConsWeightAtt[];
	float $aDefRotValues[];
	
	string $upJnt, $alignTrueGrp, $alignFalseGrp, $autoAlignGrp, $alignNeckGrp, $aSpaceParCons[], $aSpaceParConsWeightAtt[];
	int $shownAlignMsg = false;
	
	// add fkControls
	for ($i=0;$i<size($aTempJnts);$i++){
		
		$upJnt = ($i == 0) ? $lastSpineJnt : $aTempJnts[$i-1];
		$ctrl = ($i < size($aNeckJnts)) ? abRTMakeWireController("circle", 1, {}, 20) : abRTMakeWireController("circle", 1, {}, 30);
		
		$aStr = abRTRename($ctrl, abRTRigNamer($aNames[$i], "", "ctrl"));
		$ctrl = $aStr[1];
		
		abRTSnapToPosition($aTempJnts[$i], $ctrl);
		
		if (abRTGetPosInIntArray($i, $aInt) != -1 && $rootCtrl != ""){
			
			// make group to hold neck control and align true/false nodes
			$alignNeckGrp = `group -em -name (abRTRigNamer(($aNames[$i]+"_fk_ctrl"), "", "Grp")) -p $headGrp`;
			abRTSnapToPosition($aTempJnts[$i], $alignNeckGrp);
			
			// parent neckCtrl to alignNeckGrp
			$ctrl = abRTParent($ctrl, $alignNeckGrp);
			$ctrl = abRTGroupFreezeReturnObj($ctrl, true);
			$tFrzGrp = firstParentOf($ctrl);
			
			// add align att to this jnt
			addAttr -ln "align" -at double -min 0 -max 1 -dv 0 -keyable true $ctrl;
			
			$tNode = abRTCreateNode("reverse", $aNames[$i]+"_align", "", $limbName);
			
			$alignFalseGrp = `group -em -name (abRTRigNamer($aNames[$i]+"AlignFalse", "", "Grp")) -p $alignNeckGrp`;
			
			abRTSnapToPosition($aTempJnts[$i], $alignFalseGrp);
			
			// alignTrue will be placed in autoAlign group; they're both positioned at the neck joint and aligned with the world axes
			$alignTrueGrp = `group -em -name (abRTRigNamer($aNames[$i]+"AlignTrue", "", "Grp")) -p $alignNeckGrp`;
			$autoAlignGrp = `group -em -name (abRTRigNamer(($aNames[$i]+"AutoAlign"), "", "Grp")) -p $alignNeckGrp`;
			
			// constrain guideLoc to upJnt
			
			$aStr = `pointConstraint $aTempJnts[$i] $alignFalseGrp`;
			for ($str in $aStr)
				delete $str;
			
			$aStr = `pointConstraint $aTempJnts[$i] $alignTrueGrp`;
			for ($str in $aStr)
				delete $str;
			
			$alignTrueGrp = abRTParent($alignTrueGrp, $autoAlignGrp);
			
			parentConstraint -mo $rootCtrl $autoAlignGrp;
			pointConstraint $alignFalseGrp $alignTrueGrp;
			
			// add spaces for root and upJnt
			$aSpaceParCons = `parentConstraint -mo $rootCtrl $upJnt $alignFalseGrp`;
			$aSpaceParConsWeightAtt = `parentConstraint -q -wal $aSpaceParCons[0]`;
			
			addAttr -ln "useRootSpace" -at double -min 0 -max 1 -dv 0 -keyable true $ctrl;
			
			connectAttr -f ($ctrl+".useRootSpace") ($tNode+".inputY");
			connectAttr -f ($tNode+".outputY") ($aSpaceParCons[0]+"."+$aSpaceParConsWeightAtt[1]);
			connectAttr -f ($ctrl+".useRootSpace") ($aSpaceParCons[0]+"."+$aSpaceParConsWeightAtt[0]);
			
			//pointConstraint -mo $alignFalseGrp $alignTrueGrp;
			
			$aParCons = `parentConstraint -mo $alignTrueGrp $alignFalseGrp $tFrzGrp`;
			$aParConsWeightAtt = `parentConstraint -q -wal $aParCons[0]`;
			
			connectAttr -f ($ctrl+".align") ($tNode+".inputX");
			connectAttr -f ($tNode+".outputX") ($aParCons[0]+"."+$aParConsWeightAtt[1]);
			connectAttr -f ($ctrl+".align") ($aParCons[0]+"."+$aParConsWeightAtt[0]);
			
		}else{
			// no align
				
			// parent neckCtrl and make frzGrp
			$ctrl = abRTParent($ctrl, $headGrp);
			$ctrl = abRTGroupFreezeReturnObj($ctrl, true);
			$tFrzGrp = firstParentOf($ctrl);
			
			if ($rootCtrl != ""){
				
				// there is a root so can add useRootSpace
				$aSpaceParCons = `parentConstraint -mo $rootCtrl $upJnt $tFrzGrp`;
				$aSpaceParConsWeightAtt = `parentConstraint -q -wal $aSpaceParCons[0]`;
				
				$tNode = abRTCreateNode("reverse", $aNames[$i]+"_align", "", $limbName);
				
				addAttr -ln "useRootSpace" -at double -min 0 -max 1 -dv 0 -keyable true $ctrl;
				
				connectAttr -f ($ctrl+".useRootSpace") ($tNode+".inputY");
				connectAttr -f ($tNode+".outputY") ($aSpaceParCons[0]+"."+$aSpaceParConsWeightAtt[1]);
				connectAttr -f ($ctrl+".useRootSpace") ($aSpaceParCons[0]+"."+$aSpaceParConsWeightAtt[0]);
				
			}else{
				// just parent it
				parentConstraint -mo $upJnt $tFrzGrp;
				
				if (!$shownAlignMsg){
					confirmDialog -messageAlign "center" -title "Warning" -message "Unable to locate your character's root control (created when\nyou rig the spine).  As a result, your rig will have no align\nattributes on the head or neck controls." -button "OK";
					$shownAlignMsg = true;
				}
			}
		}
		
		parentConstraint $ctrl $aTempJnts[$i];
		
		if ($includeHeadNeckTransAtts){
			abRTHideAttr($ctrl, {"sx","sy","sz","v"});
			abRTSetRootJntAtt("includeHeadNeckTransAtts", "1", $charName);
		}else{
			abRTHideAttr($ctrl, {"tx","ty","tz","useRootSpace","sx","sy","sz","v"});
			abRTSetRootJntAtt("includeHeadNeckTransAtts", "0", $charName);
		}
		
		if ($i < size($aNeckJnts))
			$aNeckCtrls[$i] = $ctrl;
		else
			$headCtrl = $ctrl;
		
	}
	
	// set up head and neck controls
	$aTempCtrls = $aNeckCtrls;
	$aTempCtrls[size($aTempCtrls)] = $headCtrl;
	
	
	// update UI fields, and clean up ctrls
	for ($i=0;$i<size($aTempCtrls);$i++){
		
		$ctrl = $aTempCtrls[$i];
		
		if ($i < size($aNeckCtrls)){
			// neck ctrl
			
			// add extra freezGrp for masterNeckCtrl to rotate
			$ctrl = abRTGroupFreezeReturnObj($ctrl, true);
			$aNeckCtrls[$i] = $ctrl;
			
			// nameString will be neckCtrl (cause there's only one)
			$nameStr = $aNames[$i]+"Ctrl";
			
		}else{
			// head ctrl
			$headCtrl = $ctrl;
			$nameStr = $aNames[$i]+"Ctrl";
		}
		
		// update UI text fields
		abRTSetUITxtFld($nameStr, $ctrl);
		
		// set the rotate order to zxy
		if (attributeExists("rotateOrder", $ctrl)) setAttr ($ctrl+".rotateOrder") 2;
		
		// color the ctrls
		abRTColorObj($ctrl, "ctrCtrlColor", -1);
	}
	
	
	// make eye ctrls
	string $eyeJnt = abRTGetFromUI("eye");
	if ($eyeJnt != ""){
		
		float $scale = float(abRTGetGlobal("globalScale"));
		
		float $eyeCtrlOffset = float(abRTGetGlobal("eyeCtrlOffset"));
		
		string $mEyeJnt = abRTGetMirrorObj($eyeJnt);
		if ($mEyeJnt != ""){
		
		string $prefix = abRTGetObjSide($eyeJnt);
		string $mPrefix = ($prefix == "l") ? "r" : "l";
		
		string $eyeWire = "leftEye_1";
		string $mEyeWire = "rightEye_1";
		
		if ($prefix == "r"){
			$str = $eyeWire;
			$eyeWire = $mEyeWire;
			$mEyeWire = $str;
		}
		
		
		// create and position eyeCtrl
		string $eyeCtrl = abRTMakeWireController($eyeWire, 5, {}, 5);
		$aStr = abRTRename($eyeCtrl, abRTRigNamer("eye", $prefix, "ctrl"));
		$eyeCtrl = $aStr[1];
		
		$eyeCtrl = abRTParent($eyeCtrl, $headGrp);
		
		abRTSnapToPosition($eyeJnt, $eyeCtrl);
		
		string $eyeFrzGrp1 = abRTGroupFreeze($eyeCtrl, 1);
		$eyeCtrl = $eyeFrzGrp1+"|"+abRTStripPath($eyeCtrl);
		
		string $tLoc = abRTMakeLocator("abEyePlacement_loc");
		
		abRTSnapToPosition($eyeJnt, $tLoc);
		
		$aTrans = `xform -q -ws -t $tLoc`;
		
		setAttr ($eyeCtrl+".tz") ($aTrans[2]+$eyeCtrlOffset*$scale);
		
		string $eyeFrzGrp2 = abRTGroupFreeze($eyeCtrl, 1);
		$eyeCtrl = $eyeFrzGrp2+"|"+abRTStripPath($eyeCtrl);
		
		
		// mirror eye ctrl
		string $mEyeCtrl = abRTMakeWireController($mEyeWire, 5, {}, 5);
		$aStr = abRTRename($mEyeCtrl, abRTRigNamer("eye", $mPrefix, "ctrl"));
		$mEyeCtrl = $aStr[1];
		
		$mEyeCtrl = abRTParent($mEyeCtrl, $headGrp);
		
		abRTSnapToPosition($mEyeJnt, $mEyeCtrl);
		
		string $mEyeFrzGrp1 = abRTGroupFreeze($mEyeCtrl, 1);
		$mEyeCtrl = $mEyeFrzGrp1+"|"+abRTStripPath($mEyeCtrl);
		
		abRTSnapToPosition($mEyeJnt, $tLoc);
		$aTrans = `xform -q -ws -t $tLoc`;
		
		setAttr ($mEyeCtrl+".tz") ($aTrans[2]+$eyeCtrlOffset*$scale);
		
		string $mEyeFrzGrp2 = abRTGroupFreeze($mEyeCtrl, 1);
		$mEyeCtrl = $mEyeFrzGrp2+"|"+abRTStripPath($mEyeCtrl);
		
		delete $tLoc;
		
		
		// create and position master control and parent eye ctrls to it
		string $eyeMasterCtrl = abRTMakeWireController("eyeHolder_1", 5, {}, 18);
		$eyeMasterCtrl = abRTParent($eyeMasterCtrl, $headGrp);
		$aStr = abRTRename($eyeMasterCtrl, abRTRigNamer("eyeMaster", "", "ctrl"));
		$eyeMasterCtrl = $aStr[0];
		
		$aStr = `pointConstraint $eyeCtrl $eyeMasterCtrl`;
		pointConstraint $mEyeCtrl $eyeMasterCtrl;
		delete $aStr;
		$aStr = `orientConstraint $eyeCtrl $eyeMasterCtrl`;
		orientConstraint $mEyeCtrl $eyeMasterCtrl;
		delete $aStr;
		
		string $eyeMasterFrzGrp = abRTGroupFreeze($eyeMasterCtrl, 1);
		$eyeMasterCtrl = $eyeMasterFrzGrp+"|"+abRTStripPath($eyeMasterCtrl);
		
		parentConstraint -mo $eyeMasterCtrl $eyeFrzGrp2;
		parentConstraint -mo $eyeMasterCtrl $mEyeFrzGrp2;
		
		// create eye aim constraints
		aimConstraint -aimVector 0 0 1 -upVector 0 0 0 -worldUpVector 0 0 1 -worldUpType "objectrotation" -worldUpObject $head $eyeCtrl $eyeJnt;
		aimConstraint -aimVector 0 0 1 -upVector 0 0 0 -worldUpVector 0 0 1 -worldUpType "objectrotation" -worldUpObject $head $mEyeCtrl $mEyeJnt;
		//aimConstraint -aimVector 0 0 1 $eyeCtrl $eyeJnt;
		//aimConstraint -aimVector 0 0 1 $mEyeCtrl $mEyeJnt;
		
		// hide control atts
		abRTHideAttr($eyeMasterCtrl, {"sx","sy","sz","v"});
		abRTHideAttr($eyeCtrl, {"rx","ry","rz","sx","sy","sz","v"});
		abRTHideAttr($mEyeCtrl, {"rx","ry","rz","sx","sy","sz","v"});
		
		// color the eye ctrls
		abRTColorObj($eyeMasterCtrl, "ctrCtrlColor", -1);
		string $lfColorIndexKey = "lfCtrlColor";
		string $rtColorIndexKey = "rtCtrlColor";
		string $eyeColorIndexKey = ($prefix == "l") ? $lfColorIndexKey : $rtColorIndexKey;
		string $mEyeColorIndexKey = ($mPrefix == "l") ? $lfColorIndexKey : $rtColorIndexKey;
		
		abRTColorObj($eyeCtrl, $eyeColorIndexKey, -1);
		abRTColorObj($mEyeCtrl, $mEyeColorIndexKey, -1);
		
		// parent to spaces
		abRTParentConstrainToSpace($eyeMasterFrzGrp, $eyeMasterCtrl, {"rootCtrl","headCtrl"}, "eyeFrzGrp", "rootCtrl");
		
		}
	}
	
	// set up jaw
	string $jawJnt = abRTGetFromUI("jaw");
	string $childJnt;
	
	if ($jawJnt != ""){
		
		string $jawCtrl = abRTMakeWireController("circle", 0, {}, 5);
		$aStr = abRTRename($jawCtrl, abRTRigNamer("jaw", "", "ctrl"));
		$jawCtrl = $aStr[1];
		
		$jawCtrl = abRTParent($jawCtrl, $headGrp);
		
		abRTSnapToPosition($jawJnt, $jawCtrl);
		
		// now create wire that will replace the wire we just created
		// get last child of jaw joint and snap new wire to it
		
		$childJnt = $jawJnt;
		
		do {
			$aStr = `listRelatives -c -type joint $childJnt`;
			if (size($aStr) == 1)
				$childJnt = $aStr[0];
			else
				break;
			
		} while (size($aStr) == 1);
		
		
		// center jaw wire on childJnt
		abRTCenterWireOnPivot($jawCtrl, $childJnt);
		
		
		// constrain
		$jawCtrl = abRTGroupFreezeReturnObj($jawCtrl, 1);
		parentConstraint -mo $head (firstParentOf($jawCtrl));
		orientConstraint $jawCtrl $jawJnt;
		
		// hide atts, and color
		abRTHideAttr($jawCtrl, {"tx","ty","tz","sx","sy","sz","v"});
		abRTColorObj($jawCtrl, "ctrCtrlColor", -1);
		
	}
	
	select -clear;
	
	$ret = 1;
	return $ret;
}


global proc int abRTRigArm(string $upArmJnt){
	// rigs an arm -- returns 1 on success,  -1 on fail
	
	int $int, $i;
	float $xForm[], $xForm2[], $float, $float2;
	string $aRel[], $aStr[], $aJnts[], $globalKey, $name, $aNames[], $str, $jnt;
	string $aCtrlCurves[]; // all ctrl curves put in this array will be colored according to the side of the body
	string $aIkCtrls[]; // objects in this array will have visibility switched according to ikFk switch on footCtrl
	string $aFkCtrls[]; // objects in this array will have visibility switched according to ikFk switch on footCtrl
	string $aArmJntKeyNames[] = {"upArm","elbow","wrist"};
	
	int $ret = -1;
	
	int $premiumVersion = int(abRTGetGlobal("premiumVersion"));
	string $charName = abRTGetGlobal("name");
	
	if ($upArmJnt == "") return $ret;
	
	string $charName = abRTGetGlobal("name");
	
	abRTSetScale($upArmJnt);
	
	string $rootJnt = abRTGetRootFromJoint($upArmJnt);
	if ($rootJnt == ""){
		warning "Can't find the skeleton's root joint.";
		return -1;
	}
	
	//string $rigSettingsCtrl = abRTGetFromUI("rigSettingsCtrl");
	
	int $upArmSplitNum = int(abRTGetGlobal("upArmSplitNum"));
	int $foreArmSplitNum = int(abRTGetGlobal("foreArmSplitNum"));
	
	// get joints
	string $aAllArmJnts[];
	string $elbowJnt, $wristJnt, $handJnt;
	string $aArmJnts[];
	
	// find elbow
	$elbowJnt = abRTGetDownJoint($upArmJnt);
	
	if ($elbowJnt == ""){
		warning "Unable to locate the elbow joint.  Make sure your elbow joint is the only child of your upArm joint with children of its own.";
		return $ret;
	}
	
	// find wrist
	$wristJnt = abRTGetDownJoint($elbowJnt);
	if ($wristJnt == ""){
		warning "Unable to locate the wrist joint.  Make sure your wrist joint is the only child of your elbow joint with children of its own.";
		return $ret;
	}
	
	// make sure there are no old style splits
	string $aOldSplits[];
	
	$aOldSplits = abRTGetSplits($upArmJnt, true);
	$aOldSplits = stringArrayCatenate($aOldSplits, abRTGetSplits($upArmJnt, false));
	$aOldSplits = stringArrayCatenate($aOldSplits, abRTGetSplits($elbowJnt, true));
	$aOldSplits = stringArrayCatenate($aOldSplits, abRTGetSplits($elbowJnt, false));
	
	
	if (size($aOldSplits) > 0){
		if ($premiumVersion){
			$str = `confirmDialog -title "Confirm" -message "This character's arm and split joints must be updated before it can be rigged.  You can use the included skeleton update tool." -button "Ok" -button "Run Skeleton Updater" -defaultButton "Ok"`;
			
			if ($str == "Run Skeleton Updater"){
				if (exists("abRTUpdateSkeletonSplitsJointsUI"))
					abRTUpdateSkeletonSplitsJointsUI();
			}
		}else{
			$str = `confirmDialog -title "Confirm" -message "This character's arm and split joints must be updated before it can be rigged.  The Advanced version comes with an update tool that makes this a little bit easier.\n\nJust sayin'." -button "Ok" -defaultButton "Ok"`;
		}
		
		return $ret;
	}
	
	
	// build some arrays
	$aArmJnts = {$upArmJnt, $elbowJnt, $wristJnt};
	$aAllArmJnts = $aArmJnts;
	
	string $shoulderJnt = firstParentOf($upArmJnt);
	
	$aRel = `listRelatives -c -fullPath -type joint $wristJnt`;
	if (size($aRel) != 1){
		warning "There needs to be a single hand joint beneath the wrist joint.";
		return $ret;
	}
	string $handJnt = $aRel[0];
	
	string $prefix = abRTGetObjSide($upArmJnt);
	string $limbName = ($prefix == "l") ? "leftArm" : "rightArm";
	
	string $rootCtrl = abRTGetFromUI("rootCtrl");
	int $mirroredBehavior = abRTJointMirroredBehavior($elbowJnt);
	
	string $colorIndexKey = ($prefix == "l") ? "lfCtrlColor" : "rtCtrlColor"; // get global colorIndex for this side of the body
	
	
	// create arm rig group
	string $armGrp = (abRTRigNamer("arm", $prefix, "rigGrp")); // arm group -- all arm rig transforms created from here out will be placed in this group
	if (!`objExists ((abRTRigRootFolder())+"|"+$armGrp)`){
		$armGrp = `group -em -name $armGrp`;
		$armGrp = abRTParent($armGrp, abRTRigRootFolder());
	}else{
		warning "This part of the character has already been rigged.  You must remove the current rig before you can continue.";
		return $ret;
	}
	
	abRTConnectToMasterScale($armGrp);
	
	// save armGrp to charVars
	abRTSaveRigGrpToCharVars($armGrp, $limbName);
	
	// put fk ctrls on shoulder
	$aStr = abRTAddFkControls({$shoulderJnt}, {"clavicle"}, {}, "", "", "sphere", $armGrp, $limbName);
	$shouderJnt =  $aStr[0];
	$shoulderCtrl = $aStr[1];
	
	abRTHideAttr($shoulderCtrl, {"rx"});
	//abRTReplaceWireController($shoulderCtrl, "simpleCurve", 3, false);
	abRTReplaceWireController($shoulderCtrl, "simpleCurve", 3, false, {});
	
	$xForm = objectCenter($shoulderJnt);
	$xForm2 = objectCenter($upArmJnt);
	abRTMoveWireRelativeToPivot($shoulderCtrl, (($xForm2[0]-$xForm[0])), 2, 0, true);
	
	// color it
	abRTColorObj($shoulderCtrl, $colorIndexKey, -1);
	
	// make fk arm
	string $fkArmGrp = `group -em -name (abRTRigNamer("armFK", $prefix, "Grp")) -p $armGrp`;
	
	if ($shoulderJnt != ""){
		select -r $shoulderJnt $fkArmGrp;
	}else{
		select -r $upArmJnt $fkArmGrp;
	}
	
	abRTPointOrient(1);
	select -clear;
	
	clear($aNames);
	for ($globalKey in $aArmJntKeyNames) $aNames[size($aNames)] = abRTRigNamer($globalKey, $prefix, "fkJnt");
	$aJnts = abRTDuplicateJointHierarchy($aArmJnts, $aNames, $fkArmGrp);
	
	if ($shoulderJnt != "")
		parentConstraint -mo $shoulderJnt $fkArmGrp;
	
	// add fk controls
	string $spineHighJnt = $charName+"_spine_end_jnt";
	if (!objExists($spineHighJnt))
		$spineHighJnt = "";
	
	$aStr = abRTAddFkControls({$aJnts[0],$aJnts[1],$aJnts[2]}, $aArmJntKeyNames, {0,2}, $shoulderJnt, $spineHighJnt, "sphere", $armGrp, $limbName);
	
	
	string $aFkJnts[];
	for ($i=0;$i<size($aStr);$i+=2){
		$aFkJnts[size($aFkJnts)] = $aStr[$i];
		$aFkCtrls[size($aFkCtrls)] = $aStr[$i+1];
	}
	
	// limit elbow to bend axis
	float $elbowVector[] = abRTFindClosestAxisToWorldRetVector($elbowJnt, {0.0,1.0,0.0});
	$aStr = {"rx","ry","rz"};
	for ($i=0;$i<size($elbowVector);$i++){
		if (abs($elbowVector[$i]) > .1)
			stringArrayRemoveAtIndex($i, $aStr);
	}
	abRTHideAttr($aFkCtrls[1], $aStr);
	
	// color it
	for ($jnt in $aFkJnts) abRTColorObj($jnt, "fkJntColor", -1);
	
	// color them
	$aCtrlCurves = stringArrayCatenate($aCtrlCurves,$aFkCtrls);
	
	// set rotation order
	setAttr ($aFkCtrls[0]+".rotateOrder") 2; // zxy
	setAttr ($aFkCtrls[2]+".rotateOrder") 2; // zxy
	
	// fk done
	
	
	// make ik arm
	// start with names
	
	// make grp for ik arm
	string $ikArmGrp = `group -em -name ((abRTRigNamer("armIK", $prefix, "Grp"))) -p $armGrp`;
	
	if ($shoulderJnt != ""){
		select -r $shoulderJnt $ikArmGrp;
	}else{
		select -r $upArmJnt $ikArmGrp;
	}
	
	abRTPointOrient(1);
	select -clear;
	
	clear($aNames);
	for ($globalKey in $aArmJntKeyNames) $aNames[size($aNames)] = abRTRigNamer($globalKey, $prefix, "ikJnt");
	string $aIkJnts[] = abRTDuplicateJointHierarchy({$upArmJnt,$elbowJnt,$wristJnt}, $aNames, $ikArmGrp);
	
	if ($shoulderJnt != "") parentConstraint -mo $shoulderJnt $ikArmGrp;
	
	
	// color it 
	for ($jnt in $aIkJnts) abRTColorObj($jnt, "ikJntColor", -1);
	
	// create ik control curve
	string $ikCtrlCrv = abRTMakeWireController("diamond", 8, {}, 10);
	abRTSnapToPosition($wristJnt, $ikCtrlCrv);
	
	$ikCtrlCrv = abRTParent($ikCtrlCrv, $armGrp);
	$aStr = abRTRename($ikCtrlCrv, (abRTRigNamer("arm", $prefix, "ikCtrl")));       
	$ikCtrlCrv = $aStr[1];
	
	int $alignIkWithWorld = int(abRTGetGlobal("alignHandIkToWorld"));
	string $ikCtrlGrp; // only used if the hand is not aligned to the world
	
	if ($alignIkWithWorld){
		// freeze transforms on ikCtrlCrv and hide rotation atts
		setAttr ($ikCtrlCrv+".r") 0 0 0;
		$ikCtrlGrp = abRTGroupFreeze($ikCtrlCrv, 1);
		$ikCtrlCrv = $ikCtrlGrp+"|"+abRTStripPath($ikCtrlCrv);
		
		abRTSetRootJntAtt("alignHandIkToWorld", "1", $charName);
	}else{
		if ($mirroredBehavior && $prefix == "r"){
			// rotate the ikCtrlCrv into proper orientation
			$float = `getAttr ($ikCtrlCrv+".rx")`;
			$float = ($float > 0) ? $float - 180 : $float + 180;
			setAttr ($ikCtrlCrv+".rx") $float;
		}
		$ikCtrlGrp = abRTGroupFreeze($ikCtrlCrv, 1);
		$ikCtrlCrv = $ikCtrlGrp+"|"+abRTStripPath($ikCtrlCrv);
		
		abRTSetRootJntAtt("alignHandIkToWorld", "0", $charName);
	}
	
	
	// write offset values (of Ik ctrl from wrist joint) for matching Ik to Fk
	abRTWriteIkCtrlWristJntOffsetData($wristJnt, $ikCtrlCrv, "IkCtrlOffsetFromWristJnt");
	
	if ($prefix == "l")
		abRTSetUITxtFld("lfArmIkCtrl", $ikCtrlCrv);
	else
		abRTSetUITxtFld("rtArmIkCtrl", $ikCtrlCrv);
	
	// hide undesired attributes
	abRTHideAttr($ikCtrlCrv, {"sx","sy","sz","v"});
	
	// color it (later)
	$aCtrlCurves[size($aCtrlCurves)] = $ikCtrlCrv;
	
	// set up its visibility (later
	$aIkCtrls[size($aIkCtrls)] = $ikCtrlCrv;
	
	// create arm ikHandle
	string $ikArmHandle = abRTMakeIkHandle($aIkJnts[0], $aIkJnts[2], abRTRigNamer("arm", $prefix, "ikHndl"), $ikCtrlCrv, $armGrp);
	
	// add attributes to ik control
	
	// arm twist
	addAttr -ln "armTwist" -at double -min -180 -max 180 -dv 0 -keyable true $ikCtrlCrv;
	connectAttr ($ikCtrlCrv+".armTwist") ($ikArmHandle+".twist");
	
	// create hand control curve (attached to bottom of hand)
	string $handCtrlCrv = abRTMakeWireController("circle", 0, {}, 12);
	
	abRTSnapToPosition($handJnt, $handCtrlCrv);
	
	$handCtrlCrv = abRTParent($handCtrlCrv, $armGrp);
	$aStr = abRTRename($handCtrlCrv, (abRTRigNamer("hand", $prefix, "ctrl")));
	$handCtrlCrv = $aStr[1];
	
	string $handCtrlParGrp = `group -w -em -n (abRTRigNamer("handCtrl", $prefix, "grp"))`;
	$handCtrlParGrp = abRTParent($handCtrlParGrp, $armGrp);
	
	abRTSnapToPosition($wristJnt, $handCtrlParGrp);
	
	$handCtrlCrv = abRTParent($handCtrlCrv, $handCtrlParGrp);
	
	string $handCtrlPtGrpFrz = abRTGroupFreeze($handCtrlCrv, 1);
	$handCtrlCrv = $handCtrlPtGrpFrz+"|"+abRTStripPath($handCtrlCrv);
	
	string $handCtrlOrGrpFrz = abRTGroupFreeze($handCtrlCrv, 1);
	$handCtrlCrv = $handCtrlOrGrpFrz+"|"+abRTStripPath($handCtrlCrv);
	
	parentConstraint $wristJnt $handCtrlParGrp;
	orientConstraint $handCtrlCrv $handJnt;
	
	// want to orientConstrain wrist to ikCtrl without -mo -- need to make child locator to which we can parent wrist
	string $ikCtrlOrientLoc = abRTMakeLocator(abRTRigNamer("ikCtrlCrvOrientOffset",$prefix,"loc"));
	
	$ikCtrlOrientLoc = abRTParent($ikCtrlOrientLoc, $ikCtrlCrv);
	abRTSnapToPosition($aIkJnts[2], $ikCtrlOrientLoc);
	$ikCtrlOrientLoc = abRTGroupFreezeReturnObj($ikCtrlOrientLoc, true);
	setAttr ($ikCtrlOrientLoc+".v") 0;
	
	orientConstraint -mo $ikCtrlOrientLoc $aIkJnts[2];
	
	// rotate order
	setAttr ($ikCtrlCrv+".rotateOrder") 2;
	setAttr ($handCtrlCrv+".rotateOrder") 2;
	
	// hide undesired attributes
	abRTHideAttr($handCtrlCrv, {"tx","ty","tz","sx","sy","sz","v"});
	
	// color it (later)
	$aCtrlCurves[size($aCtrlCurves)] = $handCtrlCrv;
	
	// add attributes
	
	addAttr -ln "ikFkBlend" -at double -min 0 -max 1 -dv 1 -keyable true $handCtrlCrv;
	
	addAttr -ln "ikVis" -at bool -keyable true $handCtrlCrv;
	setAttr ($handCtrlCrv+".ikVis") 0;
	connectAttr ($handCtrlCrv+".ikVis") ($aIkJnts[0]+".v");
	
	addAttr -ln "fkVis" -at bool -keyable true $handCtrlCrv;
	setAttr ($handCtrlCrv+".fkVis") 0;
	connectAttr ($handCtrlCrv+".fkVis") ($aFkJnts[0]+".v");
	
	// create ikFkBlend reverse (used later)
	string $ikFkReverse = abRTCreateNode("reverse", "armIkFkSwitch", $prefix, $limbName);
	connectAttr -f ($handCtrlCrv+".ikFkBlend") ($ikFkReverse+".inputX");
	
	// hand ctrl done
	
	
	// expose rotate order on controls
	setAttr -lock false -channelBox true ($ikCtrlCrv+".rotateOrder");
	setAttr -lock false -channelBox true ($handCtrlCrv+".rotateOrder");
	
	
	// create pv control
	$aStr = abRTMakePvControl($aIkJnts, $ikArmHandle, $elbowJnt, 2, "elbow", $armGrp);
	string $pvCtrl = $aStr[0];
	string $pvCtrlGrp = $aStr[2];
	$aIkCtrls[size($aIkCtrls)] = $pvCtrlGrp; // add to ik vis nodes
	
	// pv vis controls on ik arm ctrl
	addAttr -ln "pvControl" -at bool -keyable true $ikCtrlCrv;
	setAttr ($ikCtrlCrv+".pvControl") 1;
	
	// $aStr[0] - pv control, $aStr[1] - pv constraint, $aStr[3] - pv line, $aStr[4] - lineJointLoc
	connectAttr -f ($ikCtrlCrv+".pvControl") ($pvCtrl+".v");
	connectAttr ($ikCtrlCrv+".pvControl") ($aStr[1]+"."+(abRTStripPath($pvCtrl))+"W0");
	connectAttr -f ($ikCtrlCrv+".pvControl") ($aStr[3]+".v");
	connectAttr -f ($ikCtrlCrv+".pvControl") ($aStr[4]+".v");
	
	// create blend for pv control (between pv constraint and 0 0 0)
	string $tCon[];
	$tCon[size($tCon)] = `connectionInfo -sourceFromDestination ($ikArmHandle+".poleVectorX")`;
	$tCon[size($tCon)] = `connectionInfo -sourceFromDestination ($ikArmHandle+".poleVectorY")`;
	$tCon[size($tCon)] = `connectionInfo -sourceFromDestination ($ikArmHandle+".poleVectorZ")`;
	
	string $pvCtrlBlnd = abRTCreateNode("blendColors", "armPvCtrl", $prefix, $limbName);
	
	connectAttr ($ikCtrlCrv+".pvControl") ($pvCtrlBlnd+".blender");
	
	connectAttr $tCon[0] ($pvCtrlBlnd+".color1R");
	connectAttr $tCon[1] ($pvCtrlBlnd+".color1G");
	connectAttr $tCon[2] ($pvCtrlBlnd+".color1B");
	
	setAttr ($pvCtrlBlnd+".color2") 0 0 0;
	
	connectAttr -f ($pvCtrlBlnd+".outputR") ($ikArmHandle+".poleVectorX");
	connectAttr -f ($pvCtrlBlnd+".outputG") ($ikArmHandle+".poleVectorY");
	connectAttr -f ($pvCtrlBlnd+".outputB") ($ikArmHandle+".poleVectorZ");
	
	// color it (later)
	$aCtrlCurves[size($aCtrlCurves)] = $pvCtrl;
	
	// pv done (except for snap, which will be plugged into elbow after orient stuff)
	
	
	// add stretch
	abRTMakeIKStretchy($aArmJnts, $aIkJnts, $aFkJnts, $ikCtrlCrv, $handCtrlCrv, $ikCtrlCrv, $armGrp, $limbName);
	
	// tx constrain arm to fk and ik
	string $armTxBlnd = abRTCreateNode("blendColors", "armTrans", $prefix, $limbName);
	
	connectAttr ($handCtrlCrv+".ikFkBlend") ($armTxBlnd+".blender");
	connectAttr ($aIkJnts[1]+".tx") ($armTxBlnd+".color1R");
	connectAttr ($aIkJnts[2]+".tx") ($armTxBlnd+".color1G");
	connectAttr ($aFkJnts[1]+".tx") ($armTxBlnd+".color2R");
	connectAttr ($aFkJnts[2]+".tx") ($armTxBlnd+".color2G");
	
	// connect upArm and elbow jnts tx (including splits) to $armTxBlnd outputs
	float $elbowTx = `getAttr ($aIkJnts[1]+".tx")`;
	float $wristTx = `getAttr ($aIkJnts[2]+".tx")`;
	
	connectAttr ($armTxBlnd+".outputR") ($elbowJnt+".tx");
	connectAttr ($armTxBlnd+".outputG") ($wristJnt+".tx");
	
	// stretch done
	
	
	// orient constrain arm to fk and ik
	// constrain ik
	clear $aNames;
	for ($globalKey in $aArmJntKeyNames) $aNames[size($aNames)] = abRTRigNamer($globalKey, $prefix, "ikFkCons");
	string $aIkJntCons[] = abRTMassOrientConstraint({$aIkJnts[0],$aIkJnts[1],$aIkJnts[2]}, $aArmJnts, $aNames);
	
	// constrain fk (using same $aNames because these are the same constraints)
	string $aFkJntCons[] = abRTMassOrientConstraint({$aFkJnts[0],$aFkJnts[1],$aFkJnts[2]}, $aArmJnts, $aNames);
	
	for ($str in $aIkJntCons) connectAttr -f ($handCtrlCrv+".ikFkBlend") $str;
	for ($str in $aFkJntCons) connectAttr -f ($ikFkReverse+".outputX") $str;
	
	// Set up arm twist
	string $aData[] = abRTMakeLimbWeightAndCtrlJnts({$upArmJnt, $elbowJnt, $wristJnt}, {"upArm", "elbow", "wrist"}, $upArmSplitNum, $foreArmSplitNum, $prefix, $rootJnt, "arm", $armGrp, true);
	
	if (size($aData) == 0){
		// failure -- undo
		evalDeferred("undo");
		return $ret;
	}
	
	// parse data
	
	// $aData[0] - skelGroup  
	// $aData[1] - upWtJnt & midWtJnt & dnWtJnt
	// $aData[2] - upWtSplit1 & upWtSplit2
	// $aData[3] - dnWtSplit1 & dnWtSplit2
	// $aData[4] - upCtrlJnt & midCtrlJnt & dnCtrlJnt
	// $aData[5] - upCtrlSplit1 & upCtrlSplit2
	// $aData[6] - dnCtrlSplit1 & dnCtrlSplit2
	// $aData[7] - upSplitCtrlParentJnt
	// $aData[8] - dnSplitCtrlParentJnt
	
	string $aUpArmWtSplits[], $aForeArmWtSplits[], $aUpArmCtrlSplits[], $aForeArmCtrlSplits[], $rhStretchCurve, $upSplitCtrlParentJnt, $dnSplitCtrlParentJnt;
	
	string $skelArmWtJntGrp = $aData[0];
	
	$aStr = stringToStringArray($aData[1], "&");
	string $upArmWtJnt = $aStr[0]; 
	string $elbowWtJnt = $aStr[1]; 
	string $wristWtJnt = $aStr[2]; 
	
	if ($aData[2] != ""){
		$aStr = stringToStringArray($aData[2], "&");
		for ($str in $aStr)
			if ($str != "")	$aUpArmWtSplits[size($aUpArmWtSplits)] = $str;
	}
	
	if ($aData[3] != ""){
		$aStr = stringToStringArray($aData[3], "&");
		for ($str in $aStr)
			if ($str != "")	$aForeArmWtSplits[size($aForeArmWtSplits)] = $str;
	}
	
	$aStr = stringToStringArray($aData[4], "&");
	string $upArmCtrlJnt = $aStr[0]; 
	string $elbowCtrlJnt = $aStr[1]; 
	string $wristCtrlJnt = $aStr[2]; 
	
	if ($aData[5] != ""){
		$aStr = stringToStringArray($aData[5], "&");
		for ($str in $aStr)
			if ($str != "")	$aUpArmCtrlSplits[size($aUpArmCtrlSplits)] = $str;
	}
	
	if ($aData[6] != ""){
		$aStr = stringToStringArray($aData[6], "&");
		for ($str in $aStr)
			if ($str != "")	$aForeArmCtrlSplits[size($aForeArmCtrlSplits)] = $str;
	}
	
	if ($aData[7] != ""){
		$upSplitCtrlParentJnt = $aData[7];
		setAttr ($upSplitCtrlParentJnt+".v") 0;
	}
	
	if ($aData[8] != ""){
		$dnSplitCtrlParentJnt = $aData[8];
		setAttr ($dnSplitCtrlParentJnt+".v") 0;
	}
	
	// data parsed
	
	float $aimVector[], $upVector[], $worldUpVector[];
	string $upArmTwistObjAtt, $foreArmTwistObjAtt, $lastSplitAttName, $firstSplitAttName;
	
	// get rubber leg info from UI
	int $rubberHoseArms = false;
	int $upArmRHCtrlNum = 0;
	int $foreArmRHCtrlNum = 0;
	
	if ($upArmSplitNum > 0){
		
		$firstSplitAttName = "upArm";
		
		$upArmTwistObjAtt = abRTMakeSplitJointTargetLoc($upSplitCtrlParentJnt, $upArmJnt, $elbowJnt, "", {}, {}, {}, "upArm", "", "", $limbName, $armGrp);
		abRTConnectSplitJntsToTwist($aUpArmCtrlSplits, $upArmCtrlJnt, $elbowJnt, $upArmTwistObjAtt, "upArm", $limbName, $rubberHoseArms, $firstSplitAttName, "");
	}
	
	// now foreArm which uses an aim constraint to determine twist
	$upVector = abRTFindClosestAxisToWorldRetVector($elbowJnt, {0.0,0.0,1.0});
	$worldUpVector = abRTFindClosestAxisToWorldRetVector($handCtrlCrv, {0.0,0.0,1.0});
	
	addAttr -ln "useAimTwist" -at double -dv 0 -min 0 -max 1 -keyable true $handCtrlCrv;
	
	// parent wrist to elbow
	$wristCtrlJnt = abRTParent($wristCtrlJnt, $elbowCtrlJnt);
	
	if ($foreArmSplitNum > 0){
		
		$lastSplitAttName = "wrist";
		addAttr -ln "forearmTwistCtrl" -at double -dv 0 -min 0 -max 1 -keyable true $handCtrlCrv;
		
		$foreArmTwistObjAtt = abRTMakeSplitJointTargetLoc("", $elbowJnt, $wristJnt, $handJnt, $aimVector, $upVector, $worldUpVector, "forearm", $handCtrlCrv+".forearmTwistCtrl", $handCtrlCrv+".useAimTwist", $limbName, $armGrp);
		abRTConnectSplitJntsToTwist((stringArrayCatenate($aForeArmCtrlSplits, {$wristCtrlJnt})), "", $wristJnt, $foreArmTwistObjAtt, "forearm", $limbName, $rubberHoseArms, "", $lastSplitAttName);
		
	}else{
		// there are no other split joints, so treat the wrist like one
		$lastSplitAttName = "wrist";
		addAttr -ln "wristTwistCtrl" -at double -dv 0 -min 0 -max 1 -keyable true $handCtrlCrv;
		
		$foreArmTwistObjAtt = abRTMakeSplitJointTargetLoc("", $elbowJnt, $wristJnt, $handJnt, $aimVector, $upVector, $worldUpVector, "forearm", $handCtrlCrv+".wristTwistCtrl", $handCtrlCrv+".useAimTwist", $limbName, $armGrp);
		abRTConnectSplitJntsToTwist({$wristCtrlJnt}, "", $wristJnt, $foreArmTwistObjAtt, "forearm", $limbName, $rubberHoseArms, "", $lastSplitAttName);
	}
	
	
	// bind wtJnts to ctrlJnts and clean up
	string $aArmCtrlJnts[], $aArmWtJnts[];
	
	$aArmCtrlJnts = stringArrayCatenate({$upArmCtrlJnt, $elbowCtrlJnt, $wristCtrlJnt}, $aUpArmCtrlSplits);
	$aArmWtJnts = stringArrayCatenate({$upArmWtJnt, $elbowWtJnt, $wristWtJnt}, $aUpArmWtSplits);
	
	$aArmCtrlJnts = stringArrayCatenate($aArmCtrlJnts, $aForeArmCtrlSplits);
	$aArmWtJnts = stringArrayCatenate($aArmWtJnts, $aForeArmWtSplits);
	
	for ($i=0;$i<size($aArmCtrlJnts);$i++){
		parentConstraint $aArmCtrlJnts[$i] $aArmWtJnts[$i];
		setAttr ($aArmCtrlJnts[$i]+".v") 0;
	}
	
	// add to armJnts which will later be saved to charVars (important for removing the rig cleanly)
	$aAllArmJnts = stringArrayCatenate($aAllArmJnts, $aArmCtrlJnts);
	$aAllArmJnts = stringArrayCatenate($aAllArmJnts, $aArmWtJnts);
	
	// done with twist
	
	
	
	// attach visibility
	string $ikVisCond = abRTCreateNode("condition", "armIkVis", $prefix, $limbName);
	string $fkVisCond = abRTCreateNode("condition", "armFkVis", $prefix, $limbName);
	
	connectAttr -f ($handCtrlCrv+".ikFkBlend") ($ikVisCond+".firstTerm"); 
	setAttr ($ikVisCond+".operation") 2;
	setAttr ($ikVisCond+".colorIfTrueR") 1;
	setAttr ($ikVisCond+".colorIfFalseR") 0;
	
	connectAttr -f ($handCtrlCrv+".ikFkBlend") ($fkVisCond+".firstTerm"); 
	setAttr ($fkVisCond+".operation") 4;
	setAttr ($fkVisCond+".secondTerm") 1;
	setAttr ($fkVisCond+".colorIfTrueR") 1;
	setAttr ($fkVisCond+".colorIfFalseR") 0;
	
	for ($str in $aIkCtrls) connectAttr -f ($ikVisCond+".outColorR") ($str+".v"); 
	for ($str in $aFkCtrls) connectAttr -f ($fkVisCond+".outColorR") ($str+".v"); 
	
	// color the curves in $aCtrlCurves
	for ($str in $aCtrlCurves) abRTColorObj($str, $colorIndexKey, -1);
	
	// add pv snap
	addAttr -ln "snapElbow" -at double -min 0 -max 1 -dv 0 -keyable true $pvCtrl;
	
	// make distanceDim -- upArm to pvCtrl
	$aStr = abRTMakeDistanceDim({abRTRigNamer("upArmPvCtrl",$prefix,"dist"),abRTRigNamer("upArmPvCtrl",$prefix,"dist_sp"),abRTRigNamer("upArmPvCtrl",$prefix,"dist_ep")}, $aIkJnts[0], $pvCtrl, $armGrp);
	
	string $upArmPvDistShape = $aStr[3];
	pointConstraint $aIkJnts[0] $aStr[1];
	pointConstraint $pvCtrl $aStr[2];
	
	// make distanceDim -- pvCtrl to ikCtrl
	$aStr = abRTMakeDistanceDim({abRTRigNamer("armPvIkCtrl",$prefix,"dist"),abRTRigNamer("armPvIkCtrl",$prefix,"dist_sp"),abRTRigNamer("armPvIkCtrl",$prefix,"dist_ep")}, $pvCtrl, $ikCtrlCrv, $armGrp);
	
	string $pvIkCtrlDistShape = $aStr[3];
	pointConstraint $pvCtrl $aStr[1];
	pointConstraint $ikCtrlCrv $aStr[2];
	
	// divide distance values by the masterScale on the rootCtrl
	string $upArmPvDistAtt, $pvIkCtrlDistAtt;
	
	if ($rootCtrl == ""){
		$upArmPvDistAtt = $upArmPvDistShape+".distance";
		$pvIkCtrlDistAtt = $pvIkCtrlDistShape+".distance";
	}else{
		// create multDiv node to divide values by masterScale
		string $pvDistMltDiv = abRTCreateNode("multiplyDivide", "armPvDistScaleAdjust", $prefix, $limbName);
		setAttr ($pvDistMltDiv+".operation") 2;
		connectAttr ($upArmPvDistShape+".distance") ($pvDistMltDiv+".input1X");
		connectAttr ($pvIkCtrlDistShape+".distance") ($pvDistMltDiv+".input1Y");
		connectAttr ($rootCtrl+".masterScale") ($pvDistMltDiv+".input2X");
		connectAttr ($rootCtrl+".masterScale") ($pvDistMltDiv+".input2Y");
		
		$upArmPvDistAtt = ($pvDistMltDiv+".outputX");
		$pvIkCtrlDistAtt = ($pvDistMltDiv+".outputY");
		
	}
	
	if ($mirroredBehavior && $prefix == "r"){
		// if skeleton was created with mirror behavior, tx will be negative for the -X limb joints, need to negate it to get PV snap to move the joints the correct way
		
		string $pvNegateTxMltDiv = abRTCreateNode("multiplyDivide", "armPvNegate", $prefix, $limbName);
		setAttr ($pvNegateTxMltDiv+".input2") -1 -1 0;
		connectAttr $upArmPvDistAtt ($pvNegateTxMltDiv+".input1X");
		connectAttr $pvIkCtrlDistAtt ($pvNegateTxMltDiv+".input1Y");
		
		$upArmPvDistAtt = ($pvNegateTxMltDiv+".outputX");
		$pvIkCtrlDistAtt = ($pvNegateTxMltDiv+".outputY");
	}
	
	abRTSpliceConnection(($aIkJnts[1]+".tx"), $upArmPvDistAtt, ($pvCtrl+".snapElbow"), false, "upArmSnap", $prefix, $limbName);
	abRTSpliceConnection(($aIkJnts[2]+".tx"), $pvIkCtrlDistAtt, ($pvCtrl+".snapElbow"), false, "elbowSnap", $prefix, $limbName);
	
	// pv snap done
	
	// add spaces to hand and pvctrl
	string $txtFldPrefix = ($prefix == "l") ? "lf" : "rt";
	
	$pvCtrl = abRTParentConstrainToSpace($pvCtrl, $pvCtrl, {"rootCtrl","cogCtrl","lowSpineCtrl","hiSpineCtrl","masterSpineCtrl",($txtFldPrefix+"ArmIkCtrl")}, "armPvCtrlGrp","rootCtrl");
	
	// if not aligned to world then need to send ikCtrlGrp to abRTParentConstrainToSpace
	$ikCtrlGrp = abRTParentConstrainToSpace($ikCtrlGrp, $ikCtrlCrv, {"rootCtrl","cogCtrl","lowSpineCtrl","hiSpineCtrl","masterSpineCtrl","headCtrl"}, "armIkCtrl","rootCtrl");
	$ikCtrlCrv = $ikCtrlGrp+"|"+abRTStripPath($ikCtrlCrv);
	
	// update UI again
	if ($prefix == "l")
		abRTSetUITxtFld("lfArmIkCtrl", $ikCtrlCrv);
	else
		abRTSetUITxtFld("rtArmIkCtrl", $ikCtrlCrv);
	
	select -clear;
	
	// save arm joints to charVars
	abRTSaveToCharVars($aAllArmJnts, $limbName);
	
	$ret = 1;
	return $ret;
}


global proc string[] abRTMakeLimbWeightAndCtrlJnts(string $aRefJnts[], string $aJntBaseNames[], int $upJntSplitNum, int $dnJntSplitNum, string $prefix, string $rootJnt, string $limbBaseName, string $rigGrp, int $makeCtrlJnts){
	
	// makes weight joints for arms and legs
	// $aRefJnts is {upJnt, midJnt, dnJnt} hierarchy the weight joints will follow
	// $aJntBaseNames is baseNames for each joint in $aRefJnts e.g. {upArm, elbow, wrist}
	// $upJntSplitNum and $dnJntSplitNum are number of splits for each
	// $limbBaseName is "arm" or "leg"
	// $makeCtrlJnts will only make weight joints (called from skelBuilder) if false ($rigGrp not required if false)
	// returns dataStr in form of aData[n]
	// 0 - skelGroup  
	// 1 - upWtJnt & midWtJnt & dnWtJnt
	// 2 - upWtSplit1 & upWtSplit2
	// 3 - dnWtSplit1 & dnWtSplit2
	// 4 - upCtrlJnt & midCtrlJnt & dnCtrlJnt
	// 5 - upCtrlSplit1 & upCtrlSplit2
	// 6 - dnCtrlSplit1 & dnCtrlSplit2
	// 7 - upSplitCtrlParentJnt
	// 8 - dnSplitCtrlParentJnt
	
	// init some vars
	string $aWtJnts[], $aStr[], $aRet[], $aRel[], $rel, $jnt, $str;
	string $upWtJnt, $midWtJnt, $dnWtJnt;
	string $tSplitJnt, $aUpLimbWtSplits[], $aUpLimbCtrlSplits[], $aMidLimbWtSplits[], $aMidLimbCtrlSplits[];
	string $tCtrl, $tCtrlBaseNm, $aUpLimbSplitCtrls[], $aMidLimbSplitCtrls[], $aUpLimbSplitCtrlGrps[], $aMidLimbSplitCtrlGrps[];
	string $tWtJntBaseNm, $tCtrlJntName, $tWtJnt, $tCtrlJnt;
	int $i;
	
	int $maxNumSplitJnts = 10;
	
	string $charName = abRTGetGlobal("name");
	string $namingPrefix = ($prefix == "l") ? "lf_" : "rt_";
	
	if (size($aRefJnts) != size($aJntBaseNames))
		return $aRet;
	
	int $createLimbWtJntsInHierarchy;
	
	if (abRTGetRootJntAtt("createLimbWtJntsInHierarchy", $charName) != ""){
		
		$createLimbWtJntsInHierarchy = int(abRTGetRootJntAtt("createLimbWtJntsInHierarchy", $charName));
	}else{
		
		// if there's no rootJntAtt, assume the value is false (don't create joints in a hierarchy -- the old system)
		// if they are in a hierarchy, it won't be removed regardless of the value of $createLimbWtJntsInHierarchy -- it will just be left as it is
		$createLimbWtJntsInHierarchy = false;
		abRTSetRootJntAtt("createLimbWtJntsInHierarchy", "0", $charName);
	}
	
	
	// make arm weight jnt group
	string $skeletonGrp = firstParentOf($rootJnt);
	string $skelLimbWeightJntGroupName = $namingPrefix+$limbBaseName+"WeightJnt_grp";
	string $skelLimbWtJntGrp = $skeletonGrp+"|"+$skelLimbWeightJntGroupName;
	
	if (!objExists($skelLimbWtJntGrp))
		group -em -name $skelLimbWeightJntGroupName -parent $skeletonGrp;
	
	// check to see if there are enough weight joints
	int $useExUpMidDnWtJnts = false;
	int $useExUpSplitWtJnts = false;
	int $useExDnSplitWtJnts = false;
	
	// get existing weight joints (aExUpSplits and aExDnSplits are in order from top of joint chain to bottom)
	string $aExWtJnts[], $aExUpSplits[], $aExDnSplits[], $exUpWtJnt, $exMidWtJnt, $exUpDnJnt, $tUpWtJnt, $tDnWtJnt;
	int $matchedUpJnt, $matchedDnJnt;
	
	// weight joints are under nulls so that they'll rotate correctly when parented to ctrlJnts -- have to verify nulls and weightJnts
	//$aStr = `listRelatives -c $skelLimbWtJntGrp`;
	$aStr = `listRelatives -ad -type joint $skelLimbWtJntGrp`;
	
	for ($jnt in $aStr)
		$aExWtJnts[size($aExWtJnts)] = shortNameOf($jnt);
	
	if (size($aExWtJnts) > 0){
		
		// check for weight joints
		
		$upWtJnt = abRTRigNamer($aJntBaseNames[0]+"Weight", $prefix, "jnt");
		$midWtJnt = abRTRigNamer($aJntBaseNames[1]+"Weight", $prefix, "jnt");
		$dnWtJnt = abRTRigNamer($aJntBaseNames[2]+"Weight", $prefix, "jnt");
		
		if ((abRTGetPosInStrArray($upWtJnt, $aExWtJnts) != -1) && (abRTGetPosInStrArray($midWtJnt, $aExWtJnts) != -1) && (abRTGetPosInStrArray($dnWtJnt, $aExWtJnts) != -1))
			$useExUpMidDnWtJnts = true;
		else
			$upWtJnt = $midWtJnt = $dnWtJnt = "";
		
		// now sort out split joints
		
		for ($i=0;$i<$maxNumSplitJnts;$i++){
			
			$tUpWtJnt = $aJntBaseNames[0]+"WeightSplit_"+($i+1);
			$tUpWtJnt = abRTRigNamer($tUpWtJnt, $prefix, "jnt");
			$tDnWtJnt = $aJntBaseNames[1]+"WeightSplit_"+($i+1);
			$tDnWtJnt = abRTRigNamer($tDnWtJnt, $prefix, "jnt");
			
			$matchedUpJnt = $matchedDnJnt = false;
			
			if (abRTGetPosInStrArray($tUpWtJnt, $aExWtJnts) != -1){
				$aExUpSplits[size($aExUpSplits)] = $tUpWtJnt;
				$matchedUpJnt = true;
			}
			
			if (abRTGetPosInStrArray($tDnWtJnt, $aExWtJnts) != -1){
				$aExDnSplits[size($aExDnSplits)] = $tDnWtJnt;
				$matchedDnJnt = true;
			}
			
			if ($matchedUpJnt == false && $matchedDnJnt == false)
				break;
		}
		
		if ((size($aExUpSplits) > 0 && size($aExUpSplits) != $upJntSplitNum) || (size($aExDnSplits) > 0 && size($aExDnSplits) != $dnJntSplitNum)){
			// alert and delete
			$str = `confirmDialog -title "Confirm" -message ("Some or all of this character's existing "+$limbBaseName+"\nweight joints don't match the required\nweight joints and will have to be deleted.") -button "Ok" -button "Cancel" -defaultButton "Ok" -cancelButton "Cancel" -dismissString "Cancel"`;
			
			if ($str == "Cancel"){
				//evalDeferred("undo");
				return $aRet;
			}
		}
		
		if (size($aExUpSplits) == $upJntSplitNum){
			$useExUpSplitWtJnts = true;
		}else{
			for($jnt in $aExUpSplits){
				
				// unparent children to prevent deleting joints down the hierarchy that we want to keep (if joints are arranged in a hierarchy);
				if (objExists($jnt)){
					
					$aRel = `listRelatives -c -type joint $jnt`;
					
					for ($rel in $aRel)
						parent $rel (firstParentOf($jnt));
					
					delete $jnt;
				}
			}
		}
		
		if (size($aExDnSplits) == $dnJntSplitNum){
			$useExDnSplitWtJnts = true;
		}else{
			for($jnt in $aExDnSplits){
				
				// same as before
				if (objExists($jnt)){
					
					$aRel = `listRelatives -c -type joint $jnt`;
					
					for ($rel in $aRel)
						parent $rel (firstParentOf($jnt));
					
					delete $jnt;
				}
			}
		}
	}
	
	
	// make upArm and elbow weight jnts and put copy of each in armWeightJnt grp and in $splitCtrlJntGrp
	// first set radius to clavicle
	float $radius = `getAttr (firstParentOf($aRefJnts[0])+".radius")`;
	setAttr ($aRefJnts[0]+".radius") $radius;
	setAttr ($aRefJnts[1]+".radius") $radius;
	setAttr ($aRefJnts[2]+".radius") $radius;
	
	// weight joints
	
	if (!$useExUpMidDnWtJnts){
		
		$aStr = `duplicate -parentOnly $aRefJnts[0]`;
		$upWtJnt = abRTParent($aStr[0], $skelLimbWtJntGrp);
		$aStr = `duplicate -parentOnly $aRefJnts[1]`;                         
		$midWtJnt = abRTParent($aStr[0], $skelLimbWtJntGrp);
		$aStr = `duplicate -parentOnly $aRefJnts[2]`;                         
		$dnWtJnt = abRTParent($aStr[0], $skelLimbWtJntGrp);
		
		$aStr = abRTRename($upWtJnt, (abRTRigNamer($aJntBaseNames[0]+"Weight", $prefix, "jnt")));
		$upWtJnt = $aStr[1];
		$aStr = abRTRename($midWtJnt, (abRTRigNamer($aJntBaseNames[1]+"Weight", $prefix, "jnt")));
		$midWtJnt = $aStr[1];
		$aStr = abRTRename($dnWtJnt, (abRTRigNamer($aJntBaseNames[2]+"Weight", $prefix, "jnt")));
		$dnWtJnt = $aStr[1];
		
	}else{
		
		abRTSnapToPosition($aRefJnts[0], $upWtJnt);
		abRTSnapToPosition($aRefJnts[1], $midWtJnt);
		abRTSnapToPosition($aRefJnts[2], $dnWtJnt);
	}
	
	string $upCtrlJnt, $midCtrlJnt, $dnCtrlJnt;
	string $splitCtrlJntGrp;
	
	// make limbSplitCtrlGrp (holds joints to which weight jnts will be constrained)
	if ($makeCtrlJnts){
		$splitCtrlJntGrp = $namingPrefix+$limbBaseName+"WtCtrlJnt_grp";
		$splitCtrlJntGrp = `group -em -name $splitCtrlJntGrp -parent $rigGrp`;
	}else{
		$splitCtrlJntGrp = "abAutoRigTempWtCtrlJnt_grp";
		$splitCtrlJntGrp = `group -em -name $splitCtrlJntGrp`;
	}
	
	// now ctrl joints
	$aStr = `duplicate -parentOnly $aRefJnts[0]`;
	$upCtrlJnt = abRTParent($aStr[0], $splitCtrlJntGrp);
	$aStr = `duplicate -parentOnly $aRefJnts[1]`;                         
	$midCtrlJnt = abRTParent($aStr[0], $splitCtrlJntGrp);
	$aStr = `duplicate -parentOnly $aRefJnts[2]`;                         
	$dnCtrlJnt = abRTParent($aStr[0], $splitCtrlJntGrp);
	
	$aStr = abRTRename($upCtrlJnt, (abRTRigNamer($aJntBaseNames[0]+"Ctrl", $prefix, "jnt")));
	$upCtrlJnt = $aStr[1];
	$aStr = abRTRename($midCtrlJnt, (abRTRigNamer($aJntBaseNames[1]+"Ctrl", $prefix, "jnt")));
	$midCtrlJnt = $aStr[1];
	$aStr = abRTRename($dnCtrlJnt, (abRTRigNamer($aJntBaseNames[2]+"Ctrl", $prefix, "jnt")));
	$dnCtrlJnt = $aStr[1];
	
	string $upSplitCtrlParentJnt, $dnSplitCtrlParentJnt;
	
	if ($upJntSplitNum > 0){
		
		// make upSplitCtrlParentJnt which will be the parent to the upCtrlSplit joints -- upCtrlJnt will sit in the same frzGrp as upSplitCtrlParentJnt
		$aStr = `duplicate -parentOnly $upCtrlJnt`;
		$upSplitCtrlParentJnt = abRTParent($aStr[0], $splitCtrlJntGrp);
		$aStr = abRTRename($upSplitCtrlParentJnt, (abRTRigNamer($aJntBaseNames[0]+"UpSplitCtrlParent", $prefix, "jnt")));
		$upSplitCtrlParentJnt = $aStr[1];
	}
	
	if ($dnJntSplitNum > 0){
		
		// make dnSplitCtrlParentJnt which will be the parent to the upCtrlSplit joints -- upCtrlJnt will sit in the same frzGrp as dnSplitCtrlParentJnt
		$aStr = `duplicate -parentOnly $midCtrlJnt`;
		$dnSplitCtrlParentJnt = abRTParent($aStr[0], $splitCtrlJntGrp);
		$aStr = abRTRename($dnSplitCtrlParentJnt, (abRTRigNamer($aJntBaseNames[0]+"DnSplitCtrlParent", $prefix, "jnt")));
		$dnSplitCtrlParentJnt = $aStr[1];
	}
	
	// some group freezing
	$upCtrlJnt = abRTGroupFreezeReturnObj($upCtrlJnt, true);
	
	if ($upSplitCtrlParentJnt != "")
		$upSplitCtrlParentJnt = abRTGroupFreezeReturnObj($upSplitCtrlParentJnt, true);
	
	if ($makeCtrlJnts){
		
		// parent and constrain
		if ($upJntSplitNum > 0){
			parentConstraint -mo (firstParentOf($aRefJnts[0])) (firstParentOf($upSplitCtrlParentJnt));
			//parentConstraint -mo $aRefJnts[0] (firstParentOf($upSplitCtrlParentJnt));
			parentConstraint $upSplitCtrlParentJnt (firstParentOf($upCtrlJnt));
		}else{
			parentConstraint $aRefJnts[0] $upCtrlJnt;
		}
		
		if ($dnJntSplitNum > 0){
			parentConstraint $aRefJnts[1] $dnSplitCtrlParentJnt;
		}
		
		parentConstraint $aRefJnts[1] $midCtrlJnt;
		
	}
	
	
	// hide orig jnts
	setAttr ($aRefJnts[0]+".radius") .01;
	setAttr ($aRefJnts[1]+".radius") .01;
	setAttr ($aRefJnts[2]+".radius") .01;
	
	// get length of upArm and elbow bones
	float $upJntLen = `getAttr ($aRefJnts[1]+".tx")`;
	float $midJntLen = `getAttr ($aRefJnts[2]+".tx")`;
	
	// make splits
	
	// upJnt -- (as of v. 5.2 joints are branching)
	float $splitSep = $upJntLen/(float($upJntSplitNum+1));
	for ($i=0;$i<$upJntSplitNum;$i++){
		
		$tWtJntBaseNm = $aJntBaseNames[0]+"WeightSplit_"+($i+1);
		$tCtrlJntBaseNm = $aJntBaseNames[0]+"CtrlSplit_"+($i+1);
		$tCtrlBaseNm = $aJntBaseNames[0]+"Split_"+($i+1);
		
		// dup upJnt and parent new jnt under previous split
		$aStr = `duplicate -parentOnly $upSplitCtrlParentJnt`;
		//$aStr = `duplicate -parentOnly $upCtrlJnt`;
		
		// parent to upJnt so it can be positioned
		$tSplitJnt = abRTParent($aStr[0], $upSplitCtrlParentJnt);
		setAttr ($tSplitJnt+".tx") ($splitSep*($i+1));
		
		// reparent under the last split jnt
		//if ($i > 0)
		//	$tSplitJnt = abRTParent($aStr[0], $aUpLimbCtrlSplits[$i-1]);
		
		// use it as a ctrl jnt
		$aStr = abRTRename($tSplitJnt, (abRTRigNamer($tCtrlJntBaseNm, $prefix, "jnt")));
		$tCtrlJnt = $aStr[1];
		
		// create weight joint if it doesn't exist
		if (!$useExUpSplitWtJnts){
			
			// need to make a weight jnt
			$aStr = `duplicate -parentOnly $tCtrlJnt`;
			$tWtJnt = abRTParent($aStr[0], $skelLimbWtJntGrp);
			$aStr = abRTRename($tWtJnt, (abRTRigNamer($tWtJntBaseNm, $prefix, "jnt")));
			$tWtJnt = $aStr[1];
			
		}else{
			
			// make sure weight jnt is properly positioned
			$tWtJnt = abRTRigNamer($tWtJntBaseNm, $prefix, "jnt");
			if (objExists($tWtJnt))
				abRTSnapToPosition($tCtrlJnt, $tWtJnt);
		}
		
		// update both arrays
		$aUpLimbCtrlSplits[$i] = $tCtrlJnt;
		$aUpLimbWtSplits[$i] = $tWtJnt;
	}
	
	
	// dnJnt -- (joints are branching)
	float $splitSep = $midJntLen/(float($dnJntSplitNum+1));
	for ($i=0;$i<$dnJntSplitNum;$i++){
		
		$tWtJntBaseNm = $aJntBaseNames[1]+"WeightSplit_"+($i+1);
		$tCtrlJntBaseNm = $aJntBaseNames[1]+"CtrlSplit_"+($i+1);
		$tCtrlBaseNm = $aJntBaseNames[1]+"Split_"+($i+1);
		
		// dup upJnt and parent new jnt under upJnt to position correctly
		$aStr = `duplicate -parentOnly $dnSplitCtrlParentJnt`;
		$tSplitJnt = abRTParent($aStr[0], $dnSplitCtrlParentJnt);
		setAttr ($tSplitJnt+".tx") ($splitSep*($i+1));
		
		// use it as a ctrl jnt
		$aStr = abRTRename($tSplitJnt, (abRTRigNamer($tCtrlJntBaseNm, $prefix, "jnt")));
		$tCtrlJnt = $aStr[1];
		
		// create weight joint if it doesn't exist
		if (!$useExDnSplitWtJnts){
			
			// need to make a weight jnt
			$aStr = `duplicate -parentOnly $tCtrlJnt`;
			$tWtJnt = abRTParent($aStr[0], $skelLimbWtJntGrp);
			$aStr = abRTRename($tWtJnt, (abRTRigNamer($tWtJntBaseNm, $prefix, "jnt")));
			$tWtJnt = $aStr[1];
			
		}else{
			
			// make sure weight jnt is properly positioned
			$tWtJnt = abRTRigNamer($tWtJntBaseNm, $prefix, "jnt");
			if (objExists($tWtJnt))
				abRTSnapToPosition($tCtrlJnt, $tWtJnt);
		}
		
		$aMidLimbCtrlSplits[$i] = $tCtrlJnt;
		$aMidLimbWtSplits[$i] = $tWtJnt;
	}
	
	// ok, those ctrlJnts we made -- they never existed.
	if (!$makeCtrlJnts){
		
		// delete jnts
		delete $splitCtrlJntGrp;
		
		// and empty vars
		clear($aUpLimbCtrlSplits);
		clear($aMidLimbCtrlSplits);
		
		$splitCtrlJntGrp = $upCtrlJnt = $midCtrlJnt = $dnCtrlJnt = "";
	}
	
	// write splitNum of jnts to rootJntAtt (read by script UI to preset splitNum sliders when rerigging)
	if ($limbBaseName == "arm"){
		
		abRTSetRootJntAtt("upArmSplitNum", string($upJntSplitNum), $charName);             
		abRTSetRootJntAtt("foreArmSplitNum", string($dnJntSplitNum), $charName);
		
	}else if ($limbBaseName == "leg"){
		
		abRTSetRootJntAtt("upLegSplitNum", string($upJntSplitNum), $charName);             
		abRTSetRootJntAtt("lowLegSplitNum", string($dnJntSplitNum), $charName);
	}
	
	
	// parent weight joints to one another, starting with the upArm
	string $prevJnt;
	
	if ($createLimbWtJntsInHierarchy){
		
		for ($i=0;$i<size($aUpLimbWtSplits);$i++){
			
			$prevJnt = ($i == 0) ? $upWtJnt : $aUpLimbWtSplits[$i-1];
			$aUpLimbWtSplits[$i] = abRTParent($aUpLimbWtSplits[$i], $prevJnt);
		}
		
		$prevJnt = (size($aUpLimbWtSplits) == 0) ? $upWtJnt : $aUpLimbWtSplits[size($aUpLimbWtSplits)-1];
		$midWtJnt = abRTParent($midWtJnt, $prevJnt);
		
		for ($i=0;$i<size($aMidLimbWtSplits);$i++){
			
			$prevJnt = ($i == 0) ? $midWtJnt : $aMidLimbWtSplits[$i-1];
			$aMidLimbWtSplits[$i] = abRTParent($aMidLimbWtSplits[$i], $prevJnt);
		}
		
		$prevJnt = (size($aMidLimbWtSplits) == 0) ? $midWtJnt : $aMidLimbWtSplits[size($aMidLimbWtSplits)-1];
		$dnWtJnt = abRTParent($dnWtJnt, $prevJnt);
	}
	
	// done
	
	
	// connect to rootCon SkeletonVis att
	string $rootCtrl, $skelVisAtt, $skelVisObjAtt, $aVisJnts[];
	
	$rootCtrl = abRTGetFromUI("rootCtrl");
	$skelVisAtt = "skeletonVis";
	
	if ($rootCtrl != ""){
		
		if (attributeExists($skelVisAtt, $rootCtrl)){
			
			$skelVisObjAtt = $rootCtrl+"."+$skelVisAtt;
			
			$aVisJnts = {$upWtJnt,$midWtJnt,$dnWtJnt};
			$aVisJnts = stringArrayCatenate($aVisJnts, $aUpLimbWtSplits);
			$aVisJnts = stringArrayCatenate($aVisJnts, $aMidLimbWtSplits);
			
			for ($jnt in $aVisJnts){
				
				// connect it if not connected
				if (!`connectionInfo -isDestination ($jnt+".v")` && !`connectionInfo -isSource ($jnt+".v")`){
					
					connectAttr -f $skelVisObjAtt ($jnt+".v");
				}
			}
		}
	}
	
	
	$aRet[0] = $skelLimbWtJntGrp;
	$aRet[1] = $upWtJnt+"&"+$midWtJnt+"&"+$dnWtJnt;
	$aRet[2] = stringArrayToString($aUpLimbWtSplits, "&");
	$aRet[3] = stringArrayToString($aMidLimbWtSplits, "&");
	$aRet[4] = $upCtrlJnt+"&"+$midCtrlJnt+"&"+$dnCtrlJnt;
	$aRet[5] = stringArrayToString($aUpLimbCtrlSplits, "&");
	$aRet[6] = stringArrayToString($aMidLimbCtrlSplits, "&");
	$aRet[7] = $upSplitCtrlParentJnt;
	$aRet[8] = $dnSplitCtrlParentJnt;
	
	return $aRet;
}


global proc abRTUnStickifyIKLimb(){
	// unsticks stuck IK limbs (select a related control curve)
	// usually happens when rig creation changes the number of split joints (but not always)
	// once fixed it seems to stay fixed
	
	string $charName;
	string $lfPrefix = abRTGetGlobal("leftPrefix");
	string $rtPrefix = abRTGetGlobal("rightPrefix");
	
	string $aSel[] = `ls -sl`;
	
	if (size($aSel) > 0){
		$charName = abRTGetCharNameFromCtrl("", false);
		
		if ($charName == ""){
			warning "No value character control curves selected.  Select at least one control curve on your character's stuck limb and try again.";
			return;
		}
	}
	
	// # = prefix
	
	string $aLegCtrls[] = {$charName+"_#knee_pv_ctrl",$charName+"_#foot_ctrl",$charName+"_#heel_ik_ctrl",$charName+"_#hip_ctrl"};
	string $aArmCtrls[] = {$charName+"_#arm_ik_ctrl",$charName+"_#hand_ctrl",$charName+"_#elbow_pv_ctrl",$charName+"_#shoulder_ctrl"};
	
	string $aIkJnts[] = {$charName+"_"+$lfPrefix+"knee_ik_jnt", $charName+"_"+$rtPrefix+"knee_ik_jnt", $charName+"_"+$lfPrefix+"elbow_ik_jnt", $charName+"_"+$rtPrefix+"elbow_ik_jnt"};
	
	string $tLfCrv, $tRtCrv, $aIkJntsToUnStick[], $aLfSel[], $aRtSel[], $ikJnt;
	int $i, $k, $ro;
	
	int $lfArm = false;
	int $rtArm = false;
	int $lfLeg = false;
	int $rtLeg = false;
	
	int $unstuckCounter = 0;
	
	if (size($aSel) == 0){
		
		// match any and all controls
		string $aIkMatchStr[] = {"*_"+$lfPrefix+"knee_ik_jnt", "*_"+$rtPrefix+"knee_ik_jnt", "*_"+$lfPrefix+"elbow_ik_jnt", "*_"+$rtPrefix+"elbow_ik_jnt"};
		$aIkJntsToUnStick = `ls -type joint $aIkMatchStr`;
		
	}else{
		
		// match control
		for ($i=0;$i<size($aLegCtrls);$i++){
			
			$tLfCrv = substitute("#", $aLegCtrls[$i], $lfPrefix);
			$tRtCrv = substitute("#", $aLegCtrls[$i], $rtPrefix);
			
			$aLfSel = `ls -sl $tLfCrv`;
			$aRtSel = `ls -sl $tRtCrv`;
			
			if (size($aLfSel) > 0 && !$lfLeg){
				$aIkJntsToUnStick[size($aIkJntsToUnStick)] = $charName+"_"+$lfPrefix+"knee_ik_jnt";
				$lfLeg = true;
			}
			
			if (size($aRtSel) > 0 && !$rtLeg){
				$aIkJntsToUnStick[size($aIkJntsToUnStick)] = $charName+"_"+$rtPrefix+"knee_ik_jnt";
				$rtLeg = true;
			}
		}
		
		
		for ($i=0;$i<size($aArmCtrls);$i++){
			
			$tLfCrv = substitute("#", $aArmCtrls[$i], $lfPrefix);
			$tRtCrv = substitute("#", $aArmCtrls[$i], $rtPrefix);
			
			$aLfSel = `ls -sl $tLfCrv`;
			$aRtSel = `ls -sl $tRtCrv`;
			
			if (size($aLfSel) > 0 && !$lfArm){
				$aIkJntsToUnStick[size($aIkJntsToUnStick)] = $charName+"_"+$lfPrefix+"elbow_ik_jnt";
				$lfArm = true;
			}
			
			if (size($aRtSel) > 0 && !$rtArm){
				$aIkJntsToUnStick[size($aIkJntsToUnStick)] = $charName+"_"+$rtPrefix+"elbow_ik_jnt";
				$rtArm = true;
			}
		}
	}
	
	for ($ikJnt in $aIkJntsToUnStick){
		
		if (!objExists($ikJnt))
			continue;
		
		// a little bit of magic that keeps the IK from locking up
		$ro = `getAttr ($ikJnt+".rotateOrder")`;
		
		setAttr ($ikJnt+".rotateOrder") (($ro+3)%5);
		setAttr ($ikJnt+".rotateOrder") $ro;
		
		$unstuckCounter++;
	}
	
	if ($unstuckCounter > 0)
		print ("\n"+$unstuckCounter+" joint(s) unstuck.\n");
	else
		print ("\nNo joints unstuck.\n");
	
}


global proc float[] abRTFindClosestAxisToWorldRetVector(string $obj, float $aWorldVector[]){
	// wrapper for abRTFindClosestAxisToWorld but returns vector instead of int
	
	int $axis = abRTFindClosestAxisToWorld($obj, $aWorldVector);
	
	if ($axis == 0) return {1.0,0.0,0.0};
	if ($axis == 1) return {0.0,1.0,0.0};
	if ($axis == 2) return {0.0,0.0,1.0};
	if ($axis == 3) return {-1.0,0.0,0.0};
	if ($axis == 4) return {0.0,-1.0,0.0};
	if ($axis == 5) return {0.0,0.0,-1.0};
	
}


global proc int abRTFindClosestAxisToWorld(string $obj, float $aWorldVector[]){
	// returns closest axis of obj to given world vector (in form of x:0 y:1 z:2 -x:3 -y:4 -z:5)
	// I'm sure there's some super simple way to do this -- I just don't know it yet, so I'm hacking on through
	
	// make a loc and snap it to our obj
	string $aLocs[], $cLoc; 
	string $baseName = "abHackLoc_";
	float $aTrans0[], $aTransX[], $aTransY[], $aTransZ[];
	float $aXVector[], $aYVector[], $aZVector[];
	float $aNegXVector[], $aNegYVector[], $aNegZVector[];
	float $aDotProduct[], $min;
	
	int $i;
	int $ret = 0;
	
	for ($i=0;$i<4;$i++){
		
		// make locs
		$cLoc = abRTMakeLocator($baseName+$i);
		$aLocs[size($aLocs)] = $cLoc;
		
		// snap them
		abRTSnapToPosition($obj, $cLoc);
	}
	
	// move locs in axes x, y, z
	xform -os -r -t 1 0 0 $aLocs[1];
	xform -os -r -t 0 1 0 $aLocs[2];
	xform -os -r -t 0 0 1 $aLocs[3];
	
	// get vectors
	$aTrans0 = `xform -q -ws -t $aLocs[0]`;
	$aTransX = `xform -q -ws -t $aLocs[1]`;
	$aTransY = `xform -q -ws -t $aLocs[2]`;
	$aTransZ = `xform -q -ws -t $aLocs[3]`;
	
	$aXVector = {$aTrans0[0]-$aTransX[0], $aTrans0[1]-$aTransX[1], $aTrans0[2]-$aTransX[2]};
	$aYVector = {$aTrans0[0]-$aTransY[0], $aTrans0[1]-$aTransY[1], $aTrans0[2]-$aTransY[2]};
	$aZVector = {$aTrans0[0]-$aTransZ[0], $aTrans0[1]-$aTransZ[1], $aTrans0[2]-$aTransZ[2]};
	
	$aNegXVector = {-$aXVector[0], -$aXVector[1], -$aXVector[2]};
	$aNegYVector = {-$aYVector[0], -$aYVector[1], -$aYVector[2]};
	$aNegZVector = {-$aZVector[0], -$aZVector[1], -$aZVector[2]};
	
	// delete locs
	for ($cLoc in $aLocs) delete $cLoc;
	
	// compare vectors to aWorldVector
	$aDotProduct[0] = dotProduct($aWorldVector, $aXVector, false);
	$aDotProduct[1] = dotProduct($aWorldVector, $aYVector, false);
	$aDotProduct[2] = dotProduct($aWorldVector, $aZVector, false);
	$aDotProduct[3] = dotProduct($aWorldVector, $aNegXVector, false);
	$aDotProduct[4] = dotProduct($aWorldVector, $aNegYVector, false);
	$aDotProduct[5] = dotProduct($aWorldVector, $aNegZVector, false);
	
	$min = 180;
	
	for ($i=0;$i<6;$i++){
		
		if ($aDotProduct[$i] < $min){
			$min = $aDotProduct[$i];
			$ret = $i;
		}
		
	}
	
	return $ret;
}


global proc string abRTMakeSplitJointTargetLoc(string $upJntGetsTwist, string $upJnt, string $dnJnt, string $target, float $aimVector[], float $upVector[], float $worldUpVector[], string $baseName, string $twistCtrlBlendObjAtt, string $aimPvTwistSrcBlendObjAtt, string $limbName, string $rigGrp){
	
	// creates target locs for up and down limbs from which split joint rotation can be read
	// $upJntGetsTwist is upJnt that twists -- no aimLoc and jnts must be inline (like upArm), leave empty for reading dnJnt twist and rotating splits (like wrist) where joints are branching
	// if using $upJntGetsTwist, $target, $twistCtrlBlendObjAtt, and vector variables are ignored
	// $upJnt is joint above splits in hierarchy (must be the same for all), $dnJnt is the joint below upJnt that the splitjoints are twisting for
	// $target is object to get rotations from or can be an attribute string ("obj.att") in which case aimVector info is ignored and no aimconstraint is created
	// $baseName is foreArm, upArm, upLeg, lowLeg, etc
	// $twistCtrlBlendObjAtt is an obj.att (double, min 0, max 1) that will enable the manual rotation control.
	// $aimPvTwistSrcBlendObjAtt is obj.att (double, min 0, max 1) that will switch between aimconstraint and pv twist readers
	// $limbName is for rig remover
	// returns reader obj.output (if any)
	
	
	string $txMltDiv, $rxMltDiv, $cAxis, $aimLocGrp, $aimLoc, $targLoc, $attLabel, $aRxMltDiv[], $labelPrfx, $aStr[], $tJnt, $str, $upJntIkHandle, $upJntChildJnt, $aimLocGrp, $aimLocGrpFrzGrp;
	string $twistCtrl, $twistCtrlFrzGrp, $twistCtrlAttObj, $twistCtrlAtt, $readerSrcObjAtt;
	float $jntTx, $txRatio, $rxRatio, $aUpSplitRatios[], $aTempSplitRatios[];
	int $i, $k;
	
	int $locVis = 0; // vis for built locs -- set to false unless testing
	
	float $gScale = float(abRTGetGlobal("globalScale"));
	
	string $aAxis[] = {"X","Y","Z"};
	string $prefix = abRTGetObjSide($upJnt);
	string $labelPrfx = ($prefix == "l") ? "LF" : "RT";
	string $lowerBaseName = tolower($baseName);
	
	string $rigSettingsCtrl = abRTGetFromUI("rigSettingsCtrl");
	if (!(objExists($rigSettingsCtrl)))
		$rigSettingsCtrl = "";
	
	
	if ($upJntGetsTwist == ""){
		
		// set up aim loc
		$aimLoc = abRTMakeLocatorV2((abRTRigNamer($baseName+"Twist", $prefix, "loc")), $upJnt, $rigGrp);
		
		$aimLoc = abRTGroupFreezeReturnObj($aimLoc, true);
		$aimLocGrp = firstParentOf($aimLoc);
		
		setAttr ($aimLoc+".s") 2 2 2;
		setAttr ($aimLoc+".v") $locVis;
		
		// make target loc
		$targLoc = abRTMakeLocatorV2((abRTRigNamer($baseName+"TwistTarget", $prefix, "loc")), $target, $rigGrp);
		$targLoc = abRTGroupFreezeReturnObj($targLoc, true);
		parentConstraint $target (firstParentOf($targLoc));
		
		setAttr ($targLoc+".s") 2 2 2;
		setAttr ($targLoc+".v") $locVis;
		
		parentConstraint -n (abRTRigNamer($baseName+"SplitAimLoc", $prefix, "parCons")) $upJnt $aimLocGrp;
		aimConstraint -n (abRTRigNamer($baseName+"SplitAimLoc", $prefix, "aimCons")) -mo -aimVector $aimVector[0] $aimVector[1] $aimVector[2] -upVector $upVector[0] $upVector[1] $upVector[2] -worldUpVector $worldUpVector[0] $worldUpVector[1] $worldUpVector[2] -worldUpType "objectrotation" -worldUpObject $targLoc $targLoc $aimLoc;
		
		if ($aimPvTwistSrcBlendObjAtt != ""){
			
			// set up pv twist reader and create a blend node to swap between it and the aim constraint
			// has to be a down joint for the 
			string $pvRotUpJnt, $pvRotDnJnt;
			
			select -clear;
			
			// dup upJnt and move it down
			$aStr = `duplicate -po -n (abRTRigNamer($baseName+"UpTwistReader", $prefix, "jnt")) $upJnt`;
			$pvRotUpJnt = $aStr[0];
			setAttr ($pvRotUpJnt+".radius") $gScale;
			
			// parent to upJnt and move
			$pvRotUpJnt = abRTParent($pvRotUpJnt, $upJnt);
			setAttr ($pvRotUpJnt+".tx") (`getAttr ($dnJnt+".tx")`);
			
			$pvRotUpJnt = abRTParent($pvRotUpJnt, $rigGrp);
			$pvRotUpJnt = abRTGroupFreezeReturnObj($pvRotUpJnt, 1);
			
			string $pvRotJntFrzGrp = firstParentOf($pvRotUpJnt);
			
			$aStr = `duplicate -po -n (abRTRigNamer($baseName+"dnTwistReader", $prefix, "jnt")) $pvRotUpJnt`;
			$pvRotDnJnt = $aStr[0];
			$pvRotDnJnt = abRTParent($pvRotDnJnt, $pvRotUpJnt);
			
			float $dnJntDist = ($prefix == "l") ? 1 : -1;
			setAttr ($pvRotDnJnt+".tx") $dnJntDist;
			
			string $dnJntIkHandle = abRTMakeIkHandle($pvRotUpJnt, $pvRotDnJnt, (abRTRigNamer($baseName+"Twist", $prefix, "ikHndl")), $target, $rigGrp);
			
			setAttr ($dnJntIkHandle+".poleVector") 0 0 0;
			
			parentConstraint -mo $upJnt $pvRotJntFrzGrp;
			pointConstraint $dnJnt $pvRotUpJnt;
			
			// now make rotation reader (not really an aim loc, but serves the same purpose) -- parent to upJntGetsTwist (top of control jnts that sit on top of upJnt, elbowJnt, wristJnt hierarchy) and orient to $upJnt to read rotation difference
			string $pvRotLoc = abRTMakeLocatorV2((abRTRigNamer($baseName+"PvTwistReader", $prefix, "loc")), $dnJnt, $rigGrp);
			$pvRotLoc = abRTGroupFreezeReturnObj($pvRotLoc, true);
			string $pvRotLocFrzGrp = (firstParentOf($pvRotLoc));
			
			if ($target != $dnJnt){
				
				// make two freezeGrps and constrain one to dnJnt and one to target
				$pvRotLoc = abRTGroupFreezeReturnObj($pvRotLoc, true);
				parentConstraint $target (firstParentOf($pvRotLoc));
			}
			
			// can't parent $pvRotLoc to $dnJnt (want to keep rig separate from hierarchy) so put it in a parentConstrained frzGrp instead
			parentConstraint $dnJnt $pvRotLocFrzGrp;
			
			orientConstraint -skip "y" -skip "z" -n (abRTRigNamer($baseName+"TwistReader", $prefix, "orCons")) $pvRotUpJnt $pvRotLoc;
			
			// now create reader attribute on pvRotLoc (to reverse rotation)
			addAttr -ln "readerRot" -at double $pvRotLoc;
			//setAttr -e -channelBox true ($pvRotLoc+".readerRot");
			string $pvRotRvrsePlsMns = abRTCreateNode("plusMinusAverage", ($baseName+"TwistReverser"), $prefix, $limbName);
			
			// and connect it up
			setAttr ($pvRotRvrsePlsMns+".operation") 2; // subtract
			setAttr ($pvRotRvrsePlsMns+".input1D[0]") 0;
			connectAttr ($pvRotLoc+".rx") ($pvRotRvrsePlsMns+".input1D[1]");
			connectAttr ($pvRotRvrsePlsMns+".output1D") ($pvRotLoc+".readerRot");
			
			// now blend the aim and pv twist atts
			string $aimPvTwistSrcBlnd = abRTCreateNode("blendColors", ($baseName+"AimPvTwist"), $prefix, $limbName);
			
			connectAttr $aimPvTwistSrcBlendObjAtt ($aimPvTwistSrcBlnd+".blender");
			connectAttr ($aimLoc+".rx") ($aimPvTwistSrcBlnd+".color1R");
			connectAttr ($pvRotLoc+".readerRot") ($aimPvTwistSrcBlnd+".color2R");
			$readerSrcObjAtt = $aimPvTwistSrcBlnd+".outputR";
			
			setAttr ($pvRotUpJnt+".v") $locVis;
			setAttr ($pvRotLoc+".v") $locVis;
		}
	}else{
		
		// add a down joint to if upJnt has none
		$aStr = `listRelatives -type joint -c $upJntGetsTwist`;
		
		if (size($aStr) == 0){
			$aStr = `duplicate -po $upJntGetsTwist`;
			$upJntChildJnt = $aStr[0];
			$upJntChildJnt = abRTParent($upJntChildJnt, $upJntGetsTwist);
			setAttr ($upJntChildJnt+".tx") ((`getAttr ($dnJnt+".tx")`)/2.0);
		}else{
			$upJntChildJnt = $aStr[0];
		}
		
		$upJntIkHandle = abRTMakeIkHandle($upJntGetsTwist, $upJntChildJnt, (abRTRigNamer($baseName+"Twist", $prefix, "ikHndl")), $upJnt, $rigGrp);
		
		// pv to 0 so now the upJntGetsTwist jnts won't rotate in X with parent (upJnt)
		setAttr ($upJntIkHandle+".poleVector") 0 0 0;
		
		// now make rotation reader (not really an aim loc, but serves the same purpose) -- parent to upJntGetsTwist (top of control jnts that sit on top of upJnt, elbowJnt, wristJnt hierarchy) and orient to $upJnt to read rotation difference
		$aimLocGrp = `group -em -parent $rigGrp -name (abRTRigNamer($baseName+"TwistTarget", $prefix, "grp"))`;
		abRTSnapToPosition($upJntGetsTwist, $aimLocGrp);
		
		$aimLocGrp = abRTGroupFreezeReturnObj($aimLocGrp, true);
		$aimLocGrpFrzGrp = firstParentOf($aimLocGrp);
		
		parentConstraint -mo (firstParentOf($upJnt)) $aimLocGrpFrzGrp;
		pointConstraint $upJnt $aimLocGrp;
		
		$aimLoc = abRTMakeLocatorV2((abRTRigNamer($baseName+"TwistTarget", $prefix, "loc")), $upJntGetsTwist, $aimLocGrp);
		orientConstraint -n (abRTRigNamer($baseName+"TwistReader", $prefix, "orCons")) $upJnt $aimLoc;
		
		setAttr ($aimLoc+".v") $locVis;
		
		$readerSrcObjAtt = $aimLoc+".rx";
	}
	
	
	// make manual rotation control for splits
	if ($readerSrcObjAtt == "")
		$readerSrcObjAtt = $aimLoc+".rx";
	
	if ($twistCtrlBlendObjAtt != "" && $upJntGetsTwist == ""){
		
		$aStr = stringToStringArray($twistCtrlBlendObjAtt, ".");
		if (size($aStr) == 2){
			
			$twistCtrlAttObj = $aStr[0];
			$twistCtrlAtt = $aStr[1];
			
			if (attributeExists($twistCtrlAtt, $twistCtrlAttObj)){
				
				$twistCtrl = abRTMakeWireController("twister_1", 0, {}, 10);
				
				if ($lowerBaseName == "forearm" || $lowerBaseName == "wrist"){
					if ($prefix == "l")
						abRTRotateWire($twistCtrl, {180, 0, 0});
				}
				
				if ($lowerBaseName == "lowleg" || $lowerBaseName == "ankle"){
					if ($prefix == "l")
						abRTRotateWire($twistCtrl, {-90, 0, 0});
					else
						abRTRotateWire($twistCtrl, {90, 0, 0});
				}
				
				$aStr = abRTRename($twistCtrl, (abRTRigNamer($baseName+"Twist", $prefix, "ctrl")));
				$twistCtrl = $aStr[1];
				
				// position the control
				abRTSnapToPosition($upJnt, $twistCtrl);
				$aStr = `pointConstraint $upJnt $dnJnt $twistCtrl`;
				for ($str in $aStr)
					delete $str;
				
				$twistCtrl = abRTParent($twistCtrl, $rigGrp);
				$twistCtrl = abRTGroupFreezeReturnObj($twistCtrl, true);
				$twistCtrlFrzGrp = firstParentOf($twistCtrl);
				
				abRTHideAttr($twistCtrl, {"tx","ty","tz","ry","rz","sx","sy","sz","v"});
				string $indexColorStr = ($prefix == "l") ? "lfCtrlColor" : "rtCtrlColor";
				abRTColorObj($twistCtrl, $indexColorStr, -1);
				
				parentConstraint -mo $upJnt $twistCtrlFrzGrp;
				
				// connect visibility
				string $twistCtrlCond = abRTCreateNode("condition", ($baseName+"ManualRotCtrl"), $prefix, $limbName);
				setAttr ($twistCtrlCond+".operation") 2; // greater than
				connectAttr $twistCtrlBlendObjAtt ($twistCtrlCond+".firstTerm"); 
				setAttr ($twistCtrlCond+".secondTerm") 0;
				setAttr ($twistCtrlCond+".colorIfTrueR") 1;
				setAttr ($twistCtrlCond+".colorIfFalseR") 0;
				
				connectAttr ($twistCtrlCond+".outColorR") ($twistCtrl+".v"); 
				
				// connect to blend with wrist target
				string $existingSrcTarget = $readerSrcObjAtt;
				string $twistCtrlBlnd = abRTCreateNode("blendColors", ($baseName+"ManualRotCtrl"), $prefix, $limbName);
				
				connectAttr $twistCtrlBlendObjAtt ($twistCtrlBlnd+".blender");
				connectAttr ($twistCtrl+".rx") ($twistCtrlBlnd+".color1R");
				connectAttr $existingSrcTarget ($twistCtrlBlnd+".color2R");
				$readerSrcObjAtt = $twistCtrlBlnd+".outputR";
			}
		}
	}
	
	return $readerSrcObjAtt;
	
}


global proc abRTConnectSplitJntsToTwist(string $aSplitJnts[], string $upLimbCtrlJnt, string $dnJnt, string $twistSrcObjAtt, string $baseName, string $limbName, int $rubberHoseLimb, string $firstSplitAttName, string $lastSplitAttName){
	// connects split joints to twist
	// $upLimbCtrlJnt is only passed when setting up an upLeg or upArm.  It's the joint that sits in the same grp as the upLimbSplitCtrlParent joint, which is the parent to the upSplits.  I do it this way so users can still choose to apply twist to the upLimb upJnt, which they wouldn't otherwise be able to do.
	// $rubberHoseLimb indicates whether the limb will be built with rubber hose
	// $firstSplitAttName (if not empty) will be used to name the twist contribution attribute for the first split joint in $aSplitJnts -- used to name upJnt attribute when connecting upLimbs
	// $lastSplitAttName (if not empty) will be used to name the twist contribution attribute for the last split joint in $aSplitJnts -- used to name wrist attribute when connecting forearm
	// if so, might want default twist amounts to be less
	// if not, need to connect the splits to translated when limb is stretched if true, otherwise just connects rx (tx is taken care of when rubber hose limbs are built)
	
	
	string $cAxis, $dnJnt, $tJnt, $txMltDiv, $rxMltDiv, $aRxMltDiv[], $attLabel, $labelPrfx, $aTempSplits[];
	float $jntTx, $dnJntTx, $rxRatio, $txRatio, $aUpSplitRatios[];
	int $i, $counter;
	
	string $aAxis[] = {"X","Y","Z"};
	string $rigSettingsCtrl = abRTGetFromUI("rigSettingsCtrl");
	
	string $prefix = abRTGetObjSide($aSplitJnts[0]);
	string $labelPrfx = ($prefix == "l") ? "LF" : "RT";
	string $lowerBaseName = tolower($baseName);
	
	$dnJntTx = `getAttr ($dnJnt+".tx")`;
	
	int $firstSplitIsUpCtrlJnt = false;
	
	if ($upLimbCtrlJnt != ""){
		// add $upLimbCtrlJnt to the beginning of the splits array
		$firstSplitIsUpCtrlJnt = true;
		$aTempSplits = stringArrayCatenate({$upLimbCtrlJnt}, $aSplitJnts);
		
	}else{
		$aTempSplits = $aSplitJnts;
	}
	
	for ($i=0;$i<size($aTempSplits);$i++){
		
		$cAxis = $aAxis[($i%3)];
		$tJnt = $aTempSplits[$i];
		
		if ($i%3 == 0){
			// create nodes for next round
			$counter++;
			
			if (!$rubberHoseLimb)
				$txMltDiv = abRTCreateNode("multiplyDivide", ($baseName+"SplitTx"+$counter), $prefix, $limbName);
			
			$rxMltDiv = abRTCreateNode("multiplyDivide", ($baseName+"SplitRx"+$counter), $prefix, $limbName);
			
			// save rxMltDiv to later connect to atts on the rigSettings control
			$aRxMltDiv[size($aRxMltDiv)] = $rxMltDiv;
		}
		
		// set up tx first; if $firstSplitIsUpCtrlJnt, set its jntTx and rxRatio to 0;
		if ($i == 0 && $firstSplitIsUpCtrlJnt){
			
			$jntTx = $rxRatio = 0;
		}else{
			
			// use jnt.tx if it's a child of $dnJnt, otherwise (in the case of wrists) we can just set it to 1
			if ($lowerBaseName == "forearm" && nodeType(firstParentOf($tJnt)) != "joint"){
				
				$rxRatio = 1;
			}else{
				$jntTx = `getAttr ($tJnt+".tx")`;
				$rxRatio = $jntTx/$dnJntTx;
			}
		}
		
		// save ratios to later be connected to atts on the rigSettings control
		$aUpSplitRatios[$i] = $rxRatio;
		
		if (!$rubberHoseLimb){
			
			if (!($firstSplitIsUpCtrlJnt && $i == 0)){
				
				// set up tx (except on upLimbCtrlJnt, if it exists)
				$txRatio = $rxRatio;
				
				// connect dnJnt tx to mltDiv input 1 
				connectAttr ($dnJnt+".tx") ($txMltDiv+".input1"+$cAxis);
				setAttr ($txMltDiv+".input2"+$cAxis) $txRatio;
				connectAttr ($txMltDiv+".output"+$cAxis) ($tJnt+".tx");
			}
		}
		
		connectAttr $twistSrcObjAtt ($rxMltDiv+".input1"+$cAxis);
		
		if ($rigSettingsCtrl == "")
			setAttr ($rxMltDiv+".input2"+$cAxis) $rxRatio;
		
		connectAttr ($rxMltDiv+".output"+$cAxis) ($tJnt+".rx");
	}
	
	// add and connect rotate atts to rigSettings control
	if ($rigSettingsCtrl != ""){
		
		if ($lowerBaseName == "forearm")
			$attLabel = "______"+$labelPrfx+"_FOREARM___";
		else if ($lowerBaseName == "uparm")
			$attLabel = "______"+$labelPrfx+"___UPARM___";
		else if ($lowerBaseName == "lowleg")
			$attLabel = "______"+$labelPrfx+"__LOWLEG___";
		else if ($lowerBaseName == "upleg")
			$attLabel = "______"+$labelPrfx+"___UPLEG___";
		else if ($lowerBaseName == "wrist")
			$attLabel = "______"+$labelPrfx+"___WRIST___";
		
		abRTAddSplitAttsToRigSettingsCrv($rigSettingsCtrl, $aUpSplitRatios, $aRxMltDiv, $attLabel, $baseName, $prefix, $limbName, $firstSplitAttName, $lastSplitAttName);
	}
	
}


global proc int abRTJointMirroredBehavior(string $jnt){
	// returns true if the mirror joint of jnt has been mirrored using behavior, false if mirrored with orientation, -1 if it can't find a mirror joint
	
	int $ret = -1;
	float $tol = .001;
	
	string $mJnt = abRTGetMirrorObj($jnt);
	
	if ($mJnt == "")
		return $ret;
	
	// find joint x axis aim direction and compare to its mirror
	// assume joints were mirrored by behavior
	$ret = true;
	
	if ((abRTFindClosestAxisToWorld($jnt, {1, 0, 0})) == (abRTFindClosestAxisToWorld($mJnt, {1, 0, 0}))){
		// do x axes match?
		
		if ((abRTFindClosestAxisToWorld($jnt, {0, 1, 0})) == (abRTFindClosestAxisToWorld($mJnt, {0, 1, 0}))){
			// how about y?
			
			if ((abRTFindClosestAxisToWorld($jnt, {0, 0, 1})) == (abRTFindClosestAxisToWorld($mJnt, {0, 0, 1}))){
				// no way, really?  what about z?
				
				$ret = false;
			}
		}
	}
	
	return $ret;
	
}


global proc abRTFingerRigHelper(string $aFinger[], string $CBLabel, string $baseName, string $handCtrl, string $curlSpreadRollAxes, string $mstrFistAtt, string $mstrSpreadAtt, string $fingerSpreadAmtAtt, string $fingerCurlAtt, string $midCurlAmtAtt, string $tipCurlAmtAtt, string $curlDampener, int $makeIk, string $prefix, string $handGrp, string $limbName){
	
	// takes care of some of the repetitive stuff in finger rigging
	// $aFinger is array of {baseFingerJnt, midFingerJnt, tipFingerJnt}
	// $CBLabel (channelBox label) is locked category name to precede finger channels with (eg. "________THUMB___")
	// $baseName is name of finger (eg. "thumb")
	// $handCtrl is path to ctrlCrv to add attributes
	// $curlSpreadRollAxes is string specifying (in order) the curl, spread and roll axes for the finger in the form of "xyz". (thumb is default "zyx", fingers are "yzx")
	// $rtReverseCurl will reverse the curl axes if the finger is located on the -x side of the z axis (true for fingers, false for thumb)
	// $mstrFistAtt, $mstrSpread, $fingerSpreadAmtAtt, $fingerCurlAtt, $midCurlAtt, $tipCurlAtt, and $curlDampener are respective attributes including control curve ("controlCrv.masterFist") (fingerSpreadAmt (optional) is multiplier for given finger to use with masterSpread) (curlDampener (optional) modifies the amount of masterFist inherited by finger -- used to slow thumb curl)
	// $makeIk will add finger IK controls if true
	// $prefix, $handGrp and $limbName are obvious
	
	
	string $mstrSpread = $handCtrl+".masterSpread";
	string $fkHandVisAtt = $handCtrl+".fkFingerCtrlVis";
	string $curlCtrlVisAtt = $handCtrl+".fingerMasterCtrlVis";
	
	string $prefixStr = ($prefix == "l") ? "lf" : "rt";
	
	string $aRotAxesRef[] = {"rx","ry","rz"};
	string $aAxes[] = {"X","Y","Z"};
	string $aPlsMns3dPlug[] = {"3Dx","3Dy","3Dz"};
	string $aBaseNames[] = {"Base","Mid","Tip"};
	string $aHideFkAtts[] = {"tx","ty","tz","rx","ry","rz","sx","sy","sz","v"};
	string $attName, $plsMns, $curlMultDiv, $curlPlsMns, $totalCurlPlsMns, $rtMltDiv, $rtFKRotFrzMltDiv, $rvSpreadPlsMns, $rvRollPlsMns, $dampMltDiv, $str, $aFkFingerCtrls[], $aStr[];
	
	string $curlAxis = "r"+(substring($curlSpreadRollAxes, 1, 1));
	string $spreadAxis = "r"+(substring($curlSpreadRollAxes, 2, 2));
	string $rollAxis = "r"+(substring($curlSpreadRollAxes, 3, 3));
	
	int $rtReverseCurl = int(abRTGetGlobal("reverseFingerCurl"));
	string $indexColorStr = ($prefix == "l") ? "lfFingerCtrlColor" : "rtFingerCtrlColor";
	
	for ($str in $aHideFkAtts){
		if ($str != $curlAxis) $aStr[size($aStr)] = $str;
	}
	
	$aHideFkAtts = $aStr;
	
	
	// curl
	string $tFingerFkCtrl, $tFingerFkCtrlFrzGrp, $tFingerFkCtrlRotFrzGrp, $aStr[], $fingerMegaCurlMultDiv, $fingerMegaManipRateMultDiv, $curlCtrlRotSpeedAtt, $spreadCtrlRotSpeedAtt, $rollCtrlRotSpeedAtt, $rigSettingsCtrl, $tFingerMegaCtrl, $curlCtrlRotSpeedAttName, $spreadCtrlRotSpeedAttName, $rollCtrlRotSpeedAttName, $curlCtrlLabel, $curlCtrlVisAtt;
	string $midCtrlCurlSpeedAttName, $tipCtrlCurlSpeedAttName, $midCtrlCurlSpeedAtt, $tipCtrlCurlSpeedAtt, $midTipCurlMultDiv, $midTipCurlPlsMns;
	float $flt, $aDefVals[];
	int $i, $k;
	
	for ($i=0;$i<size($aBaseNames);$i++){
		if ($i == size($aFinger)) break;
		
		if ($i == 0){
			
			if (!attributeExists($CBLabel, $handCtrl)) addAttr -ln $CBLabel -at bool -keyable false $handCtrl;
			setAttr -lock true -cb true ($handCtrl+"."+$CBLabel);
			$plsMns = abRTCreateNode("plusMinusAverage", $baseName, $prefix, $limbName);
			
			// curl stuff
			$curlMultDiv = abRTCreateNode("multiplyDivide", ($baseName+"Curl"), $prefix, $limbName);
			$curlPlsMns = abRTCreateNode("plusMinusAverage", ($baseName+"Curl"), $prefix, $limbName); // curl without Fk contribution
			$totalCurlPlsMns = abRTCreateNode("plusMinusAverage", ($baseName+"TotalCurl"), $prefix, $limbName); // add Fk control contribution
			
			// add curl to masterFist
			if ($curlDampener != ""){
				$dampMltDiv = abRTCreateNode("multiplyDivide", ($baseName+"CurlDamp"), $prefix, $limbName);
				connectAttr $mstrFistAtt ($dampMltDiv+".input1X");
				connectAttr $curlDampener ($dampMltDiv+".input2X");
				connectAttr ($dampMltDiv+".outputX") ($curlPlsMns+".input1D[0]");
			}else{
				connectAttr $mstrFistAtt ($curlPlsMns+".input1D[0]");
			}
			
			connectAttr $fingerCurlAtt ($curlPlsMns+".input1D[1]");
			
			// make connections
			setAttr ($curlMultDiv+".input1X") 1;
			connectAttr $midCurlAmtAtt ($curlMultDiv+".input1Y");
			connectAttr $tipCurlAmtAtt ($curlMultDiv+".input1Z");
			connectAttr ($curlPlsMns+".output1D") ($curlMultDiv+".input2X");
			connectAttr ($curlPlsMns+".output1D") ($curlMultDiv+".input2Y");
			connectAttr ($curlPlsMns+".output1D") ($curlMultDiv+".input2Z");
			
			// reverse curl if fingerJnts are on the right side and $rtReverCurl is true
			if ($prefix == "r" && $rtReverseCurl && $baseName != "thumb"){
				
				$rtMltDiv= abRTCreateNode("multiplyDivide", "indexRev", $prefix, $limbName);
				setAttr ($rtMltDiv+".input1") -1 -1 -1;
				$rtFKRotFrzMltDiv = abRTCreateNode("multiplyDivide", "fkRotFrzGrpRev", $prefix, $limbName);
				setAttr ($rtFKRotFrzMltDiv+".input1") -1 -1 -1;
				
			}else{
				
				$rtMltDiv = $rtFKRotFrzMltDiv = "";
			}
			
			
			// add master finger controls (one to a finger)
			$tFingerMegaCtrl = abRTMakeWireController("circle", 1, {}, 4);
			$aStr = abRTRename($tFingerMegaCtrl, (abRTRigNamer("master"+(capitalizeString($baseName)), $prefix, "ctrl")));
			$tFingerMegaCtrl = $aStr[1];
			addAttr -ln "midCurl" -at double -min -10 -max 10 -dv 1 -keyable true $tFingerMegaCtrl;
			addAttr -ln "tipCurl" -at double -min -10 -max 10 -dv 1.4 -keyable true $tFingerMegaCtrl;
			
			// color it
			abRTColorObj($tFingerMegaCtrl, $indexColorStr, -1);
			
			// connect vis
			connectAttr $curlCtrlVisAtt ($tFingerMegaCtrl+".v");
			
			// put in handGrp
			$tFingerMegaCtrl = abRTParent($tFingerMegaCtrl, $handGrp);
			
			// place it at tip
			$aStr = `listRelatives -c -type joint $aFinger[2]`;
			abRTSnapToPosition($aStr[0], $tFingerMegaCtrl);
			
			
			// need to rotate into proper orientation if on right side
			// align control using an aim constraint (otherwise axes will be out of whack if hand is rotated)
			int $curlIntAxis, $spreadIntAxis, $rollIntAxis;
			
			$curlIntAxis = abRTGetPosInStrArray($curlAxis, $aRotAxesRef);
			$spreadIntAxis = abRTGetPosInStrArray($spreadAxis, $aRotAxesRef);
			$rollIntAxis = abRTGetPosInStrArray($rollAxis, $aRotAxesRef);
			
			float $aAimAxis[] = {0,0,0};
			float $aWorldUpAxis[] = {0,0,0};
			
			$aAimAxis[$rollIntAxis] = -1;
			$aWorldUpAxis[$spreadIntAxis] = 1;
			
			if ($prefix == "r"){
				$aAimAxis[$rollIntAxis] *= -1;
				$aWorldUpAxis[$spreadIntAxis] *= -1;
			}
			
			if ($baseName == "thumb")
				$aWorldUpAxis[$spreadIntAxis] *= -1;
			
			string $aAimCons[] = `aimConstraint -offset 0 0 0 -weight 1 -aimVector $aAimAxis[0] $aAimAxis[1] $aAimAxis[2] -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector $aWorldUpAxis[0] $aWorldUpAxis[1] $aWorldUpAxis[2] -worldUpObject $aFinger[2] $aFinger[2] $tFingerMegaCtrl`;
			for ($str in $aAimCons)
				delete $str;
			
			
			// now freeze it
			$tFingerMegaCtrl = abRTGroupFreezeReturnObj($tFingerMegaCtrl, 1);
			string $tFingerMegaCtrlFrzGrp = firstParentOf($tFingerMegaCtrl);
			
			// move frzGrp
			float $flt = `getAttr ($aFinger[1]+".tx")`;
			$flt += `getAttr ($aFinger[2]+".tx")`;
			$flt *= 1.2;
			move -r -os -wd $flt 0 0 $tFingerMegaCtrlFrzGrp;
			
			
			// parentConstrain frzGrp
			parentConstraint -mo $handCtrl $tFingerMegaCtrlFrzGrp;
			
			string $rigSettingsCtrl = abRTGetFromUI("rigSettingsCtrl");
			
			if ($prefix == "l")
				$aDefVals = {-15.0, 8.0, 1.0, -3.0, -4.0};
			else
				$aDefVals = {15.0, 8.0, 1.0, -3.0, -4.0};
			
			// start connecting it
			if ($rigSettingsCtrl != ""){
				
				$curlCtrlLabel = toupper($prefixStr)+"_MASTER_FINGER_CTRLS";
				$curlCtrlRotSpeedAttName = $prefixStr+"CurlCtrlSpeed";
				$spreadCtrlRotSpeedAttName = $prefixStr+"SpreadCtrlSpeed";
				$rollCtrlRotSpeedAttName = $prefixStr+"RollCtrlSpeed";
				$midCtrlCurlSpeedAttName = $prefixStr+"MidCurlCtrlSpeed";
				$tipCtrlCurlSpeedAttName = $prefixStr+"TipCurlCtrlSpeed";
				
				$curlCtrlRotSpeedAtt = $rigSettingsCtrl+"."+$curlCtrlRotSpeedAttName;
				$spreadCtrlRotSpeedAtt = $rigSettingsCtrl+"."+$spreadCtrlRotSpeedAttName;
				$rollCtrlRotSpeedAtt = $rigSettingsCtrl+"."+$rollCtrlRotSpeedAttName;
				$midCtrlCurlSpeedAtt = $rigSettingsCtrl+"."+$midCtrlCurlSpeedAttName;
				$tipCtrlCurlSpeedAtt = $rigSettingsCtrl+"."+$tipCtrlCurlSpeedAttName;
				
				if (!attributeExists($curlCtrlRotSpeedAttName, $rigSettingsCtrl)){
					
					addAttr -ln $curlCtrlLabel -at bool -dv 0 -keyable true $rigSettingsCtrl;
					setAttr  -lock true ($rigSettingsCtrl+"."+$curlCtrlLabel);
					
					addAttr -ln $curlCtrlRotSpeedAttName -at double -min -50 -max 50 -dv $aDefVals[0] -keyable true $rigSettingsCtrl;
					addAttr -ln $spreadCtrlRotSpeedAttName -at double -min -50 -max 50 -dv $aDefVals[1] -keyable true $rigSettingsCtrl;
					addAttr -ln $rollCtrlRotSpeedAttName -at double -min -50 -max 50 -dv $aDefVals[2] -keyable true $rigSettingsCtrl;
					addAttr -ln $midCtrlCurlSpeedAttName -at double -min -50 -max 50 -dv $aDefVals[3] -keyable true $rigSettingsCtrl;
					addAttr -ln $tipCtrlCurlSpeedAttName -at double -min -50 -max 50 -dv $aDefVals[4] -keyable true $rigSettingsCtrl;
					
					// record atts to charVars
					abRTSaveToCharVars({($rigSettingsCtrl+"."+$curlCtrlLabel)}, $limbName);
					abRTSaveToCharVars({$curlCtrlRotSpeedAtt}, $limbName);
					abRTSaveToCharVars({$spreadCtrlRotSpeedAtt}, $limbName);
					abRTSaveToCharVars({$rollCtrlRotSpeedAtt}, $limbName);
					abRTSaveToCharVars({$midCtrlCurlSpeedAtt}, $limbName);
					abRTSaveToCharVars({$tipCtrlCurlSpeedAtt}, $limbName);
				}
			}else{
				
				addAttr -ln "rotSpeed" -at double -min -50 -max 50 -dv $aDefVals[0] -keyable true $tFingerMegaCtrl;
				addAttr -ln "spreadSpeed" -at double -min -50 -max 50 -dv $aDefVals[1] -keyable true $tFingerMegaCtrl;
				addAttr -ln "rollSpeed" -at double -min -50 -max 50 -dv $aDefVals[2] -keyable true $tFingerMegaCtrl;
				addAttr -ln "midCurlSpeed" -at double -min -50 -max 50 -dv $aDefVals[3] -keyable true $tFingerMegaCtrl;
				addAttr -ln "tipCurlSpeed" -at double -min -50 -max 50 -dv $aDefVals[4] -keyable true $tFingerMegaCtrl;
				
				$curlCtrlRotSpeedAtt = $tFingerMegaCtrl+".rotSpeed";
				$spreadCtrlRotSpeedAtt = $tFingerMegaCtrl+".spreadSpeed";
				$rollCtrlRotSpeedAtt = $tFingerMegaCtrl+".rollSpeed";
				$midCtrlCurlSpeedAtt = $tFingerMegaCtrl+".midCurlSpeed";
				$tipCtrlCurlSpeedAtt = $tFingerMegaCtrl+".tipCurlSpeed";
			}
			
			$fingerMegaManipRateMultDiv = abRTCreateNode("multiplyDivide", ($baseName+"Curl_mega"), $prefix, $limbName);
			$fingerMegaCurlMultDiv = abRTCreateNode("multiplyDivide", ($baseName+"Curl_mega"), $prefix, $limbName);
			
			connectAttr ($tFingerMegaCtrl+".tx") ($fingerMegaManipRateMultDiv+".input1X");
			connectAttr ($tFingerMegaCtrl+".tz") ($fingerMegaManipRateMultDiv+".input1Y");
			connectAttr ($tFingerMegaCtrl+".rx") ($fingerMegaManipRateMultDiv+".input1Z");
			connectAttr $curlCtrlRotSpeedAtt ($fingerMegaManipRateMultDiv+".input2X");
			connectAttr $spreadCtrlRotSpeedAtt ($fingerMegaManipRateMultDiv+".input2Y");
			connectAttr $rollCtrlRotSpeedAtt ($fingerMegaManipRateMultDiv+".input2Z");
			
			// mega ctrl .ty is connected to mid and tip curl amounts (the rate of which can be changed in the rig settings ctrl)
			$midTipCurlMultDiv = abRTCreateNode("multiplyDivide", ($baseName+"MidTipCurl"), $prefix, $limbName);
			$midTipCurlPlsMns = abRTCreateNode("plusMinusAverage", ($baseName+"MidTipCurl"), $prefix, $limbName);
			
			connectAttr ($tFingerMegaCtrl+".ty") ($midTipCurlMultDiv+".input1X");
			connectAttr ($tFingerMegaCtrl+".ty") ($midTipCurlMultDiv+".input1Y");
			connectAttr $midCtrlCurlSpeedAtt ($midTipCurlMultDiv+".input2X");
			connectAttr $tipCtrlCurlSpeedAtt ($midTipCurlMultDiv+".input2Y");
			
			connectAttr ($tFingerMegaCtrl+".midCurl") ($midTipCurlPlsMns+".input2D[0].input2Dx");
			connectAttr ($tFingerMegaCtrl+".tipCurl") ($midTipCurlPlsMns+".input2D[0].input2Dy");
			connectAttr ($midTipCurlMultDiv+".outputX") ($midTipCurlPlsMns+".input2D[1].input2Dx");
			connectAttr ($midTipCurlMultDiv+".outputY") ($midTipCurlPlsMns+".input2D[1].input2Dy");
			
			setAttr ($fingerMegaCurlMultDiv+".input1X") 1;
			connectAttr ($midTipCurlPlsMns+".output2D.output2Dx") ($fingerMegaCurlMultDiv+".input1Y");
			connectAttr ($midTipCurlPlsMns+".output2D.output2Dy") ($fingerMegaCurlMultDiv+".input1Z");
			
			connectAttr ($fingerMegaManipRateMultDiv+".outputX") ($fingerMegaCurlMultDiv+".input2X");
			connectAttr ($fingerMegaManipRateMultDiv+".outputX") ($fingerMegaCurlMultDiv+".input2Y");
			connectAttr ($fingerMegaManipRateMultDiv+".outputX") ($fingerMegaCurlMultDiv+".input2Z");
			
			// hide unused atts
			abRTHideAttr($tFingerMegaCtrl, {"ry","rz","sx","sy","sz","v"});
			
		}
		
		$attName = $baseName+$aBaseNames[$i];
		if (!attributeExists($attName, $handCtrl)) addAttr -ln $attName -at double  -min -90 -max 150 -dv 0 -keyable true $handCtrl;
		
		connectAttr ($curlMultDiv+".output"+$aAxes[$i]) ($plsMns+".input3D[0].input"+$aPlsMns3dPlug[$i]);
		connectAttr ($handCtrl+"."+$attName) ($plsMns+".input3D[1].input"+$aPlsMns3dPlug[$i]);
		connectAttr ($fingerMegaCurlMultDiv+".output"+$aAxes[$i]) ($plsMns+".input3D[2].input"+$aPlsMns3dPlug[$i]);
		
		// add fk finger control
		$tFingerFkCtrl = abRTMakeWireController("flattenedCircle", 0, {}, 5);
		
		// rotate flattened circle on thumbs
		if ($baseName == "thumb")
			abRTRotateWire($tFingerFkCtrl, {90, 0, 0});
		
		$aStr = abRTRename($tFingerFkCtrl, (abRTRigNamer($baseName+capitalizeString($aBaseNames[$i])+"_fk", $prefix, "ctrl")));
		$tFingerFkCtrl = $aStr[1];
		connectAttr $fkHandVisAtt ($tFingerFkCtrl+".v");
		
		$tFingerFkCtrl = abRTParent($tFingerFkCtrl, $handGrp);
		
		// color it
		abRTColorObj($tFingerFkCtrl, $indexColorStr, -1);
		
		// place it
		abRTSnapToPosition($aFinger[$i], $tFingerFkCtrl);
		
		// freeze it twice
		$tFingerFkCtrl = abRTGroupFreezeReturnObj($tFingerFkCtrl, 1);
		$tFingerFkCtrl = abRTGroupFreezeReturnObj($tFingerFkCtrl, 1);
		$tFingerFkCtrlRotFrzGrp = firstParentOf($tFingerFkCtrl);
		$tFingerFkCtrlFrzGrp = firstParentOf($tFingerFkCtrlRotFrzGrp);
		
		// save for later set up of fk/ik visibility
		$aFkFingerCtrls[$i] = $tFingerFkCtrl;
		
		// hide and add atts
		if ($i == 0){
			// first finger has all rotations enabled
			abRTHideAttr($tFingerFkCtrl, {"tx","ty","tz","sx","sy","sz","v"});
		}else{
			abRTHideAttr($tFingerFkCtrl, $aHideFkAtts);
		}
		
		// constrain top frzGrp to previous joint in hierarchy
		parentConstraint -mo (firstParentOf($aFinger[$i])) $tFingerFkCtrlFrzGrp;
		
		// combine curl and Fk curl
		connectAttr ($plsMns+".output"+$aPlsMns3dPlug[$i]) ($totalCurlPlsMns+".input3D[0].input"+$aPlsMns3dPlug[$i]);
		connectAttr ($tFingerFkCtrl+"."+$curlAxis) ($totalCurlPlsMns+".input3D[1].input"+$aPlsMns3dPlug[$i]);
		
		
		// plug in other rotations to $tFingerFkCtrlRotFrzGrp and connect fingerFrzRotGrp to incoming rotation
		if ($prefix == "r" && $rtReverseCurl && $baseName != "thumb"){
			connectAttr ($totalCurlPlsMns+".output"+$aPlsMns3dPlug[$i]) ($rtMltDiv+".input2"+$aAxes[$i]);
			connectAttr ($rtMltDiv+".output"+$aAxes[$i]) ($aFinger[$i]+"."+$curlAxis);
			
			connectAttr ($plsMns+".output"+$aPlsMns3dPlug[$i]) ($rtFKRotFrzMltDiv+".input2"+$aAxes[$i]);
			connectAttr ($rtFKRotFrzMltDiv+".output"+$aAxes[$i]) ($tFingerFkCtrlRotFrzGrp+"."+$curlAxis);
			
		}else{
			connectAttr ($totalCurlPlsMns+".output"+$aPlsMns3dPlug[$i]) ($aFinger[$i]+"."+$curlAxis);
			connectAttr ($plsMns+".output"+$aPlsMns3dPlug[$i]) ($tFingerFkCtrlRotFrzGrp+"."+$curlAxis);
		}
		
	}
	
	string $spreadPlsMns, $spreadMultDiv, $rollPlsMns;
	string $fingerSpread = $baseName+"Spread";
	string $fingerRoll = $baseName+"Roll";
	string $fingerIk = $baseName+"IK";
	
	// spread
	
	if (!attributeExists($fingerSpread, $handCtrl)) addAttr -ln $fingerSpread -at double  -min -50 -max 50 -dv 0 -keyable true $handCtrl;
	
	$spreadMultDiv = abRTCreateNode("multiplyDivide", ($baseName+"Spread"), $prefix, $limbName);
	$spreadPlsMns = abRTCreateNode("plusMinusAverage", ($baseName+"Spread"), $prefix, $limbName);
	
	// connect atts
	
	// mltDiv
	connectAttr $mstrSpread ($spreadMultDiv+".input1X");
	if ($fingerSpreadAmtAtt != ""){
		connectAttr $fingerSpreadAmtAtt ($spreadMultDiv+".input2X");
	}else{
		// in this case (where there's no spineCtrl with spread att) use default based on five fingered hand
		
		string $aDefaultSpreadValuesTable[] = {"thumb","index","middle","ring","pinky"};
		float $spreadScalar;
		
		int $fingerInd = abRTGetPosInStrArray($baseName, $aDefaultSpreadValuesTable);
		if ($fingerInd != -1) $spreadScalar = -1*(float($fingerInd)/2 - 1);
		else $spreadScalar = 1;
		
		setAttr ($spreadMultDiv+".input2X") $spreadScalar; // connect spreadVal here
		
	}
	
	// fk finger ctrl connection stuff
	string $firstFingerFkCtrlRotFrzGrp = firstParentOf($aFkFingerCtrls[0]);
	string $totalSpreadPlsMns = abRTCreateNode("plusMinusAverage", ($baseName+"TotalSpread"), $prefix, $limbName);
	string $totalRollPlsMns = abRTCreateNode("plusMinusAverage", ($baseName+"TotalRoll"), $prefix, $limbName);
	
	
	// plsMns
	connectAttr ($handCtrl+"."+$fingerSpread) ($spreadPlsMns+".input1D[0]");
	connectAttr ($spreadMultDiv+".outputX") ($spreadPlsMns+".input1D[1]");
	connectAttr ($fingerMegaManipRateMultDiv+".outputY") ($spreadPlsMns+".input1D[2]");
	
	
	if ((!$rtReverseCurl && $baseName == "thumb") || ($rtReverseCurl && $baseName == "thumb" && $prefix == "l")){
		
		connectAttr ($spreadPlsMns+".output1D") ($totalSpreadPlsMns+".input1D[0]");
		connectAttr ($aFkFingerCtrls[0]+"."+$spreadAxis) ($totalSpreadPlsMns+".input1D[1]");
		
		connectAttr ($totalSpreadPlsMns+".output1D") ($aFinger[0]+"."+$spreadAxis);
		
		// rotate fk ctrl frzGrp with incoming rotations
		connectAttr ($spreadPlsMns+".output1D") ($firstFingerFkCtrlRotFrzGrp+"."+$spreadAxis);
	}else{
		
		$rvSpreadPlsMns = abRTCreateNode("plusMinusAverage", ($fingerSpread+"Rev"), $prefix, $limbName);
		
		setAttr ($rvSpreadPlsMns+".input1D[0]") 0;
		setAttr ($rvSpreadPlsMns+".operation") 2;
		
		connectAttr ($spreadPlsMns+".output1D") ($rvSpreadPlsMns+".input1D[1]");
		connectAttr ($rvSpreadPlsMns+".output1D") ($totalSpreadPlsMns+".input1D[0]");
		connectAttr ($aFkFingerCtrls[0]+"."+$spreadAxis) ($totalSpreadPlsMns+".input1D[1]");
		connectAttr ($totalSpreadPlsMns+".output1D") ($aFinger[0]+"."+$spreadAxis);
		
		// rotate fk ctrl frzGrp with incoming rotations
		connectAttr ($rvSpreadPlsMns+".output1D") ($firstFingerFkCtrlRotFrzGrp+"."+$spreadAxis);;
	}
	
	// roll
	
	$rollPlsMns = abRTCreateNode("plusMinusAverage", ($baseName+"Roll"), $prefix, $limbName);
	
	if (!attributeExists($fingerRoll, $handCtrl)) addAttr -ln $fingerRoll -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
	
	connectAttr ($handCtrl+"."+$fingerRoll) ($rollPlsMns+".input1D[0]");
	connectAttr ($fingerMegaManipRateMultDiv+".outputZ") ($rollPlsMns+".input1D[1]");
	
	if (!$rtReverseCurl || ($rtReverseCurl && $prefix == "l")){
		
		connectAttr ($rollPlsMns+".output1D") ($totalRollPlsMns+".input1D[0]");
		connectAttr ($aFkFingerCtrls[0]+"."+$rollAxis) ($totalRollPlsMns+".input1D[1]");
		connectAttr ($totalRollPlsMns+".output1D") ($aFinger[0]+"."+$rollAxis);
		
		// rotate fk ctrl frzGrp with incoming rotations
		connectAttr ($rollPlsMns+".output1D") ($firstFingerFkCtrlRotFrzGrp+"."+$rollAxis);
		
	}else{
		$rvRollPlsMns = abRTCreateNode("plusMinusAverage", ($fingerRoll+"Rev"), $prefix, $limbName);
		setAttr ($rvRollPlsMns+".input1D[0]") 0;
		setAttr ($rvRollPlsMns+".operation") 2;
		
		connectAttr ($rollPlsMns+".output1D") ($rvRollPlsMns+".input1D[1]");
		connectAttr ($rvRollPlsMns+".output1D") ($totalRollPlsMns+".input1D[0]");
		connectAttr ($aFkFingerCtrls[0]+"."+$rollAxis) ($totalRollPlsMns+".input1D[1]");
		connectAttr ($totalRollPlsMns+".output1D") ($aFinger[0]+"."+$rollAxis);
		
		// rotate fk ctrl frzGrp with incoming rotations
		connectAttr ($rvRollPlsMns+".output1D") ($firstFingerFkCtrlRotFrzGrp+"."+$rollAxis);
	}
	
	// add ik
	if ($makeIk){
		if (!attributeExists($fingerIk, $handCtrl)) addAttr -ln $fingerIk -at double  -min 0 -max 1 -dv 0 -keyable true $handCtrl;
		abRTMakeFingerIK($aFinger[0], $aFinger[1], $aFinger[2], $baseName, ($handCtrl+"."+$fingerIk), $handGrp, $limbName, $indexColorStr);
		
		// set up ik/fk vis
		string $fkVisCond = abRTCreateNode("condition", ($baseName+"FkVis"), $prefix, $limbName);
		setAttr ($fkVisCond+".operation") 4; // less than
		connectAttr -f ($handCtrl+"."+$fingerIk) ($fkVisCond+".firstTerm"); 
		setAttr ($fkVisCond+".secondTerm") 1;
		connectAttr -f $fkHandVisAtt ($fkVisCond+".colorIfTrueR"); 
		setAttr ($fkVisCond+".colorIfFalseR") 0;
		
		for ($str in $aFkFingerCtrls) connectAttr -f ($fkVisCond+".outColorR") ($str+".v");
		
	}
	
}


global proc int abRTRigHand(string $handCtrl, string $thumbJnt, string $indexJnt, string $middleJnt, string $ringJnt, string $pinkyJnt, string $pinkyCup, string $ringCup){
	// rigs a hand -- returns 1 on success, -1 on failure
	
	int $ret = -1;
	
	if ($handCtrl == "" || $thumbJnt == "" || $indexJnt == "") return $ret;
	
	abRTSetScale($indexJnt);
	
	int $i;
	string $aThumb[], $aIndex[], $aMiddle[], $aRing[], $aPinky[], $handGrp;
	string $prefix = abRTGetObjSide($handCtrl);
	string $limbName = ($prefix == "l") ? "leftHand" : "rightHand";
	int $makeIk = int(abRTGetGlobal("createIkFingerCtrls"));
	int $rtReverseCurl = int(abRTGetGlobal("reverseFingerCurl"));
	string $charName = abRTGetGlobal("name");
	
	
	// create hand rig group (if necessary) -- ik is responsible for the only hand related transforms
	$handGrp = (abRTRigNamer("hand", $prefix, "rigGrp")); // hand group -- all hand rig transforms created from here out will be placed in this group
	if (!`objExists ((abRTRigRootFolder())+"|"+$handGrp)`){
		$handGrp = `group -em -name $handGrp`;
		$handGrp = abRTParent($handGrp, abRTRigRootFolder());
	}else{
		warning "This part of the character has already been rigged.  You must remove the current rig before you can continue.";
		return $ret;
	}
	
	abRTConnectToMasterScale($handGrp);
	
	string $aAllHandJnts[]; // used to save all hand Jnts to charVars
	
	if ($thumbJnt != "") $aThumb = abRTGetHierarchy($thumbJnt, "", true); $aAllHandJnts = stringArrayCatenate($aAllHandJnts, $aThumb);
	if ($indexJnt != "") $aIndex = abRTGetHierarchy($indexJnt, "", true); $aAllHandJnts = stringArrayCatenate($aAllHandJnts, $aIndex);
	if ($middleJnt != "") $aMiddle = abRTGetHierarchy($middleJnt, "", true); $aAllHandJnts = stringArrayCatenate($aAllHandJnts, $aMiddle);
	if ($ringJnt != "") $aRing = abRTGetHierarchy($ringJnt, "", true); $aAllHandJnts = stringArrayCatenate($aAllHandJnts, $aRing);
	if ($pinkyJnt != "") $aPinky = abRTGetHierarchy($pinkyJnt, "", true); $aAllHandJnts = stringArrayCatenate($aAllHandJnts, $aPinky);
	
	// finish and clean up $aAllHandJnts
	$aAllHandJnts = stringArrayCatenate($aAllHandJnts, {$pinkyCup, $ringCup});
	$aAllHandJnts = stringArrayRemove({""}, $aAllHandJnts);
	
	// save to charVars
	abRTSaveRigGrpToCharVars($handGrp, $limbName);
	abRTSaveToCharVars($aAllHandJnts, $limbName);
	
	// want to capture newly added $handCtrl atts, so first must capture list of current custom $handCtrl atts
	string $aOrigAtts[] = `listAttr -userDefined $handCtrl`;
	string $aOtherNewAtts[]; // used to capture new spread atts on spine control curve
	string $tAtt;
	string $longPrefix = ($prefix == "l") ? "left" : "right";
	string $cupRotStr = "r"+(abRTGetGlobal("fingerCupAxis")); // rx, ry, or rz (from fingerCupAxis global)
	
	// header for finger controls
	if (!attributeExists("fingerAtts", $handCtrl)) addAttr -ln "fingerAtts" -at bool -keyable false $handCtrl;
	setAttr -lock true -cb true ($handCtrl+".fingerAtts");
	
	// add finger control vis atts
	if (!attributeExists("fkFingerCtrlVis", $handCtrl)) addAttr -ln "fkFingerCtrlVis" -at bool  -dv 1 -keyable true $handCtrl;
	if (!attributeExists("fingerMasterCtrlVis", $handCtrl)) addAttr -ln "fingerMasterCtrlVis" -at bool -dv 1 -keyable true $handCtrl;
	
	if ($pinkyCup != ""){
		
		string $ringCupMltDiv;
		
		if (!attributeExists("masterCup", $handCtrl)) addAttr -ln "masterCup" -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
		
		if (!$rtReverseCurl || $rtReverseCurl && $prefix == "l"){
			connectAttr ($handCtrl+".masterCup") ($pinkyCup+"."+$cupRotStr);
		}else{
			$ringCupMltDiv = abRTCreateNode("multiplyDivide", "pinkyRingCup", $prefix, $limbName);
			
			setAttr ($ringCupMltDiv+".input1Y") -1;
			connectAttr ($handCtrl+".masterCup") ($ringCupMltDiv+".input2Y");
			connectAttr ($ringCupMltDiv+".outputY") ($pinkyCup+"."+$cupRotStr);
			
		}
		
		if ($ringCup != ""){
			
			if ($ringCupMltDiv == "") $ringCupMltDiv = abRTCreateNode("multiplyDivide", "pinkyRingCup", $prefix, $limbName);
			
			if (!$rtReverseCurl || $rtReverseCurl && $prefix == "l") setAttr ($ringCupMltDiv+".input1X") .5;
			else setAttr ($ringCupMltDiv+".input1X") -.5;
			
			connectAttr ($handCtrl+".masterCup") ($ringCupMltDiv+".input2X");
			connectAttr ($ringCupMltDiv+".outputX") ($ringCup+"."+$cupRotStr);
			
		}
	}
	
	// add master fist att
	if (!attributeExists("masterFist", $handCtrl)) addAttr -ln "masterFist" -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
	if (!attributeExists("masterSpread", $handCtrl)) addAttr -ln "masterSpread" -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
	
	// add thumb dampener att (modifies masterFist effect on thumb)
	if (!attributeExists("thumbFistDamp", $handCtrl)) addAttr -ln "thumbFistDamp" -at double  -min -100 -max 100 -dv .3 -keyable true $handCtrl;
	
	// add finger curl atts (instead of master fist)
	if (!attributeExists("midCurlAmt", $handCtrl)) addAttr -ln "midCurlAmt" -at double  -min -100 -max 100 -dv 1 -keyable true $handCtrl;
	if (!attributeExists("tipCurlAmt", $handCtrl)) addAttr -ln "tipCurlAmt" -at double  -min -100 -max 100 -dv 1.4 -keyable true $handCtrl;
	
	string $thumbCurlAtt, $indexCurlAtt, $middleCurlAtt, $ringCurlAtt, $pinkyCurlAtt;
	string $mstrFistAtt = ($handCtrl+".masterFist");
	string $mstrSpreadAtt = ($handCtrl+".masterSpread");
	string $thumbCurlDampAtt = ($handCtrl+".thumbFistDamp");
	string $midCurlAmtAtt = ($handCtrl+".midCurlAmt");
	string $tipCurlAmtAtt = ($handCtrl+".tipCurlAmt");
	
	
	if (!attributeExists("________CURL___", $handCtrl)) addAttr -ln "________CURL___" -at bool -keyable false $handCtrl;
	setAttr -lock true -cb true ($handCtrl+".________CURL___");
	
	// set up finger curl
	if (size($aThumb) > 0){
		if (!attributeExists("thumbCurl", $handCtrl)) addAttr -ln "thumbCurl" -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
		$thumbCurlAtt = ($handCtrl+".thumbCurl");
	}
	if (size($aIndex) > 0){
		if (!attributeExists("indexCurl", $handCtrl)) addAttr -ln "indexCurl" -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
		$indexCurlAtt = ($handCtrl+".indexCurl");
	}
	if (size($aMiddle) > 0){
		if (!attributeExists("middleCurl", $handCtrl)) addAttr -ln "middleCurl" -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
		$middleCurlAtt = ($handCtrl+".middleCurl");
	}
	if (size($aRing) > 0){
		if (!attributeExists("ringCurl", $handCtrl)) addAttr -ln "ringCurl" -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
		$ringCurlAtt = ($handCtrl+".ringCurl");
	}
	if (size($aPinky) > 0){
		if (!attributeExists("pinkyCurl", $handCtrl)) addAttr -ln "pinkyCurl" -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
		$pinkyCurlAtt = ($handCtrl+".pinkyCurl");
	}
	
	
	// add masterSpread individual finger amounts to rigSettingsCtrl
	
	float $aSpreadAmts[] = {1.0, .5, 0.0, -.5, -1.0}; // array to hold spread amounts by finger index (starting with the thumb)
	string $rigSettingsCtrl = abRTGetFromUI("rigSettingsCtrl");
	string $aSpreadAmtAtts[];  // contains attributes ("transform.att") for fingers spread amounts (starting with the thumb)
	
	if ($rigSettingsCtrl != ""){
		
		int $totNumFingers = 0;
		
		// count fingers
		if ($thumbJnt != "") $totNumFingers ++;
		if ($indexJnt != "") $totNumFingers ++;
		if ($middleJnt != "") $totNumFingers ++;
		if ($ringJnt != "") $totNumFingers ++;
		if ($pinkyJnt != "") $totNumFingers ++;
		
		float $spreadDelta = 2/float($totNumFingers-1);
		float $cSpread = 1;
		
		// add attributes
		//string $attLabel = ($prefix == "l") ? "________LF_SPREAD___" : "________RT_SPREAD___";
		string $attLabel = ($prefix == "l") ? "_LF_MASTER_SPREAD___" : "_RT_MASTER_SPREAD___";
		if (!attributeExists($attLabel, $rigSettingsCtrl)){
			addAttr -ln $attLabel -at bool -dv 0 -keyable true $rigSettingsCtrl;
			setAttr  -lock true ($rigSettingsCtrl+"."+$attLabel);
			
			// record atts to charVars
			$aOtherNewAtts[size($aOtherNewAtts)] = ($rigSettingsCtrl+"."+$attLabel);
		}
		
		if ($thumbJnt != ""){
			$aSpreadAmts[0] = $cSpread;
			$cSpread-=$spreadDelta;
			$tAtt = $longPrefix+"ThumbAmt";
			if (!attributeExists($tAtt, $rigSettingsCtrl)) addAttr -ln $tAtt -at double  -min -100 -max 100 -dv $aSpreadAmts[0] -keyable true $rigSettingsCtrl;
			$aSpreadAmtAtts[0] = ($rigSettingsCtrl+"."+$tAtt);
			$aOtherNewAtts[size($aOtherNewAtts)] = $aSpreadAmtAtts[0];
		}
		if ($indexJnt != ""){
			$aSpreadAmts[1] = $cSpread;
			$cSpread-=$spreadDelta;
			$tAtt = $longPrefix+"IndexAmt";
			if (!attributeExists($tAtt, $rigSettingsCtrl)) addAttr -ln $tAtt -at double  -min -100 -max 100 -dv $aSpreadAmts[1] -keyable true $rigSettingsCtrl;
			$aSpreadAmtAtts[1] = ($rigSettingsCtrl+"."+$tAtt);
			$aOtherNewAtts[size($aOtherNewAtts)] = $aSpreadAmtAtts[1];
		}
		if ($middleJnt != ""){
			$aSpreadAmts[2] = $cSpread;
			$cSpread-=$spreadDelta;
			$tAtt = $longPrefix+"MiddleAmt";
			if (!attributeExists($tAtt, $rigSettingsCtrl)) addAttr -ln $tAtt -at double  -min -100 -max 100 -dv $aSpreadAmts[2] -keyable true $rigSettingsCtrl;
			$aSpreadAmtAtts[2] = ($rigSettingsCtrl+"."+$tAtt);
			$aOtherNewAtts[size($aOtherNewAtts)] = $aSpreadAmtAtts[2];
		}
		if ($ringJnt != ""){
			$aSpreadAmts[3] = $cSpread;
			$cSpread-=$spreadDelta;
			$tAtt = $longPrefix+"RingAmt";
			if (!attributeExists($tAtt, $rigSettingsCtrl)) addAttr -ln $tAtt -at double  -min -100 -max 100 -dv $aSpreadAmts[3] -keyable true $rigSettingsCtrl;
			$aSpreadAmtAtts[3] = ($rigSettingsCtrl+"."+$tAtt);
			$aOtherNewAtts[size($aOtherNewAtts)] = $aSpreadAmtAtts[3];
		}
		if ($pinkyJnt != ""){
			$aSpreadAmts[4] = $cSpread;
			$cSpread-=$spreadDelta;
			$tAtt = $longPrefix+"PinkyAmt";
			if (!attributeExists($tAtt, $rigSettingsCtrl)) addAttr -ln $tAtt -at double  -min -100 -max 100 -dv $aSpreadAmts[4] -keyable true $rigSettingsCtrl;
			$aSpreadAmtAtts[4] = ($rigSettingsCtrl+"."+$tAtt);
			$aOtherNewAtts[size($aOtherNewAtts)] = $aSpreadAmtAtts[4];
		}
		
	}
	
	string $thumbCSRAxes =  abRTGetGlobal("thumbCurlSpreadRoll");
	string $fingerCSRAxes =  abRTGetGlobal("fingerCurlSpreadRoll");
	
	// rig fingers
	if (size($aThumb) > 0){
		abRTFingerRigHelper($aThumb, "________THUMB___", "thumb", $handCtrl, $thumbCSRAxes, $mstrFistAtt, $mstrSpreadAtt, $aSpreadAmtAtts[0], $thumbCurlAtt, $midCurlAmtAtt, $tipCurlAmtAtt, $thumbCurlDampAtt, $makeIk, $prefix, $handGrp, $limbName);
	}
	if (size($aIndex) > 0){
		abRTFingerRigHelper($aIndex, "________INDEX___", "index", $handCtrl, $fingerCSRAxes, $mstrFistAtt, $mstrSpreadAtt, $aSpreadAmtAtts[1], $indexCurlAtt, $midCurlAmtAtt, $tipCurlAmtAtt, "", $makeIk, $prefix, $handGrp, $limbName);
	}
	if (size($aMiddle) > 0){
		abRTFingerRigHelper($aMiddle, "________MIDDLE___", "middle", $handCtrl, $fingerCSRAxes, $mstrFistAtt, $mstrSpreadAtt, $aSpreadAmtAtts[2], $middleCurlAtt, $midCurlAmtAtt, $tipCurlAmtAtt, "", $makeIk, $prefix, $handGrp, $limbName);
	}
	if (size($aRing) > 0){
		abRTFingerRigHelper($aRing, "________RING___", "ring", $handCtrl, $fingerCSRAxes, $mstrFistAtt, $mstrSpreadAtt, $aSpreadAmtAtts[3], $ringCurlAtt, $midCurlAmtAtt, $tipCurlAmtAtt, "", $makeIk, $prefix, $handGrp, $limbName);
	}
	if (size($aPinky) > 0){
		abRTFingerRigHelper($aPinky, "________PINKY___", "pinky", $handCtrl, $fingerCSRAxes, $mstrFistAtt, $mstrSpreadAtt, $aSpreadAmtAtts[4], $pinkyCurlAtt, $midCurlAmtAtt, $tipCurlAmtAtt, "", $makeIk, $prefix, $handGrp, $limbName);
	}
	
	select -clear;
	
	// compare orig with current handCtrl atts to get an array of newly added atts
	string $aNewAtts[] = `listAttr -userDefined $handCtrl`;
	$aNewAtts = stringArrayRemove($aOrigAtts, $aNewAtts);
	
	// add handCtrl to atts ("handCtrl.att")
	for ($i=0;$i<size($aNewAtts);$i++) $aNewAtts[$i] = $handCtrl+"."+$aNewAtts[$i];
	
	// add new other atts to new atts
	$aNewAtts = stringArrayCatenate($aNewAtts, $aOtherNewAtts);
	
	// save new atts to charVars
	abRTSaveToCharVars($aNewAtts, $limbName);
	
	// save some stuff to skeleton
	abRTSetRootJntAtt("createIkFingerCtrls", string($makeIk), $charName);
	abRTSetRootJntAtt("reverseFingerCurl", string($rtReverseCurl), $charName);
	abRTSetRootJntAtt("fingerCurlSpreadRoll", $fingerCSRAxes, $charName);
	abRTSetRootJntAtt("thumbCurlSpreadRoll", $thumbCSRAxes, $charName);
	
	// done
	$ret = 1;
	return $ret;
}


global proc int abRTRigLeg(string $upLegJnt, string $heelLoc){
	// rigs a leg -- returns 1 on success, -1 on failure
	
	int $ret = -1;
	
	if ($upLegJnt == "" || $heelLoc == "") return $ret;
	
	float $xForm[], $xForm2[], $float, $float2;
	string $aRel[], $aStr[], $globalKey, $name, $aNames[], $str, $jnt;
	string $kneeJnt, $ankleJnt, $ballJnt, $toeJnt;
	string $aCtrlCurves[]; // all ctrl curves put in this array will be colored according to the side of the body
	string $aIkCtrls[]; // objects in this array will have visibility switched according to ikFk switch on footCtrl
	string $aFkCtrls[]; // objects in this array will have visibility switched according to ikFk switch on footCtrl
	string $aLegJntKeyNames[] = {"upLeg","knee","ankle","ball","toe"};
	int $i;
	
	abRTSetScale($upLegJnt);
	
	int $premiumVersion = int(abRTGetGlobal("premiumVersion"));
	string $rootJnt = abRTGetRootFromJoint($upLegJnt);
	string $charName = abRTGetGlobal("name");
	
	if ($rootJnt == ""){
		warning "Can't find the skeleton's root joint.";
		return -1;
	}
	
	int $upLegSplitNum = int(abRTGetGlobal("upLegSplitNum"));
	int $lowLegSplitNum = int(abRTGetGlobal("lowLegSplitNum"));
	
	// get joints
	string $aAllLegJnts[];
	string $aLegJnts[];
	
	// find knee
	$kneeJnt = abRTGetDownJoint($upLegJnt);
	
	if ($kneeJnt == ""){
		warning "Unable to locate knee joint.  Make sure your knee joint is the only child of your upLeg joint with children of its own.";
		return $ret;
	}
	
	// find ankle
	$ankleJnt = abRTGetDownJoint($kneeJnt);
	if ($ankleJnt == ""){
		warning "Unable to locate ankle joint.  Make sure your ankle joint is the only child of your knee joint with children of its own.";
		return $ret;
	}
	
	// get ball
	$ballJnt = abRTGetDownJoint($ankleJnt);
	if ($ballJnt == ""){
		warning "Unable to locate ball joint.  Make sure your ball joint is the only child of your ankle joint.";
		return $ret;
	}
	
	// get toe
	$toeJnt = abRTGetDownJoint($ballJnt);
	if ($toeJnt == ""){
		warning "Unable to locate toe joint.  Make sure your toe joint is the only child of your ball joint.";
		return $ret;
	}
	
	$aLegJnts = {$upLegJnt, $kneeJnt, $ankleJnt, $ballJnt, $toeJnt};
	$aAllLegJnts = $aLegJnts;
	
	
	// make sure there are no old style splits
	string $aOldSplits[];
	
	$aOldSplits = abRTGetSplits($upLegJnt, true);
	$aOldSplits = stringArrayCatenate($aOldSplits, abRTGetSplits($upLegJnt, false));
	$aOldSplits = stringArrayCatenate($aOldSplits, abRTGetSplits($kneeJnt, true));
	$aOldSplits = stringArrayCatenate($aOldSplits, abRTGetSplits($kneeJnt, false));
	
	if (size($aOldSplits) > 0){
		if ($premiumVersion){
			$str = `confirmDialog -title "Confirm" -message "This character's leg and split joints must be updated before it can be rigged.  You can use the included skeleton update tool." -button "Ok" -button "Run Skeleton Updater" -defaultButton "Ok"`;
			
			if ($str == "Run Skeleton Updater"){
				if (exists("abRTUpdateSkeletonSplitsJointsUI"))
					abRTUpdateSkeletonSplitsJointsUI();
			}
		}else{
			$str = `confirmDialog -title "Confirm" -message "This character's leg and split joints must be updated before it can be rigged.  The Advanced version comes with an update tool that makes this a little bit easier.\n\nJust sayin'." -button "Ok" -defaultButton "Ok"`;
		}
		
		return $ret;
	}
	
	string $hipJnt = firstParentOf($upLegJnt);
	string $prefix = abRTGetObjSide($upLegJnt);
	string $limbName = ($prefix == "l") ? "leftLeg" : "rightLeg";
	
	string $rootCtrl = abRTGetFromUI("rootCtrl");
	int $mirroredBehavior = abRTJointMirroredBehavior($kneeJnt);
	
	// create leg rig group
	string $legGrp = (abRTRigNamer("leg", $prefix, "rigGrp")); // leg group -- all leg rig transforms created from here out will be placed in this group
	if (!`objExists ((abRTRigRootFolder())+"|"+$legGrp)`){
		$legGrp = `group -em -name $legGrp`;
		$legGrp = abRTParent($legGrp, abRTRigRootFolder());
	}else{
		warning "This part of the character has already been rigged.  You must remove the current rig before you can continue.";
		return $ret;
	}
	
	abRTConnectToMasterScale($legGrp);
	
	// save legGrp to charVars
	abRTSaveRigGrpToCharVars($legGrp, $limbName);
	//abRTSaveToCharVars($aAllLegJnts, $limbName);
	
	string $revFootGrp = `group -em -name (abRTRigNamer("reverseFoot", $prefix, "rigGrp"))`;
	$revFootGrp = abRTParent($revFootGrp, $legGrp);
	
	
	// make fk leg
	string $fkLegGrp = `group -em -name ((abRTRigNamer("legFK", $prefix, "Grp"))) -p $legGrp`;
	
	if ($hipJnt != ""){
		select -r $hipJnt $fkLegGrp;
	}else{
		select -r $upLegJnt $fkLegGrp;
	}
	
	abRTPointOrient(1);
	select -clear;
	
	clear($aNames);
	for ($globalKey in $aLegJntKeyNames) $aNames[size($aNames)] = abRTRigNamer($globalKey, $prefix, "fkJnt");
	$aStr = abRTDuplicateJointHierarchy($aLegJnts, $aNames, $fkLegGrp);
	
	if ($hipJnt != "") parentConstraint -mo $hipJnt $fkLegGrp;
	
	
	// add fk controls
	string $cogCtrl = abRTGetFromUI("cogCtrl");
	
	$aStr = abRTAddFkControls({$aStr[0],$aStr[1],$aStr[2],$aStr[3]}, $aLegJntKeyNames, {0}, $hipJnt, $cogCtrl, "sphere", $legGrp, $limbName);
	
	
	string $aFkJnts[];
	for ($i=0;$i<size($aStr);$i+=2){
		$aFkJnts[size($aFkJnts)] = $aStr[$i];
		$aFkCtrls[size($aFkCtrls)] = $aStr[$i+1];
	}
	
	// limit knee to bend axis
	float $kneeVector[] = abRTFindClosestAxisToWorldRetVector($kneeJnt, {1.0,0.0,0.0});
	$aStr = {"rx","ry","rz"};
	for ($i=0;$i<size($kneeVector);$i++){
		if ($kneeVector[$i] > .1)
			stringArrayRemoveAtIndex($i, $aStr);
	}
	abRTHideAttr($aFkCtrls[1], $aStr);
	
	
	// color it
	for ($jnt in $aFkJnts) abRTColorObj($jnt, "fkJntColor", -1);
	
	// color them
	$aCtrlCurves = stringArrayCatenate($aCtrlCurves,$aFkCtrls);
	
	// set rotation order
	setAttr ($aFkCtrls[2]+".rotateOrder") 3; // xzy
	setAttr ($aFkCtrls[3]+".rotateOrder") 3; // xzy
	
	// fk done
	
	
	// make ik leg
	string $ikLegGrp = `group -em -name ((abRTRigNamer("legIK", $prefix, "Grp"))) -p $legGrp`;
	
	if ($hipJnt != ""){
		select -r $hipJnt $ikLegGrp;
	}else{
		select -r $upLegJnt $ikLegGrp;
	}
	
	abRTPointOrient(1);
	select -clear;
	
	$aKeyNames = {"upLeg","knee","ankle"};
	clear($aNames);
	for ($globalKey in $aKeyNames) $aNames[size($aNames)] = abRTRigNamer($globalKey, $prefix, "ikJnt");
	string $aIkJnts[] = abRTDuplicateJointHierarchy({$upLegJnt,$kneeJnt,$ankleJnt}, $aNames, $ikLegGrp);
	
	if ($hipJnt != "") parentConstraint -mo $hipJnt $ikLegGrp;
	
	
	// color it 
	for ($jnt in $aIkJnts) abRTColorObj($jnt, "ikJntColor", -1);
	
	// make heel loc
	string $tLoc = abRTMakeLocator("abRigLegHeelTemp_loc");
	abRTSnapToPosition($heelLoc, $tLoc);
	
	
	// create ik control curve
	
	// first need to find out where to position it
	int $footIKCtrlAtAnkle = int(abRTGetGlobal("footIKCtrlAtAnkle"));
	abRTSetRootJntAtt("footIKCtrlAtAnkle", string($footIKCtrlAtAnkle), $charName);
	
	// make the control curve
	string $ikCtrlCrv = abRTMakeWireController("diamond", 1, {}, 10);
	abRTSnapToPosition($tLoc, $ikCtrlCrv);
	
	if ($footIKCtrlAtAnkle){
		$aStr = `pointConstraint $ankleJnt $ikCtrlCrv`;
		for ($str in $aStr)
			delete $aStr;
	}
	
	$ikCtrlCrv = abRTParent($ikCtrlCrv, $legGrp);
	$aStr = abRTRename($ikCtrlCrv, (abRTRigNamer("heel", $prefix, "ikCtrl")));
	$ikCtrlCrv = $aStr[1];
	
	// rotate order
	setAttr ($ikCtrlCrv+".rotateOrder") 3; // xzy
	
	abRTMoveWireRelativeToPivot($ikCtrlCrv, 0, .5, -1, false);
	
	// using freezeGrp instead of freezeTransforms because want to keep ikCtrl local rotations aligned to the ankle if it's not aligned with z axis
	$ikCtrlCrv = abRTGroupFreezeReturnObj($ikCtrlCrv, true);
	
	if ($prefix == "l") abRTSetUITxtFld("lfLegIkCtrl", $ikCtrlCrv);
	else abRTSetUITxtFld("rtLegIkCtrl", $ikCtrlCrv);
	
	// hide undesired attributes
	abRTHideAttr($ikCtrlCrv, {"sx","sy","sz","v"});
	
	// color it (later)
	$aCtrlCurves[size($aCtrlCurves)] = $ikCtrlCrv;
	
	// set up its visibility (later
	$aIkCtrls[size($aIkCtrls)] = $ikCtrlCrv;
	
	
	// expose rotate order on controls
	setAttr -lock false -channelBox true ($ikCtrlCrv+".rotateOrder");
	
	
	// make reverse foot rig
	$aKeyNames = {"heel","toe","ball","ankle"};
	clear($aNames);
	for ($globalKey in $aKeyNames) $aNames[size($aNames)] = abRTRigNamer($globalKey, $prefix, "rvRigJnt");
	
	string $aRevFootJnts[] = abRTDuplicateJointHierarchy({$tLoc,$toeJnt,$ballJnt,$ankleJnt}, $aNames, $revFootGrp);
	parentConstraint -mo $ikCtrlCrv $revFootGrp;
	
	delete $tLoc;
	
	for ($jnt in $aRevFootJnts) abRTColorObj($jnt, "ikJntColor", -1);
	
	// make toe heel joints
	// first joint is parent to ball toe rig -- keeps the joint orient close to that of the fk rig ball which causes less grief with flipping
	string $aIkHeelToeJntsParent[] = abRTDuplicateJointHierarchy({$ballJnt}, {(abRTRigNamer("ballToePar", $prefix, "ikJnt"))}, $aRevFootJnts[1]);
	string $aIkHeelToeJnts[]  = abRTDuplicateJointHierarchy({$ballJnt,$toeJnt}, {(abRTRigNamer("ball", $prefix, "ikJnt")),(abRTRigNamer("toe", $prefix, "ikJnt"))}, $aIkHeelToeJntsParent[0]);
	
	for ($jnt in $aIkHeelToeJnts) abRTColorObj($jnt, "ikJntColor", -1);
	
	// create leg ikHandle
	string $ikLegHandle = abRTMakeIkHandle($aIkJnts[0], $aIkJnts[2], abRTRigNamer("leg", $prefix, "ikHndl"), $aRevFootJnts[3], $legGrp);
	
	// add attributes to ik control
	
	// leg twist
	addAttr -ln "legTwist" -at double  -min -180 -max 180 -dv 0 -keyable true $ikCtrlCrv;
	connectAttr ($ikCtrlCrv+".legTwist") ($ikLegHandle+".twist");
	
	addAttr -ln "footRoll" -at double  -min -180 -max 180 -dv 0 -keyable true $ikCtrlCrv;
	addAttr -ln "footBreak" -at double  -min -180 -max 180 -dv 40 -keyable true $ikCtrlCrv;
	addAttr -ln "ballRaise" -at double  -min -180 -max 180 -dv 0 -keyable true $ikCtrlCrv;
	addAttr -ln "toeRaise" -at double  -min -180 -max 180 -dv 0 -keyable true $ikCtrlCrv;
	addAttr -ln "toeRoll" -at double  -min -180 -max 180 -dv 0 -keyable true $ikCtrlCrv;
	addAttr -ln "toeTwist" -at double  -min -180 -max 180 -dv 0 -keyable true $ikCtrlCrv;
	addAttr -ln "ballTwist" -at double  -min -180 -max 180 -dv 0 -keyable true $ikCtrlCrv;
	addAttr -ln "heelTwist" -at double  -min -180 -max 180 -dv 0 -keyable true $ikCtrlCrv;
	
	// connect toe to toeRoll
	connectAttr -f ($ikCtrlCrv+".toeRoll") ($aIkHeelToeJnts[0]+".rz"); // toe roll
	
	// connect toe to toeTwist
	connectAttr -f ($ikCtrlCrv+".toeTwist") ($aRevFootJnts[1]+".ry"); // toe twist
	
	// connect toe to ballTwist
	connectAttr -f ($ikCtrlCrv+".ballTwist") ($aRevFootJnts[2]+".ry"); // ball twist
	connectAttr -f ($ikCtrlCrv+".ballTwist") ($aIkHeelToeJnts[0]+".ry");
	
	// connect rev heel to heelTwist
	connectAttr ($ikCtrlCrv+".heelTwist") ($aRevFootJnts[0]+".ry");
	
	// connect heel to footRoll
	string $heelPlsMns = abRTCreateNode("plusMinusAverage", "heel", $prefix, $limbName);
	string $heelClmp = abRTCreateNode("clamp", "heel", $prefix, $limbName);
	
	setAttr ($heelClmp+".minR") -50;
	connectAttr ($ikCtrlCrv+".footRoll") ($heelClmp+".inputR");
	setAttr ($heelPlsMns+".input1D[0]") 0;
	setAttr ($heelPlsMns+".operation") 2;
	connectAttr ($heelClmp+".outputR") ($heelPlsMns+".input1D[1]");
	connectAttr ($heelPlsMns+".output1D") ($aRevFootJnts[0]+".rz");
	
	// connect rev ball jnt to footRoll and footBreak
	string $ballClamp = abRTCreateNode("clamp", "ball", $prefix, $limbName);
	string $ballPlsMns = abRTCreateNode("plusMinusAverage", "ball", $prefix, $limbName);
	
	connectAttr ($ikCtrlCrv+".footRoll") ($ballClamp+".inputR");
	connectAttr ($ikCtrlCrv+".footBreak") ($ballClamp+".maxR");
	connectAttr ($ballClamp+".outputR") ($ballPlsMns+".input1D[0]");
	connectAttr ($ikCtrlCrv+".ballRaise") ($ballPlsMns+".input1D[1]");
	connectAttr ($ballPlsMns+".output1D") ($aRevFootJnts[2]+".rz");
	
	// connect rev toe jnt to footRoll and footBreak
	string $toePlsMns = abRTCreateNode("plusMinusAverage", "toe", $prefix, $limbName);
	string $toePlsMns2 = abRTCreateNode("plusMinusAverage", "toe2", $prefix, $limbName);
	string $toeClamp = abRTCreateNode("clamp", "toe", $prefix, $limbName);
	
	connectAttr ($ikCtrlCrv+".footRoll") ($toePlsMns+".input1D[0]");
	connectAttr ($ikCtrlCrv+".footBreak") ($toePlsMns+".input1D[1]");
	setAttr ($toePlsMns+".operation") 2;
	connectAttr ($toePlsMns+".output1D") ($toeClamp+".inputR");
	setAttr ($toeClamp+".maxR") 90;
	
	connectAttr ($toeClamp+".outputR") ($toePlsMns2+".input1D[0]");
	connectAttr ($ikCtrlCrv+".toeRaise") ($toePlsMns2+".input1D[1]");
	
	connectAttr ($toePlsMns2+".output1D") ($aRevFootJnts[1]+".rx");
	
	// ik done
	
	
	// create foot control curve (attached to bottom of foot)
	string $footCtrlCrv = abRTMakeWireController("square", 1, {}, 13);
	
	$xForm = `xform -q -ws -t $toeJnt`;
	$xForm2 = `xform -q -ws -t $aRevFootJnts[0]`; // heel joint
	
	setAttr ($footCtrlCrv+".tx") ($xForm[0] + ($xForm2[0] - $xForm[0])/2);
	setAttr ($footCtrlCrv+".ty") 0;
	setAttr ($footCtrlCrv+".tz") ($xForm2[2] + (($xForm[2] - $xForm2[2])/2)*.8);
	
	$footCtrlCrv = abRTParent($footCtrlCrv, $legGrp);
	$aStr = abRTRename($footCtrlCrv, (abRTRigNamer("foot", $prefix, "ctrl")));
	$footCtrlCrv = $aStr[1];
	
	parentConstraint -mo $ankleJnt $footCtrlCrv;
	
	// hide undesired attributes
	abRTHideAttr($footCtrlCrv, {"tx","ty","tz","rx","ry","rz","sx","sy","sz","v"});
	
	// color it (later)
	$aCtrlCurves[size($aCtrlCurves)] = $footCtrlCrv;
	
	// add attributes
	addAttr -ln "ikFkBlend" -at double -min 0 -max 1 -dv 1 -keyable true $footCtrlCrv;
	
	addAttr -ln "ikVis" -at bool -keyable true $footCtrlCrv;
	setAttr ($footCtrlCrv+".ikVis") 0;
	connectAttr ($footCtrlCrv+".ikVis") ($aRevFootJnts[0]+".v");
	connectAttr ($footCtrlCrv+".ikVis") ($aIkJnts[0]+".v");
	
	addAttr -ln "fkVis" -at bool -keyable true $footCtrlCrv;
	setAttr ($footCtrlCrv+".fkVis") 0;
	connectAttr ($footCtrlCrv+".fkVis") ($aFkJnts[0]+".v");
	
	// foot ctrl done
	
	// create pv control
	$aStr = abRTMakePvControl($aIkJnts, $ikLegHandle, $kneeJnt, 5, "knee", $legGrp);
	string $pvCtrl = $aStr[0];
	string $pvCtrlGrp = $aStr[2];
	$aIkCtrls[size($aIkCtrls)] = $pvCtrlGrp; // add to ik vis nodes
	
	// pv vis controls on ik leg ctrl
	addAttr -ln "pvControl" -at bool -keyable true $ikCtrlCrv;
	setAttr ($ikCtrlCrv+".pvControl") 1;
	
	// $aStr[0] - pv control, $aStr[1] - pv constraint, $aStr[3] - pv line, $aStr[4] - lineJointLoc
	connectAttr -f ($ikCtrlCrv+".pvControl") ($pvCtrl+".v");
	connectAttr ($ikCtrlCrv+".pvControl") ($aStr[1]+"."+(abRTStripPath($pvCtrl))+"W0");
	connectAttr -f ($ikCtrlCrv+".pvControl") ($aStr[3]+".v");
	connectAttr -f ($ikCtrlCrv+".pvControl") ($aStr[4]+".v");
	
	// create blend for pv control (between pv constraint and 0 0 0)
	string $tCon[];
	$tCon[size($tCon)] = `connectionInfo -sourceFromDestination ($ikLegHandle+".poleVectorX")`;
	$tCon[size($tCon)] = `connectionInfo -sourceFromDestination ($ikLegHandle+".poleVectorY")`;
	$tCon[size($tCon)] = `connectionInfo -sourceFromDestination ($ikLegHandle+".poleVectorZ")`;
	
	string $pvCtrlBlnd = abRTCreateNode("blendColors", "legPvCtrl", $prefix, $limbName);
	
	connectAttr ($ikCtrlCrv+".pvControl") ($pvCtrlBlnd+".blender");
	
	connectAttr $tCon[0] ($pvCtrlBlnd+".color1R");
	connectAttr $tCon[1] ($pvCtrlBlnd+".color1G");
	connectAttr $tCon[2] ($pvCtrlBlnd+".color1B");
	
	setAttr ($pvCtrlBlnd+".color2") 0 0 0;
	
	connectAttr -f ($pvCtrlBlnd+".outputR") ($ikLegHandle+".poleVectorX");
	connectAttr -f ($pvCtrlBlnd+".outputG") ($ikLegHandle+".poleVectorY");
	connectAttr -f ($pvCtrlBlnd+".outputB") ($ikLegHandle+".poleVectorZ");
	
	// color it (later)
	$aCtrlCurves[size($aCtrlCurves)] = $pvCtrl;
	
	// pv done (except for snap, which will be plugged into knee after orient stuff)
	
	
	// add stretch
	abRTMakeIKStretchy($aLegJnts, $aIkJnts, $aFkJnts, $ikCtrlCrv, $footCtrlCrv, $aRevFootJnts[3], $legGrp, $limbName);
	
	setAttr ($ikCtrlCrv+".stretchyLeg") 1;
	
	// tx constrain leg to fk and ik
	string $legTxBlnd = abRTCreateNode("blendColors", "legTrans", $prefix, $limbName);
	
	connectAttr ($footCtrlCrv+".ikFkBlend") ($legTxBlnd+".blender");
	connectAttr ($aIkJnts[1]+".tx") ($legTxBlnd+".color1R");
	connectAttr ($aIkJnts[2]+".tx") ($legTxBlnd+".color1G");
	connectAttr ($aFkJnts[1]+".tx") ($legTxBlnd+".color2R");
	connectAttr ($aFkJnts[2]+".tx") ($legTxBlnd+".color2G");
	
	// connect upLeg and knee jnts tx (including splits) to $legTxBlnd outputs
	float $kneeTx = `getAttr ($aIkJnts[1]+".tx")`;
	float $ankleTx = `getAttr ($aIkJnts[2]+".tx")`;
	
	connectAttr ($legTxBlnd+".outputR") ($kneeJnt+".tx");
	connectAttr ($legTxBlnd+".outputG") ($ankleJnt+".tx");
	
	
	// orient constrain leg to fk and ik
	// constrain ik
	clear $aNames;
	for ($globalKey in $aLegJntKeyNames) $aNames[size($aNames)] = abRTRigNamer($globalKey, $prefix, "ikFkCons");
	string $aIkJntCons[] = abRTMassOrientConstraint({$aIkJnts[0],$aIkJnts[1],$aRevFootJnts[3],$aIkHeelToeJnts[0],$aIkHeelToeJnts[1]}, $aLegJnts, $aNames);
	
	// constrain fk (using same $aNames because these are the same constraints)
	string $aFkJntCons[] = abRTMassOrientConstraint({$aFkJnts[0],$aFkJnts[1],$aFkJnts[2],$aFkJnts[3]}, $aLegJnts, $aNames);
	
	// hook up ik/fk switch
	string $ikFkReverse = abRTCreateNode("reverse", "legIkFkSwitch", $prefix, $limbName);
	
	connectAttr -f ($footCtrlCrv+".ikFkBlend") ($ikFkReverse+".inputX");
	
	for ($str in $aIkJntCons) connectAttr -f ($footCtrlCrv+".ikFkBlend") $str;
	for ($str in $aFkJntCons) connectAttr -f ($ikFkReverse+".outputX") $str;
	
	
	
	// Set up leg twist
	string $aData[] = abRTMakeLimbWeightAndCtrlJnts({$upLegJnt, $kneeJnt, $ankleJnt}, {"upLeg", "knee", "ankle"}, $upLegSplitNum, $lowLegSplitNum, $prefix, $rootJnt, "leg", $legGrp, true);
	
	if (size($aData) == 0){
		// failure -- undo
		evalDeferred("undo");
		return $ret;
	}
	
	// parse data
	
	// $aData[0] - skelGroup  
	// $aData[1] - upWtJnt & midWtJnt & dnWtJnt
	// $aData[2] - upWtSplit1 & upWtSplit2
	// $aData[3] - dnWtSplit1 & dnWtSplit2
	// $aData[4] - upCtrlJnt & midCtrlJnt & dnCtrlJnt
	// $aData[5] - upCtrlSplit1 & upCtrlSplit2
	// $aData[6] - dnCtrlSplit1 & dnCtrlSplit2
	// $aData[7] - upSplitCtrlParentJnt
	// $aData[8] - dnSplitCtrlParentJnt
	
	string $aUpLegWtSplits[], $aLowLegWtSplits[], $aUpLegCtrlSplits[], $aLowLegCtrlSplits[], $rhStretchCurve, $upSplitCtrlParentJnt, $dnSplitCtrlParentJnt;
	
	string $skelLegWtJntGrp = $aData[0];
	
	$aStr = stringToStringArray($aData[1], "&");
	string $upLegWtJnt = $aStr[0]; 
	string $kneeWtJnt = $aStr[1]; 
	string $ankleWtJnt = $aStr[2]; 
	
	if ($aData[2] != ""){
		$aStr = stringToStringArray($aData[2], "&");
		for ($str in $aStr)
			if ($str != "")	$aUpLegWtSplits[size($aUpLegWtSplits)] = $str;
	}
	
	if ($aData[3] != ""){
		$aStr = stringToStringArray($aData[3], "&");
		for ($str in $aStr)
			if ($str != "")	$aLowLegWtSplits[size($aLowLegWtSplits)] = $str;
	}
	
	$aStr = stringToStringArray($aData[4], "&");
	string $upLegCtrlJnt = $aStr[0]; 
	string $kneeCtrlJnt = $aStr[1]; 
	string $ankleCtrlJnt = $aStr[2]; 
	
	if ($aData[5] != ""){
		$aStr = stringToStringArray($aData[5], "&");
		for ($str in $aStr)
			if ($str != "")	$aUpLegCtrlSplits[size($aUpLegCtrlSplits)] = $str;
	}
	
	if ($aData[6] != ""){
		$aStr = stringToStringArray($aData[6], "&");
		for ($str in $aStr)
			if ($str != "")	$aLowLegCtrlSplits[size($aLowLegCtrlSplits)] = $str;
	}
	
	if ($aData[7] != ""){
		$upSplitCtrlParentJnt = $aData[7];
		setAttr ($upSplitCtrlParentJnt+".v") 0;
	}
	
	if ($aData[8] != ""){
		$dnSplitCtrlParentJnt = $aData[8];
		setAttr ($dnSplitCtrlParentJnt+".v") 0;
	}
	
	// data parsed
	
	float $aimVector[], $upVector[], $worldUpVector[], $getVector[];
	string $upLegTwistObjAtt, $lowLegTwistObjAtt, $lastSplitAttName, $firstSplitAttName;;
	
	
	// get rubber leg info from UI
	int $rubberHoseLegs = int(abRTGetGlobal("rubberHoseLegs"));
	int $upLegRHCtrlNum = int(abRTGetGlobal("rhUpLegCtrlNum"));
	int $lowLegRHCtrlNum = int(abRTGetGlobal("rhLowLegCtrlNum"));
	int $createdRHLeg = false;
	
	if ($upLegSplitNum > 0){
		
		$firstSplitAttName = "upLeg";
		
		$upLegTwistObjAtt = abRTMakeSplitJointTargetLoc($upSplitCtrlParentJnt, $upLegJnt, $kneeJnt, "", {}, {}, {}, "upLeg", "", "", $limbName, $legGrp);
		abRTConnectSplitJntsToTwist($aUpLegCtrlSplits, $upLegCtrlJnt, $ankleJnt, $upLegTwistObjAtt, "upLeg", $limbName, $rubberHoseLegs, $firstSplitAttName, "");
	}
	
	if ($lowLegSplitNum > 0){
		
		// now lowLeg which uses an aim constraint to determine twist
		$aimVector = {1.0,0.0,0.0};
		$getVector = {1.0,0.0,0.0}; // vector to get
		
		if ($prefix == "r" && $mirroredBehavior){
			$aimVector[0] = -1.0;
			$getVector[0] = -1.0;
		}
		
		$upVector = abRTFindClosestAxisToWorldRetVector($kneeJnt, $getVector);
		$worldUpVector = abRTFindClosestAxisToWorldRetVector($ankleJnt, $getVector);
		
		addAttr -ln "useAimTwist" -at double -dv 1 -min 0 -max 1 -keyable true $footCtrlCrv;
		addAttr -ln "lowLegTwistCtrl" -at double -dv 0 -min 0 -max 1 -keyable true $footCtrlCrv;
		
		$lowLegTwistObjAtt = abRTMakeSplitJointTargetLoc("", $kneeJnt, $ankleJnt, $ankleJnt, $aimVector, $upVector, $worldUpVector, "lowLeg", $footCtrlCrv+".lowLegTwistCtrl", $footCtrlCrv+".useAimTwist", $limbName, $legGrp);
		abRTConnectSplitJntsToTwist($aLowLegCtrlSplits, "", $ankleJnt, $lowLegTwistObjAtt, "lowLeg", $limbName, $rubberHoseLegs, "", "");
	}
	
	// constrain ankleCtrlJnt (and by extension, ankleWtJnt)
	parentConstraint $ankleJnt $ankleCtrlJnt;
	
	// bind wtJnts to ctrlJnts and clean up
	string $aLegCtrlJnts[], $aLegWtJnts[];
	
	$aLegCtrlJnts = stringArrayCatenate({$upLegCtrlJnt, $kneeCtrlJnt, $ankleCtrlJnt}, $aUpLegCtrlSplits);
	$aLegWtJnts = stringArrayCatenate({$upLegWtJnt, $kneeWtJnt, $ankleWtJnt}, $aUpLegWtSplits);
	
	$aLegCtrlJnts = stringArrayCatenate($aLegCtrlJnts, $aLowLegCtrlSplits);
	$aLegWtJnts = stringArrayCatenate($aLegWtJnts, $aLowLegWtSplits);
	
	for ($i=0;$i<size($aLegCtrlJnts);$i++){
		parentConstraint $aLegCtrlJnts[$i] $aLegWtJnts[$i];
		setAttr ($aLegCtrlJnts[$i]+".v") 0;
	}
	
	// add to armJnts which will later be saved to charVars (important for removing the rig cleanly)
	$aAllLegJnts = stringArrayCatenate($aAllLegJnts, $aLegCtrlJnts);
	$aAllLegJnts = stringArrayCatenate($aAllLegJnts, $aLegWtJnts);
	
	// done with twist
	
	// attach visibility
	string $ikVisCond = abRTCreateNode("condition", "legIkVis", $prefix, $limbName);
	string $fkVisCond = abRTCreateNode("condition", "legFkVis", $prefix, $limbName);
	
	connectAttr -f ($footCtrlCrv+".ikFkBlend") ($ikVisCond+".firstTerm"); 
	setAttr ($ikVisCond+".operation") 2;
	setAttr ($ikVisCond+".colorIfTrueR") 1;
	setAttr ($ikVisCond+".colorIfFalseR") 0;
	
	connectAttr -f ($footCtrlCrv+".ikFkBlend") ($fkVisCond+".firstTerm"); 
	setAttr ($fkVisCond+".operation") 4;
	setAttr ($fkVisCond+".secondTerm") 1;
	setAttr ($fkVisCond+".colorIfTrueR") 1;
	setAttr ($fkVisCond+".colorIfFalseR") 0;
	
	for ($str in $aIkCtrls) connectAttr -f ($ikVisCond+".outColorR") ($str+".v"); 
	for ($str in $aFkCtrls) connectAttr -f ($fkVisCond+".outColorR") ($str+".v"); 
	
	// color the curves in $aCtrlCurves
	string $colorIndexKey = ($prefix == "l") ? "lfCtrlColor" : "rtCtrlColor"; // get global colorIndex for this side of the body
	for ($str in $aCtrlCurves) abRTColorObj($str, $colorIndexKey, -1);
	
	// add pv snap
	addAttr -ln "snapKnee" -at double -min 0 -max 1 -dv 0 -keyable true $pvCtrl;
	
	// make distanceDim -- upLeg to pvCtrl
	$aStr = abRTMakeDistanceDim({abRTRigNamer("upLegPvCtrl",$prefix,"dist"),abRTRigNamer("upLegPvCtrl",$prefix,"dist_sp"),abRTRigNamer("upLegPvCtrl",$prefix,"dist_ep")}, $aIkJnts[0], $pvCtrl, $legGrp);
	
	string $upLegPvDistShape = $aStr[3];
	pointConstraint $aIkJnts[0] $aStr[1];
	pointConstraint $pvCtrl $aStr[2];
	
	// make distanceDim -- pvCtrl to ikCtrl
	$aStr = abRTMakeDistanceDim({abRTRigNamer("legPvIkCtrl",$prefix,"dist"),abRTRigNamer("legPvIkCtrl",$prefix,"dist_sp"),abRTRigNamer("legPvIkCtrl",$prefix,"dist_ep")}, $pvCtrl, $aRevFootJnts[3], $legGrp);
	
	string $pvIkCtrlDistShape = $aStr[3];
	pointConstraint $pvCtrl $aStr[1];
	pointConstraint $aRevFootJnts[3] $aStr[2];
	
	// divide distance values by the masterScale on the rootCtrl
	string $upLegPvDistAtt, $pvIkCtrlDistAtt;
	
	if ($rootCtrl == ""){
		$upLegPvDistAtt = $upLegPvDistShape+".distance";
		$pvIkCtrlDistAtt = $pvIkCtrlDistShape+".distance";
	}else{
		// create multDiv node to divide values by masterScale
		string $pvDistMltDiv = abRTCreateNode("multiplyDivide", "LegPvDistScaleAdjust", $prefix, $limbName);
		setAttr ($pvDistMltDiv+".operation") 2;
		connectAttr ($upLegPvDistShape+".distance") ($pvDistMltDiv+".input1X");
		connectAttr ($pvIkCtrlDistShape+".distance") ($pvDistMltDiv+".input1Y");
		connectAttr ($rootCtrl+".masterScale") ($pvDistMltDiv+".input2X");
		connectAttr ($rootCtrl+".masterScale") ($pvDistMltDiv+".input2Y");
		
		$upLegPvDistAtt = ($pvDistMltDiv+".outputX");
		$pvIkCtrlDistAtt = ($pvDistMltDiv+".outputY");
		
	}
	
	if ($mirroredBehavior && $prefix == "r"){
		// if skeleton was created with mirror behavior, tx will be negative for the -X limb joints, need to negate it to get PV snap to move the joints the correct way
		
		string $pvNegateTxMltDiv = abRTCreateNode("multiplyDivide", "armPvNegate", $prefix, $limbName);
		setAttr ($pvNegateTxMltDiv+".input2") -1 -1 0;
		connectAttr $upLegPvDistAtt ($pvNegateTxMltDiv+".input1X");
		connectAttr $pvIkCtrlDistAtt ($pvNegateTxMltDiv+".input1Y");
		
		$upLegPvDistAtt = ($pvNegateTxMltDiv+".outputX");
		$pvIkCtrlDistAtt = ($pvNegateTxMltDiv+".outputY");
	}
	
	abRTSpliceConnection(($aIkJnts[1]+".tx"), $upLegPvDistAtt, ($pvCtrl+".snapKnee"), false, "upLegSnap", $prefix, $limbName);
	abRTSpliceConnection(($aIkJnts[2]+".tx"), $pvIkCtrlDistAtt, ($pvCtrl+".snapKnee"), false, "kneeSnap", $prefix, $limbName);
	
	// pv snap done
	
	// add spaces to foot and pvctrl
	string $txtFldPrefix = ($prefix == "l") ? "lf" : "rt";
	
	$pvCtrl = abRTParentConstrainToSpace($pvCtrl, $pvCtrl, {"rootCtrl","hipCtrl",($txtFldPrefix+"LegIkCtrl")}, "legPvCtrlGrp","rootCtrl");
	
	string $ikCtrlGrp = abRTParentConstrainToSpace(firstParentOf($ikCtrlCrv), $ikCtrlCrv, {"rootCtrl","cogCtrl"}, "legIkCtrl","rootCtrl");
	$ikCtrlCrv = $ikCtrlGrp+"|"+abRTStripPath($ikCtrlCrv);
	
	
	// make ankle and ball rotation reader jnts (so we can match fk leg to ik leg, because the ankle and ball on my ik rig are funky)
	// first dup knee, ankle and ball
	
	$aNames = {abRTRigNamer("ankleBallReader_UpLeg",$prefix,"jnt"), abRTRigNamer("ankleBallReader_Knee",$prefix,"jnt"), abRTRigNamer("ankleBallReader_Ankle",$prefix,"jnt"), abRTRigNamer("ankleBallReader_Ball",$prefix,"jnt")};
	string $aAnkleReaderJnts[] = abRTDuplicateJointHierarchy({$upLegJnt,$kneeJnt,$ankleJnt,$ballJnt}, $aNames, $legGrp);
	
	select -r $upLegJnt $aAnkleReaderJnts[0];
	abRTPointOrient(0);
	select -clear;
	
	orientConstraint -name (abRTRigNamer("ankleReader_knee",$prefix,"orCons")) $kneeJnt $aAnkleReaderJnts[1];
	orientConstraint -name (abRTRigNamer("ankleReader_ankle",$prefix,"orCons")) $aRevFootJnts[3] $aAnkleReaderJnts[2];
	orientConstraint -name (abRTRigNamer("ankleReader_ball",$prefix,"orCons")) $aIkHeelToeJnts[0] $aAnkleReaderJnts[3];
	
	// hide it
	setAttr ($aAnkleReaderJnts[0]+".v") 0;
	
	select -clear;
	
	// save leg joints to charVars
	abRTSaveToCharVars($aAllLegJnts, $limbName);
	
	$ret = 1;
	return $ret;
}


global proc string[] abRTGetSplits(string $upJnt, int $inline){
	// returns the split joints below $upJnt, $inline splits only if $inline == true, otherwise returns only branching
	// splits are identified by their name, so make sure they end with "split[0-9]*_jnt"
	
	string $aRel[], $aRet[], $jnt, $aSplits[], $cJnt;
	
	string $splitMatchStr = "split[0-9]*_jnt$";
	
	$aRel = `listRelatives -c -f -type joint $upJnt`;
	if (size($aRel) == 0) return $aRet;
	
	if ($inline){
		
		$cJnt = $upJnt;
		
		do {
			clear ($aSplits);
			$aRel = `listRelatives -c -f -type joint $cJnt`;
			
			for ($jnt in $aRel){
				if (size(`listRelatives -c -f -type joint $jnt`) > 0){
					if (`match $splitMatchStr (tolower($jnt))` != "") $aSplits[size($aSplits)] = $jnt;
				}
			}
			
			if (size($aSplits) == 1){
				$cJnt = $aSplits[0];
				$aRet[size($aRet)] = $cJnt;
			}else{
				$cJnt = "";
			}
			
		} while ($cJnt != "");
		
	}else{
		for ($jnt in $aRel){
			
			if (size(`listRelatives -c -f -type joint $jnt`) == 0){
				if (`match $splitMatchStr (tolower($jnt))` != ""){
					$aRet[size($aRet)] = $jnt;
				}
			}
		}
	}
	
	return $aRet;
	
}


global proc string abRTGetDownJoint(string $upJnt){
	// returns string with downJoint for given upJnt (culls splits)
	// returns nothing if there are multiple dnJnts
	
	string $aRel[], $ret, $jnt, $aSplits[], $aDnJnts[], $cJnt;
	
	string $splitMatchStr = "split[0-9]*_jnt$";
	
	$aRel = `listRelatives -c -f -type joint $upJnt`;
	if (size($aRel) == 0) return $ret;
	
	$cJnt = $upJnt;
	
	do {
		clear ($aSplits);
		clear ($aDnJnts);
		$aRel = `listRelatives -c -f -type joint $cJnt`;
		
		for ($jnt in $aRel){
			
			// check for inline split
			if (size(`listRelatives -c -f -type joint $jnt`) > 0){
				if (`match $splitMatchStr (tolower($jnt))` != ""){
					$aSplits[size($aSplits)] = $jnt;
					continue;
				}
			}
			if (`match $splitMatchStr (tolower($jnt))` == "") $aDnJnts[size($aDnJnts)] = $jnt;
		}
		
		$cJnt = "";
		
		if (size($aDnJnts) == 1){
			if (size($aSplits) == 0){
				$ret = $aDnJnts[0];
			}
		}else{
			if (size($aSplits) == 1) $cJnt = $aSplits[0];
		}
		
	} while ($cJnt != "");
	
	return $ret;
	
}


global proc string abRTGetRootFromJoint(string $jnt){
	// returns the root of a skeleton based on the selection of a child joint or "" if unsuccessful
	
	string $aRel[], $parent, $ret;
	float $float;
	
	$aRel = `listRelatives -p -fullPath -type joint $jnt`;
	
	// if $jnt has no joint parents then it's our rootJnt -- return it
	if (size($aRel) == 0) return $jnt;
	
	// keep moving up hierarchy until there are no more joints
	int $counter = 0;
	while (size($aRel) == 1 && `nodeType $aRel[0]` == "joint"){
		
		$float = `getAttr ($aRel[0]+".tx")`;
		if (abs($float) < .00000000000001){
			$ret = $aRel[0];
			break;
		}
		
		$parent = $aRel[0];
		$aRel = `listRelatives -p -fullPath -type joint $parent`;
		
		$counter ++;
		if ($counter > 80) break;
	}
	
	return $ret;
	
}


global proc string abRTSpliceConnection(string $destConAtt, string $newConAtt, string $blenderAtt, int $flip, string $baseName, string $prefix, string $limbName){
	/*
	destConAtt is destination connection -- the attribute that you want to splice in on ("knee.tx")
	$newConAtt is the attribute that you want to plug into $destConAtt along with its existing connection
	this proc will create a colorBlend and use $blenderAtt -- when blenderAtt is true, $newConnAtt will be output into $destConAtt, if $blenderAtt is false, the existing connection will be plugged in
	$baseName and $prefix are for naming the new nodes  (baseName "elbow", prefix "l")
	$limbName is limbName attribute to record newly created nodes to in charVars
	if $flip is true, when blenderAtt is false, $newConnAtt will be output into $destConAtt
	returns new blend node
	*/
	
	string $ret;
	string $existConAtt = `connectionInfo -sourceFromDestination $destConAtt`;
	
	if ($existConAtt != ""){
		
		disconnectAttr $existConAtt $destConAtt;
		string $blend = abRTCreateNode("blendColors", ($baseName+"Splice"), $prefix, $limbName);
		
		if ($flip){
			string $tConnAtt = $newConAtt;
			$newConAtt = $existConAtt;
			$existConAtt = $tConnAtt;
		}
		
		connectAttr $blenderAtt ($blend+".blender");
		connectAttr $newConAtt ($blend+".color1R");
		connectAttr $existConAtt ($blend+".color2R");
		connectAttr ($blend+".outputR") $destConAtt;
		
		$ret = $blend;
	}
	
	return $ret;
	
}


global proc string[] abRTGetSpaceSwitchInfoForCtrl(string $ctrl){
	// returns spaceswitch frzGrp and parentConstraint name in array when $ctrl == a control curve
	// form of {ssFrzGrp, ssParentConstraint}
	
	string $aRet[], $aStr[], $aHistory[], $ssFrzGrp, $ssParCon, $parent, $aRel[];
	
	string $aOrigSel[] = `ls -sl`;
	
	// must find frzGrp first
	$parent = $ctrl;
	
	$aRel = `listRelatives -p -f $parent`;
	
	while (size($aRel) == 1 && $ssFrzGrp == ""){
		
		if (size($aRel) == 1){
			$parent = $aRel[0];
			
			if (`match "_space_grp$" $parent` == "_space_grp"){
				// found it
				$ssFrzGrp = $parent;
				break;
			}
			
			$aRel = `listRelatives -p -f $parent`;
			continue;
			
		}else{
			break;
		}
	} 
	
	if ($ssFrzGrp != ""){
		
		$aHistory = `listHistory -levels 1 $ssFrzGrp`;
		select -r $aHistory;
		
		//$aStr = `ls -sl -type parentConstraint "*SpcParCon"`;
		$aStr = abRTStringArrayMatch(`ls -sl -type parentConstraint`, ".+SpcParCon$");
		
		if (size($aStr) == 1)
			$ssParCon = $aStr[0];
		
	}
	
	if ($ssFrzGrp != "" && $ssParCon != "")
		$aRet = {$ssFrzGrp, $ssParCon};
	
	select -r $aOrigSel;
	
	return $aRet;
}





global proc int abRTAddObjAsParentSpace(string $childObj, string $parentObj, string $objWithSpaceAtts, string $spaceName){
	// parents a child object to a parentObj and adds the att to $objWithSpaceAtts
	// $spaceName is the name of the space attribute
	// returns success or failure
	
	string $aSpaceSwitchGrpAndParCons[], $ssFrzGrp, $ssParCons, $aParConsWal[], $aNewParConsWal[]/* , $aParConsTargList[] */, $parConsWeightAttr;
	int $i;
	int $ret = false;
	
	$aSpaceSwitchGrpAndParCons = abRTGetSpaceSwitchInfoForCtrl($childObj);
	
	if (size($aSpaceSwitchGrpAndParCons) != 2)
		return $ret;
	
	$ssFrzGrp = $aSpaceSwitchGrpAndParCons[0];
	$ssParCons = $aSpaceSwitchGrpAndParCons[1];
	
	$aParConsWal = `parentConstraint -q -weightAliasList $ssParCons`;
	
	// ok, now add childObj to parentObj space grp parCons
	parentConstraint -e -mo $parentObj $ssFrzGrp;
	
	// get new wal list
	$aNewParConsWal = `parentConstraint -q -weightAliasList $ssParCons`;
	
	if (size($aNewParConsWal) > size($aParConsWal)){
		// success
		$parConsWeightAttr = $ssParCons+"."+$aNewParConsWal[size($aNewParConsWal)-1];
		
		// connect attribute
		if (objExists($objWithSpaceAtts)){
			
			// just in case the label att was removed for some reason
			if (!attributeExists("________SPACES___", $objWithSpaceAtts)){
				addAttr -ln "________SPACES___" -at bool -keyable false $objWithSpaceAtts;
				setAttr -lock true -cb true ($objWithSpaceAtts+".________SPACES___");
			}
			addAttr -ln $spaceName -at double -min 0 -max 1 -dv 0 -keyable true $objWithSpaceAtts;
			connectAttr -f ($objWithSpaceAtts+"."+$spaceName) $parConsWeightAttr;
		}
		$ret = true;
	}
	
	return $ret;
}


global proc string abRTParentConstrainToSpace(string $obj, string $objToAddAttrTo, string $aSpaces[], string $baseName, string $defaultEnabled){
	/*
	will parent constrain $obj to a given space (a null parented appropriately)
	spaces contained in $aSpaces, are key words that correspond to UI name conventions -- have to be able to retrieve object from abRTGetFromUI using the string
	space strings can be "world" or global loc name of a ui field (retrievable from abRTGetFromUI) like "upLeg", or "rootCtrl", etc
	$baseName is used in naming of constraint
	$defaultEnabled is the space name in $aSpaces that should be enabled by default
	creates attribute on $objToAddAttrTo for each space in $aSpaces -- had to do this because obj might be a freeze grp, yet want atts on frozen object
	
	returns $obj new path (placed in group which is constrained to spaces)
	*/
	
	string $prefix = abRTGetObjSide($obj);
	string $rigRootFolder = abRTRigRootFolder();
	string $ret, $parent, $parentPath, $parConsWeightAttr, $nullParent, $aStr[], $parentCons, $weightAtt, $space, $aNameParPath[], $objGrp;
	int $i;
	
	for ($i=0;$i<size($aSpaces);$i++){
		
		$space = $aSpaces[$i];
		
		if ($space == "world" || abRTGetFromUI($space) != ""){
			
			$parent = abRTRigNamer($space, "", "spcSwtchGrp");
			$parentPath = $rigRootFolder+"|"+$parent;
			
			if (!`objExists $parentPath`){
				string $grp = `group -em -n $parent`;
				$parentPath = abRTParent($grp, $rigRootFolder);
				
				if ($space != "world"){
					
					$nullParent = abRTGetFromUI($space);
					if ($nullParent != ""){
						
						// constrain null to the appropriate joint
						abRTSnapToPosition($nullParent, $parentPath);
						
						parentConstraint -mo -n (abRTRigNamer(($space+"Space"),"", "parCons")) $nullParent $parentPath;
						
					}
					
					// connect space switch grp to masterScale (except for world)
					abRTConnectToMasterScale($parentPath);
				}
			}
			
			$aNameParPath[size($aNameParPath)] = $space;
			$aNameParPath[size($aNameParPath)] = $parentPath;
		}
	}
	
	$objGrp = `group -em -n (abRTRigNamer($baseName, $prefix, "space_grp"))`;
	
	string $ctrlGrp = firstParentOf($obj);
	if ($ctrlGrp != "") $objGrp = abRTParent($objGrp, $ctrlGrp);
	
	if (size($aNameParPath) > 0){
		
		int $aLock[], $val;
		string $aTrans[] = {"tx","ty","tz","rx","ry","rz","sx","sy","sz"};
		
		string $conName = abRTRigNamer($baseName, $prefix, ($space+"SpcParCon"));
		
		addAttr -ln "________SPACES___" -at bool -keyable false $objToAddAttrTo;
		setAttr -lock true -cb true ($objToAddAttrTo+".________SPACES___");
		
		
		for ($i=0;$i<size($aNameParPath);$i+=2){
			
			$space = $aNameParPath[$i];
			$parentPath = $aNameParPath[$i+1];
			
			// create constraints
			if ($i == 0) $aStr = `parentConstraint -mo -weight 1 -n $conName $parentPath $objGrp`;
			else  $aStr = `parentConstraint -mo -weight 0 $parentPath $objGrp`;
			$parentCons = $aStr[0];
			$aStr = `parentConstraint -q -wal $parentCons`;
			$weightAtt = $aStr[size($aStr)-1];
			$parConsWeightAttr = $parentCons+"."+$weightAtt;
			
			$val = ($defaultEnabled == $space);
			addAttr -ln $space -at double -min 0 -max 1 -dv $val -keyable true $objToAddAttrTo;
			connectAttr -f ($objToAddAttrTo+"."+$space) $parConsWeightAttr;
			
		}
		
		// place obj in $objGrp
		$obj = abRTParent($obj, $objGrp);
		$ret = $obj;
	}
	
	return $ret;
	
}


global proc abRTMakeFingerIK(string $baseJnt, string $midJnt, string $tipJnt, string $baseName, string $ikAtt, string $grp, string $limbName, string $indexColorStr){
	// adds ik to a finger
	// baseJnt, midJnt, and tipJnt are the finger joints
	// baseName is finger name used for naming new nodes and ctrls
	// ikAtt is the attribute (prebuilt) to use for the ik/fk switching -- in the form of "lf_handCtrlCrv.midIK"
	// grp is the rig group in which to place the control curve
	// limbName is name of attribute to record nodes on charVars node
	// $indexColorStr is global key name to set the color of the controls
	
	
	string $aStr[], $aConn[];
	string $prefix = abRTGetObjSide($baseJnt);
	
	
	// we'll disconnect any incoming connections for the tip finger, so save those now to be reconnected later
	$aConn[size($aConn)] = `connectionInfo -sourceFromDestination ($tipJnt+".rx")`;
	$aConn[size($aConn)] = `connectionInfo -sourceFromDestination ($tipJnt+".ry")`;
	$aConn[size($aConn)] = `connectionInfo -sourceFromDestination ($tipJnt+".rz")`;
	
	int $i;
	string $aRotAtt[] = {"rx","ry","rz"};
	
	for ($i=0;$i<size($aConn);$i++){
		if ($aConn[$i] == "") continue;
		
		// disconnect the incoming att and, if the node in $aConn[$i] is a unitConversion node, delete it and find its source.  Otherwise the unitConversion node will have the wrong conversion value.
		
		disconnectAttr $aConn[$i] ($tipJnt+"."+$aRotAtt[$i]);
		
		if (`nodeType $aConn[$i]` == "unitConversion"){
			$aStr = stringToStringArray($aConn[$i], ".");
			if (size($aStr) > 1){
				$aConn[$i] = `connectionInfo -sourceFromDestination ($aStr[0]+".input")`;
				delete $aStr[0];
			}
		}
	}
	
	
	// make and position ctrl curve
	string $ikCtrl = abRTMakeWireController("square", 0, {}, 5);
	
	$aStr = abRTRename($ikCtrl, abRTRigNamer($baseName, $prefix, "ikCtrl"));
	$ikCtrl = $aStr[1];
	
	abRTSnapToPosition($tipJnt, $ikCtrl);
	
	if (`objExists $grp`) $ikCtrl = abRTParent($ikCtrl, $grp);
	
	$ikCtrl = abRTGroupFreezeReturnObj($ikCtrl, 1);
	string $ikCtrlGrp = firstParentOf($ikCtrl);
	
	// color it
	abRTColorObj($ikCtrl, $indexColorStr, -1);
	
	// make handle
	string $ikHandle = abRTMakeIkHandle($baseJnt, $tipJnt, abRTRigNamer($baseName, $prefix, "ikHandle"), $ikCtrl, $grp);
	
	// orient constrain tip to ikCtrl
	$aStr = `orientConstraint -n (abRTRigNamer(($baseName+"IkCtrl"), $prefix, "orCons")) $ikCtrl $tipJnt`;
	string $orCons = $aStr[0];
	$aStr = `orientConstraint -q -wal $orCons`;
	string $orConsWeight = $aStr[0];
	
	
	// connect it to the ik attribute
	string $condition = abRTCreateNode("condition", ($baseName+"IkCtrl"), $prefix, $limbName);
	
	connectAttr $ikAtt ($condition+".firstTerm");
	connectAttr ($condition+".outColorR") ($ikCtrl+".v");
	
	connectAttr $ikAtt ($orCons+"."+$orConsWeight);
	connectAttr $ikAtt ($ikHandle+".ikBlend");
	
	// add twist
	addAttr -ln "twist" -at double  -min -360 -max 360 -dv 0 -keyable true $ikCtrl;
	connectAttr ($ikCtrl+".twist") ($ikHandle+".twist");
	
	// add attribute to change rotate order
	setAttr -lock false -channelBox true ($ikCtrl+".rotateOrder");
	
	// add spaces 
	string $txtFldPrefix = ($prefix == "l") ? "lf" : "rt";
	
	$ikCtrlGrp = abRTParentConstrainToSpace($ikCtrlGrp, $ikCtrl, {"rootCtrl",($txtFldPrefix+"HandCtrl"),"lowSpineCtrl","hiSpineCtrl","headCtrl"}, ($baseName+"Ctrl"),($txtFldPrefix+"HandCtrl"));
	
	if ($ikCtrlGrp != "") $ikCtrl = $ikCtrlGrp+"|"+abRTStripPath($ikCtrl);
	
	// hide atts
	abRTHideAttr($ikCtrl, {"sx","sy","sz","v"});
	
	// reconnect incoming connections to tipJnt
	string $newConn;
	
	if ($aConn[0] != ""){
		if ($newConn != $aConn[0]) abRTSpliceConnection(($tipJnt+".rx"), $aConn[0], $ikAtt, true, ($baseName+"Tip"), $prefix, $limbName);
	}
	if ($aConn[1] != ""){
		if ($newConn != $aConn[1]) abRTSpliceConnection(($tipJnt+".ry"), $aConn[1], $ikAtt, true, ($baseName+"Tip"), $prefix, $limbName);
	}
	if ($aConn[2] != ""){
		if ($newConn != $aConn[2]) abRTSpliceConnection(($tipJnt+".rz"), $aConn[2], $ikAtt, true, ($baseName+"Tip"), $prefix, $limbName);
	}
	
}


global proc abRTMakeStretchySplineWin(){
	
	if (`window -exists abRTStrSpnWin`)
		deleteUI -window abRTStrSpnWin;
	
	window -t "abMakeStretchySpline" -w 250 -h 268 -minimizeButton false -maximizeButton false abRTStrSpnWin;
	
	int $lmargin = 3;
	int $rmargin = 3;
	int $lTxtMarg = 10;
	int $rTxtMarg = 10;
	
	formLayout -numberOfDivisions 100 abRTStrSpnForm;
	
	nameField abRTStrSpnCrvNmFld;
	nameField -manage false abRTStrSpnCrvShapeNmFld;
	
	button -label "Select Curve" -c "abRTStretchySplineSelCurve()" abRTStrSpnSelCrvBn;
	
	text -label "Number of Joints:" abRTStrSpnJointNumTxt;
	intSliderGrp -min 4 -max 60 -v 10 -field true -columnWidth2 30 100 -adjustableColumn2 2 abRTStrSpnJntNumIntSldrGrp;
	
	text -label "Naming Prefix:" abRTStrSpnPrefixTxt;
	textField -text "spline" abRTStrSpnPrefixTxtFld;
	
	nameField abRTStrSpnParentNmFld;
	button -label "Select Parent" -c "string $gaStr[] = `ls -sl -type transform`; if (size($gaStr) == 1) nameField -e -object $gaStr abRTStrSpnParentNmFld; else nameField -e -object \"\" abRTStrSpnParentNmFld;" abRTStrSpnSelParentBn;
	
	text -label "First Control Curve Relative Size:" abRTStrSpnDnCtrlSizeTxt;
	floatField -v 1.0 -min 0.001 -max 10.0 abRTStrSpnDnCtrlSizeFltFld;
	text -label "Last Control Curve Relative Size:" abRTStrSpnUpCtrlSizeTxt;
	floatField -v .5 -min 0.001 -max 10.0 abRTStrSpnUpCtrlSizeFltFld;
	
	
	optionMenu -label "Control Axis Up The Spline:" -w 230 abRTStrSpnJntUpCtrlAxisOpMn;
	menuItem -label "X";
	menuItem -label "Y";
	menuItem -label "Z";
	menuItem -label "-X";
	menuItem -label "-Y";
	menuItem -label "-Z";
	
        optionMenu -label "Forward Control Axis:" -w 230 abRTStrSpnForCtrlAxisOpMn;
	menuItem -label "X";
	menuItem -label "Y";
	menuItem -label "Z";
	menuItem -label "-X";
	menuItem -label "-Y";
	menuItem -label "-Z";  
	
	optionMenu -e -select 1 abRTStrSpnJntUpCtrlAxisOpMn;
	optionMenu -e -select 2 abRTStrSpnForCtrlAxisOpMn;
	
	separator abRTStrSpnSep1;
	separator abRTStrSpnSep2;
	button -l "Create Stretchy Spline" -en false -h 28 -c "abRTMakeStretchySpline();" abRTStrSpnBldBn;
	
	formLayout -e
	
	-af abRTStrSpnCrvNmFld "top" 7
	-af abRTStrSpnCrvNmFld "left" $lmargin
	-af abRTStrSpnCrvNmFld "right" 80
	
	-af abRTStrSpnSelCrvBn "top" 6
	-ac abRTStrSpnSelCrvBn "left" $lmargin abRTStrSpnCrvNmFld
	-af abRTStrSpnSelCrvBn "right" $rmargin
	
	-ac abRTStrSpnParentNmFld "top" 7 abRTStrSpnSelCrvBn
	-af abRTStrSpnParentNmFld "left" $lmargin
	-af abRTStrSpnParentNmFld "right" 80
	
	-ac abRTStrSpnSelParentBn "top" 6 abRTStrSpnSelCrvBn
	-ac abRTStrSpnSelParentBn "left" $lmargin abRTStrSpnParentNmFld
	-af abRTStrSpnSelParentBn "right" $rmargin
	
	-ac abRTStrSpnSep1 "top" 6 abRTStrSpnSelParentBn
	-af abRTStrSpnSep1 "left" $lmargin
	-af abRTStrSpnSep1 "right" $rmargin
	
	-ac abRTStrSpnJointNumTxt "top" 8 abRTStrSpnSep1
	-af abRTStrSpnJointNumTxt "left" $lTxtMarg
	
	-ac abRTStrSpnJntNumIntSldrGrp "top" 5 abRTStrSpnSep1
	-ac abRTStrSpnJntNumIntSldrGrp "left" $lmargin abRTStrSpnJointNumTxt
	-af abRTStrSpnJntNumIntSldrGrp "right" $rTxtMarg
	
	-ac abRTStrSpnPrefixTxt "top" 6 abRTStrSpnJntNumIntSldrGrp
	-af abRTStrSpnPrefixTxt "left" $lTxtMarg
	
	-ac abRTStrSpnPrefixTxtFld "top" 4 abRTStrSpnJntNumIntSldrGrp
	-ac abRTStrSpnPrefixTxtFld "left" $lmargin abRTStrSpnPrefixTxt
	-af abRTStrSpnPrefixTxtFld "right" $rTxtMarg
	
	
	-ac abRTStrSpnDnCtrlSizeTxt "top" 7 abRTStrSpnPrefixTxtFld
	-af abRTStrSpnDnCtrlSizeTxt "left" $lTxtMarg
	
	-ac abRTStrSpnDnCtrlSizeFltFld "top" 4 abRTStrSpnPrefixTxtFld
	-ac abRTStrSpnDnCtrlSizeFltFld "left" $lmargin abRTStrSpnDnCtrlSizeTxt
	-af abRTStrSpnDnCtrlSizeFltFld "right" $rTxtMarg
	
	
	-ac abRTStrSpnUpCtrlSizeTxt "top" 7 abRTStrSpnDnCtrlSizeFltFld
	-af abRTStrSpnUpCtrlSizeTxt "left" $lTxtMarg
	
	-ac abRTStrSpnUpCtrlSizeFltFld "top" 4 abRTStrSpnDnCtrlSizeFltFld
	-ac abRTStrSpnUpCtrlSizeFltFld "left" $lmargin abRTStrSpnUpCtrlSizeTxt
	-af abRTStrSpnUpCtrlSizeFltFld "right" $rTxtMarg
	
	
	-ac abRTStrSpnJntUpCtrlAxisOpMn "top" 5 abRTStrSpnUpCtrlSizeFltFld
	-af abRTStrSpnJntUpCtrlAxisOpMn "left" $lTxtMarg
	-af abRTStrSpnJntUpCtrlAxisOpMn "right" $rTxtMarg
	
	-ac abRTStrSpnForCtrlAxisOpMn "top" 6 abRTStrSpnJntUpCtrlAxisOpMn
	-af abRTStrSpnForCtrlAxisOpMn "left" $lTxtMarg
	-af abRTStrSpnForCtrlAxisOpMn "right" $rTxtMarg
	
	
	-ac abRTStrSpnSep2 "top" 6 abRTStrSpnForCtrlAxisOpMn
	-af abRTStrSpnSep2 "left" $lmargin
	-af abRTStrSpnSep2 "right" $rmargin
	
	-ac abRTStrSpnBldBn "top" 8 abRTStrSpnSep2
	-af abRTStrSpnBldBn "left" $lmargin
	-af abRTStrSpnBldBn "right" $rmargin
	
	abRTStrSpnForm;
	
	showWindow abRTStrSpnWin;
	
}


global proc abRTStretchySplineSelCurve(){
	// services select curve button in makeStretchySplineUI
	
	string $aSel[] = `ls -sl`;
	string $aRel[], $curve, $curveShape;
	int $ok = false;
	
	if (size($aSel) == 1){
		$aRel = `listRelatives -shapes $aSel[0]`;
		if (size($aRel) >= 1){
			$ok = true;
			$curve = $aSel[0];
			$curveShape = $aRel[0];
		}
	}
	
	nameField -e -object $curve abRTStrSpnCrvNmFld;
	nameField -e -manage false -object $curveShape abRTStrSpnCrvShapeNmFld;
	button -e -en $ok abRTStrSpnBldBn;
	
	if (!$ok) warning "Select a single curve and try again";
	
}


global proc abRTMakeStretchySpline(){
	// creates a stretchy spline with joints from the selected curve and adds fk controls.
	
	if (!`window -exists abRTStrSpnWin`) return;
	
	int $i, $k, $int, $iMod;
	int $jointNum = `intSliderGrp -q -v abRTStrSpnJntNumIntSldrGrp`;
	float $aTrans[];
	string $aStr[], $obj, $str, $attCurve, $aAxis;
	string $curve = `nameField -q -object abRTStrSpnCrvNmFld`;
	string $curveShape = `nameField -q -object abRTStrSpnCrvShapeNmFld`;
	string $prefix = `textField -q -text abRTStrSpnPrefixTxtFld`;
	string $splineRootCon = `nameField -q -object abRTStrSpnParentNmFld`;
	string $upAxisStr = `optionMenu -q -value abRTStrSpnJntUpCtrlAxisOpMn`;
	string $forwardAxisStr = `optionMenu -q -value abRTStrSpnForCtrlAxisOpMn`;
	float $dnCtrlRelSize = `floatField -q -v abRTStrSpnDnCtrlSizeFltFld`;
	float $upCtrlRelSize = `floatField -q -v abRTStrSpnUpCtrlSizeFltFld`;
	
	string $aCtrlAxisConvertTable[] = {"X","Y","Z","-X","-Y","-Z"};
	string $aAxes[] = {"X","Y","Z"};
	string $aRgb[] = {"R","G","B"};
	
	int $upAxis = abRTGetPosInStrArray($upAxisStr, $aCtrlAxisConvertTable); // 0:x, 1:y, 2:z, 3:-x, 4:-y, 5:-z
	int $forwardAxis = abRTGetPosInStrArray($forwardAxisStr, $aCtrlAxisConvertTable); // 0:x, 1:y, 2:z, 3:-x, 4:-y, 5:-z
	
	
	if (abs($upAxis - $forwardAxis) == 3 || $upAxis - $forwardAxis == 0){
		warning "The up and forward control axes must be unique.  Try again.";
		return;
	}
	
	if (objExists($prefix+"Rig_grp") || objExists($prefix+"_ikHndl")){
		warning "A spline with the same prefix already exists in this scene.  Enter a new prefix and try again.";
		return;
	}
	
	if (!`objExists $curve` || !`objExists $curveShape`){
		abRTStretchySplineSelCurve();
		return;
	}
	
	// cache global scale (makeCurve uses it) and set it to 1
	string $cScale = abRTGetGlobal("globalScale");
	abRTSetGlobal("globalScale", 1);
	
	int $deg = `getAttr ($curveShape+".degree")`;
	int $spans = `getAttr ($curveShape+".spans")`;
	int $numCvs = $deg+$spans;
	
	// make array of spine joint names
	string $alphaId, $aNames[];
	
	for ($i=0;$i<$jointNum;$i++){
		
		$alphaId = abRTGetNumToAlphaId($i);
		$aNames[size($aNames)] = $prefix+"_"+$alphaId+"_jnt";
	}
	
	// make groups
	string $grp = `group -em -name ($prefix+"Rig_grp")`;
	string $scaleGrp = `group -em -p $grp -name ($prefix+"Scale_Rig_grp")`;
	
	// rebuild curve and make spine joints
	$aStr = `rebuildCurve -ch 1 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.01 $curve`;
	string $rebuiltSpineCurve = $aStr[0];
	string $aJnts[] = abRTMakeSpineJntsFromCurve($rebuiltSpineCurve, $aNames, "", false);
	delete $rebuiltSpineCurve;
	
	// orient joints
	abRTOrientJoints($aJnts, "xyz", "zup");
	
	// need to fix last joint's alignment (otherwise will scale in the wrong direction when masterScaled)
	// create a helper joint by duping next to last joint and moving it beyond the last joint tx
	$aStr = `duplicate -renameChildren $aJnts[size($aJnts)-1]`;
	string $tJoint = $aStr[0];
	float $flt = `getAttr (($aJnts[size($aJnts)-1])+".tx")`;
	setAttr ($tJoint+".tx") ($flt*2.0);
	$tJoint = abRTParent($tJoint, $aJnts[size($aJnts)-1]);
	
	// orient joints (again)
	abRTOrientJoints($aJnts, "xyz", "zup");
	
	// delete helper joint
	delete $tJoint;
	
	// move grp
	abRTSnapToPosition($aJnts[0], $grp);
	
	// create ikSpline
	string $aSpineIkHandle[] = `ikHandle
	-name ($prefix+"_ikHndl")
	-solver "ikSplineSolver"
	-startJoint $aJnts[0]
	-endEffector $aJnts[size($aJnts)-1]
	-createCurve false
	-curve $curveShape
	-simplifyCurve false
	-rootOnCurve true
	-snapHandleFlagToggle on
	-twistType "linear"
	-createRootAxis true
	-rootTwistMode false
	-connectEffector true
	-parentCurve false`
	;
	
	setAttr ($aSpineIkHandle[0]+".v") 0;
	
	// create clusters on curve
	string $aSpineClusters[], $aSpineClusterHandles[];
	for ($i=0;$i<$numCvs;$i++){
		
		select -r ($curveShape+".cv["+$i+"]");
		
		$alphaId = abRTGetNumToAlphaId($i);
		if ($i == 3) $aStr = `cluster -relative -name ($prefix+"_"+$alphaId+"_clstr")`;
		else $aStr = `cluster -name ($prefix+"_"+$alphaId+"_clstr")`;
		
		$aSpineClusters[size($aSpineClusters)] = $aStr[0];
		$aSpineClusterHandles[size($aSpineClusterHandles)] = $aStr[1];
		setAttr ($aSpineClusterHandles[$i]+".v") 0;
		setAttr ($aSpineClusters[$i]+".relative") 0;
	}
	
	// need to create jointChain snapped to cvs of $curve so we can properly align the ctrl curves
	
	// position locs at curve cvs
	string $aLocs[], $aRigJntNames[], $aRigJnts[], $aCtrlCrvNames[];
	int $aJntsToAlign[];
	
	for ($i=0;$i<$numCvs;$i++){
		
		$aLocs[$i] = abRTMakeLocator($prefix+"TempStretchySpline_"+$i+"_loc");
		$aTrans = `pointPosition -w ($curveShape+".cv["+$i+"]")`;
		
		move -absolute $aTrans[0] $aTrans[1] $aTrans[2] $aLocs[$i];
		
		$alphaId = abRTGetNumToAlphaId($i);
		$aRigJntNames[$i] = $prefix+"Rig_"+$alphaId+"_jnt";
		
		if ($i < ($numCvs-1)){
			$aCtrlCrvNames[$i] = $prefix+"_"+$alphaId+"_ctrl";
			
			$aJntsToAlign[$i] = $i;
		}
	}
	
	// make jointChain from locs
	$aRigJnts = abRTDuplicateJointHierarchy($aLocs, $aRigJntNames, "");
	
	// orient jointChain joints
	abRTOrientJoints($aRigJnts, "xyz", "zup");
	
	// delete locs
	for ($obj in $aLocs) delete $obj;
	
	// make curveInfo node and get arcLength
	string $curveInfoNode = abRTCreateNode("curveInfo", $prefix, "", "");
	connectAttr ($curveShape +".worldSpace")  ($curveInfoNode+".inputCurve");
	float $arcLen = `getAttr ($curveInfoNode+".arcLength")`;
	
	// create control curves
	string $aCtrlCrvs[], $aCtrlCrvGrps[], $rootSpaceRevNode, $revInput, $revOutput, $aCrvParCon[], $splineRootCon;
	float $startSize = $arcLen * .5 * $dnCtrlRelSize;
	float $endSize = $arcLen * .5 * $upCtrlRelSize;
	
	float $sizeDelta = ($startSize - $endSize)/(size($aSpineClusterHandles));
	int $makeRoot = false;
	
	if ($splineRootCon == "" || !objExists($splineRootCon)){
		
		// make splineRootCon
		$splineRootCon = abRTMakeWireController("circle", 0, {}, ($startSize*1.3));
		$aStr = abRTRename($splineRootCon, ($prefix+"_root_ctrl"));
		$splineRootCon = $aStr[1];
		$makeRoot = true;
		
		// position it
		abRTSnapToPosition($aRigJnts[0], $splineRootCon);
		
		$splineRootCon = abRTGroupFreezeReturnObj($splineRootCon, true);
	}
	
	// create an object that will bake the ctrlCurve's desired pivot by parenting the ctrl under it and freezing transforms
	float $upVector[] = {0.0, 0.0, 0.0};
	float $aimVector[] = {0.0, 0, 0.0};
	
	if ($upAxis <= 2)
		$upVector[$upAxis] = 1.0;
	else
		$upVector[$upAxis-3] = -1.0;
	
	if ($forwardAxis <= 2)
		$aimVector[$forwardAxis] = 1.0;
	else
		$aimVector[$forwardAxis-3] = -1.0;
	
	// masterParent will match the orientation of the joints in the chain and will be duped to serve as the parent of the new controlCurves
	string $pivotOven = abRTMakeLocator("abRTStretchySpinePivotOven");
	string $masterParent = abRTMakeLocator("abRTStretchySpineMasterParent");
	string $tMasterOven = abRTMakeLocator("abRTStretchySpineTempMasterOven");
	string $tParentLoc;
	
	// orient masterParent to the joint chain default (x up, y on positive world z)
	setAttr ($tMasterOven+".r") 90 0 90;
	$masterParent = abRTParent($masterParent, $tMasterOven);
	makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $masterParent;
	$aStr = `parent -w $masterParent`;
	$masterParent = $aStr[0];
	delete $tMasterOven;
	
	// orient pivot oven to the desired control orientation
	string $aimTargetLoc = abRTMakeLocator("abRTStretchySpineAimTargetLoc");
	
	// move in world positive Z
	move -a -ws 0 0 10 $aimTargetLoc;
	$aStr = `aimConstraint -offset 0 0 0 -weight 1 -aimVector $aimVector[0] $aimVector[1] $aimVector[2] -upVector $upVector[0] $upVector[1] $upVector[2] -worldUpType "scene" $aimTargetLoc $pivotOven`;
	for ($str in $aStr)
		delete $str;
	delete $aimTargetLoc;
	
	
	// set up the rest of the control curves
	for ($i=0;$i<(size($aSpineClusterHandles)-1);$i++){
		
		$alphaId = abRTGetNumToAlphaId($i);
		$aCtrlCrvs[$i] = abRTMakeWireController("circle", 1, {}, ($startSize-$sizeDelta*$i));
		$aStr = abRTRename($aCtrlCrvs[$i], ($prefix+"_"+$alphaId+"_ctrl"));
		
		$aCtrlCrvs[$i] = $aStr[1];
		
		// create reverse node
		if ($i%3 == 0)
			$rootSpaceRevNode = abRTCreateNode("reverse", ($prefix+(int($i/3))), "", "");
		
		$revInput = $rootSpaceRevNode + ".input" + $aAxes[$i%3];
		$revOutput = $rootSpaceRevNode + ".output" + $aAxes[$i%3];
		
		// adjust pivot
		$aCtrlCrvs[$i] = abRTParent($aCtrlCrvs[$i], $pivotOven);
		makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $aCtrlCrvs[$i];
		
		// parent to masterLoc dup
		$aStr = `duplicate -po -n ($prefix+"_"+$alphaId+"_parent_loc") $masterParent`;
		$tParentLoc = $aStr[0];
		$aCtrlCrvs[$i] = abRTParent($aCtrlCrvs[$i], $tParentLoc);
		
		// position curve
		abRTSnapToPosition($aRigJnts[$i], $tParentLoc);
		$aStr = `parent -w $aCtrlCrvs[$i]`;
		$aCtrlCrvs[$i] = $aStr[0];
		delete $tParentLoc;
		
		// parent to previous curves
		$aCtrlCrvs[$i] = abRTGroupFreezeReturnObj($aCtrlCrvs[$i], true);
		$aCtrlCrvGrps[$i] = firstParentOf($aCtrlCrvs[$i]);
		
		// add rootspace att to control curve
		addAttr -ln "rootSpace" -at bool $aCtrlCrvs[$i];
		setAttr -e-keyable true ($aCtrlCrvs[$i]+".rootSpace");
		
		// parent constrain to curve[$i-1] and to root curve
		if ($i == 0){
			
			// first curve only gets parented to root (no curve below)
			$aCrvParCon = `parentConstraint -mo -n ($prefix+"_"+$alphaId+"_parCon") $splineRootCon $aCtrlCrvGrps[$i]`;
			$aStr = `parentConstraint -q -weightAliasList $aCrvParCon[0]`;
			
			// connect to rootSpace parCons att
			connectAttr -f ($aCtrlCrvs[$i]+".rootSpace") ($aCrvParCon[0]+"."+$aStr[0]);
			
			setAttr ($aCtrlCrvs[$i]+".rootSpace") true;
			
		}else{
			
			$aCrvParCon = `parentConstraint -mo -n ($prefix+"_"+$alphaId+"_parCon") $aCtrlCrvs[$i-1] $splineRootCon $aCtrlCrvGrps[$i]`;
			$aStr = `parentConstraint -q -weightAliasList $aCrvParCon[0]`;
			
			if (size($aStr) == 2){
				// connect curve below parCons att
				connectAttr -f ($aCtrlCrvs[$i]+".rootSpace") $revInput;
				connectAttr -f $revOutput ($aCrvParCon[0]+"."+$aStr[0]);
				
				// connect to rootSpace parCons att
				connectAttr -f ($aCtrlCrvs[$i]+".rootSpace") ($aCrvParCon[0]+"."+$aStr[1]);
			}
		}
		
		// parent clusters to curves
		parentConstraint -n ($prefix+"Cluster_"+$alphaId+"_parCon") $aCtrlCrvs[$i] $aSpineClusterHandles[$i];
		if ($i == (size($aSpineClusterHandles)-2)) parentConstraint -mo $aCtrlCrvs[$i] $aSpineClusterHandles[$i+1];
		
		// hide atts
		abRTHideAttr($aCtrlCrvs[$i], {"sx","sy","sz","v"});
		
	}
	
	// delete locs
	delete $pivotOven;
	delete $masterParent;
	
	// delete rig joints
	delete $aRigJnts[0];
	
	// set attribute holder
	$attCurve = ($makeRoot) ? $splineRootCon : $aCtrlCrvs[0];
	
	string $attLabel = "stretchySplineSettings";
	addAttr -ln $attLabel -at bool -keyable false $attCurve;
	setAttr -lock true -cb true ($attCurve+"."+$attLabel);
	
	// add stretch
	float $aSpineLenRatios[], $float;
	for ($i=0;$i<size($aJnts);$i++){
		$float = `getAttr ($aJnts[$i]+".tx")`;
		$aSpineLenRatios[$i] = $float/$arcLen;
	}
	
	// add stretch switch and attribute
	addAttr -ln "stretchy" -at double -min 0 -max 1 -dv 1 -keyable true $attCurve;
	
	// create scale and stretch amount atts
	addAttr -ln "masterScale" -at double -dv 1 -min .0001 -keyable true $attCurve;
	addAttr -ln "stretchAmount" -at double -dv 0 -min 0 -keyable true $attCurve;
	
	// create scale adjusted arcLen
	string $arcLenMultDiv = abRTCreateNode("multiplyDivide", ($prefix+"ScaleAdjustedArcLen"), "", "");
	setAttr ($arcLenMultDiv+".operation") 2;
	connectAttr -f ($curveInfoNode+".arcLength") ($arcLenMultDiv+".input1X");
	connectAttr -f ($attCurve+".masterScale") ($arcLenMultDiv+".input2X");
	string $saArcLenNodeAtt = $arcLenMultDiv+".outputX"; // scale adjusted arcLen node att
	
	string $curveLenBld = abRTCreateNode("blendColors", $prefix, "", "");
	setAttr ($curveLenBld+".color2R") $arcLen;
	connectAttr $saArcLenNodeAtt  ($curveLenBld+".color1R");
	connectAttr ($attCurve+".stretchy")  ($curveLenBld+".blender");
	
	
	// multiply ratios and current curve length
	string $aSpineArcLenMltDiv[], $tNode, $tArcLenMltDiv, $tDynArcLenMltDiv;
	
	for ($i=0;$i<size($aJnts);$i++){
		
		$iMod = $i % 3;
		$int = floor($i/3);
		$aAxis = $aAxes[$iMod];
		
		if ($iMod == 0){
			
			$alphaId = abRTGetNumToAlphaId($int+1);
			$tArcLenMltDiv = abRTCreateNode("multiplyDivide", ($prefix+"ArcLen_"+$alphaId), "", "");
		}
		
		setAttr ($tArcLenMltDiv+".input1"+$aAxis) $aSpineLenRatios[$i];
		connectAttr -f ($curveLenBld+".outputR") ($tArcLenMltDiv+".input2"+$aAxis);
		connectAttr -f ($tArcLenMltDiv+".output"+$aAxis) ($aJnts[$i]+".tx");
	}
	
	// here's where we determine the stretch amount
	string $stretchAmtMltDiv = abRTCreateNode("multiplyDivide", ($prefix+"StretchAmt"), "", "");
	setAttr ($stretchAmtMltDiv+".operation") 2;
	connectAttr -f $saArcLenNodeAtt ($stretchAmtMltDiv+".input1X");
	setAttr ($stretchAmtMltDiv+".input2X") $arcLen;
	connectAttr -f ($stretchAmtMltDiv+".outputX") ($attCurve+".stretchAmount");
	
	// expose values to drive squash and stretch blendshapes
	addAttr -ln "squashFalloff" -at double -min 0 -max 10 -dv 1.6 -keyable true $attCurve;
	addAttr -ln "squashScalar" -at double -min 0 -max 50 -dv 2.4 -keyable true $attCurve;
	addAttr -ln "stretchFalloff" -at double -min 0 -max 10 -dv .7 -keyable true $attCurve;
	addAttr -ln "stretchScalar" -at double -min 0 -max 50 -dv 1.4 -keyable true $attCurve;
	addAttr -ln "stretchDriver" -at double -min 0 -max 1 -dv 0 -keyable true $attCurve;
	addAttr -ln "squashDriver" -at double -min 0 -max 1 -dv 0 -keyable true $attCurve;
	
	string $stretchReaderPlsMns = abRTCreateNode("plusMinusAverage", ($prefix+"StretchReader"), "", "");
	string $squashReaderPlsMns = abRTCreateNode("plusMinusAverage", ($prefix+"SquashReader"), "", "");
	string $sqStrFalloffMltDiv = abRTCreateNode("multiplyDivide", ($prefix+"SqStrFalloff"), "", "");
	string $sqStrScalarMltDiv = abRTCreateNode("multiplyDivide", ($prefix+"SqStrScalar"), "", "");
	string $sqStrClamp = abRTCreateNode("clamp", ($prefix+"SqStr"), "", "");
	string $stretchCond = abRTCreateNode("condition", ($prefix+"Stretch"), "", "");
	string $squashCond = abRTCreateNode("condition", ($prefix+"Squash"), "", "");
	
	// stretch plsMns
	setAttr ($stretchReaderPlsMns+".operation") 2;
	setAttr ($stretchReaderPlsMns+".input1D[1]") 1;
	connectAttr ($attCurve+".stretchAmount") ($stretchReaderPlsMns+".input1D[0]");
	
	// squash plsMns
	setAttr ($squashReaderPlsMns+".operation") 2;
	setAttr ($squashReaderPlsMns+".input1D[0]") 1;
	connectAttr ($attCurve+".stretchAmount") ($squashReaderPlsMns+".input1D[1]");
	
	// squash stretch falloff
	setAttr ($sqStrFalloffMltDiv+".operation") 3;
	connectAttr ($attCurve+".stretchFalloff") ($sqStrFalloffMltDiv+".input2X");
	connectAttr ($attCurve+".squashFalloff") ($sqStrFalloffMltDiv+".input2Y");
	connectAttr ($stretchReaderPlsMns+".output1D") ($sqStrFalloffMltDiv+".input1X");
	connectAttr ($squashReaderPlsMns+".output1D") ($sqStrFalloffMltDiv+".input1Y");
	
	// squash stretch scalar
	connectAttr ($attCurve+".stretchScalar") ($sqStrScalarMltDiv+".input2X");
	connectAttr ($attCurve+".squashScalar") ($sqStrScalarMltDiv+".input2Y");
	connectAttr ($sqStrFalloffMltDiv+".outputX") ($sqStrScalarMltDiv+".input1X");
	connectAttr ($sqStrFalloffMltDiv+".outputY") ($sqStrScalarMltDiv+".input1Y");
	
	// clamp
	setAttr ($sqStrClamp+".min") 0 0 0;
	setAttr ($sqStrClamp+".max") 1 1 1;
	connectAttr ($sqStrScalarMltDiv+".outputX") ($sqStrClamp+".inputR");
	connectAttr ($sqStrScalarMltDiv+".outputY") ($sqStrClamp+".inputG");
	
	// stretch condition
	setAttr ($stretchCond+".operation") 3;
	setAttr ($stretchCond+".secondTerm") 1;
	setAttr ($stretchCond+".colorIfFalseR") 0;
	connectAttr ($attCurve+".stretchAmount") ($stretchCond+".firstTerm");
	connectAttr ($sqStrClamp+".outputR") ($stretchCond+".colorIfTrueR");
	
	// squash condition
	setAttr ($squashCond+".operation") 4;
	setAttr ($squashCond+".secondTerm") 1;
	setAttr ($squashCond+".colorIfFalseR") 0;
	connectAttr ($attCurve+".stretchAmount") ($squashCond+".firstTerm");
	connectAttr ($sqStrClamp+".outputG") ($squashCond+".colorIfTrueR");
	
	// connect to atts
	connectAttr ($stretchCond+".outColorR") ($attCurve+".stretchDriver");
	connectAttr ($squashCond+".outColorR") ($attCurve+".squashDriver");
	
	// connect twist
	string $twistReaderPlsMns = abRTCreateNode("plusMinusAverage", ($prefix+"TwistReader"), "", "");
	
	for ($i=1;$i<size($aCtrlCrvs);$i++) connectAttr -f ($aCtrlCrvs[$i]+".rx") ($twistReaderPlsMns+".input1D["+($i-1)+"]");
	
	connectAttr -f ($twistReaderPlsMns+".output1D") ($aSpineIkHandle[0]+".twist");
	
	// par constrain skeleton_grp to rootCon
	parentConstraint -mo $attCurve $scaleGrp;
	
	// connect masterScale to scaleGrp scale
	connectAttr -f ($attCurve+".masterScale") ($scaleGrp+".sx"); 
	connectAttr -f ($attCurve+".masterScale") ($scaleGrp+".sy"); 
	connectAttr -f ($attCurve+".masterScale") ($scaleGrp+".sz"); 
	
	// connect masterScale to each controlFrzGrp
	for ($obj in $aCtrlCrvGrps){
		connectAttr -f ($attCurve+".masterScale") ($obj+".sx"); 
		connectAttr -f ($attCurve+".masterScale") ($obj+".sy"); 
		connectAttr -f ($attCurve+".masterScale") ($obj+".sz"); 
	}
	
	abRTHideAttr($splineRootCon, {"sx","sy","sz","v"});
	
	// hide the curve
	setAttr ($curve+".v") 0;
	
	// throw it all in a group
	abRTParent($curve, $grp);
	abRTParent($aJnts[0], $scaleGrp);
	abRTParent($aSpineIkHandle[0], $grp);
	for ($obj in $aCtrlCrvGrps) abRTParent($obj, $grp);
	for ($obj in $aSpineClusterHandles) abRTParent($obj, $grp);
	
	if ($makeRoot)
		abRTParent(firstParentOf($splineRootCon), $grp);
	
	// reset global scale
	abRTSetGlobal("globalScale", $cScale);
	
	// scroll past warning and deselect everything
	print "\n\n";
	select -clear;
}


global proc string abRTGetNumToAlphaId(int $num){
	// returns a letter index based on a given number (a, b, c, ... aa, bb, cc, etc)
	
	string $alpha = "abcdefghijklmnopqrstuvwxyz";
	string $alphaId, $cAlpha;
	int $ind, $int, $i;
	
	// get alpha id
	$ind = $num%26;
	$int = floor(float($num)/26)+1;
	$cAlpha = substring($alpha, ($ind+1), ($ind+1));
	$alphaId = "";
	for ($i=0;$i<$int;$i++) $alphaId = $alphaId + $cAlpha;
	// done
	
	return $alphaId;
	
}


global proc abRTMakeIKStretchy(string $aJnts[], string $aIkJnts[], string $aFkJnts[], string $ikCtrl, string $statCtrl, string $stretchTarget, string $grp, string $limbName){
	
	// $aIkJnts {firstJnt, secondJnt, thirdJnt}
	// $ikCtrl is the ikCtrl that will have stretchy+$name attribute added to it
	// $statCtrl is the static control that will have $name+stretch attribute added to it
	// $stretchTarget is what the chain should be stretching to -- should be in same position as last joint in chain -- reverse ankle jnt or wrist control
	// $limbName is used to name nodes and add nodes to correct attribute of charVars.
	
	string $name;
	
	$name = $limbName;
	if (startsWith($limbName, "left")) $name = tolower(`substitute "left" $limbName ""`);
	else if (startsWith($limbName, "right")) $name = tolower(`substitute "right" $limbName ""`);
	
	string $prefix = abRTGetObjSide($aIkJnts[0]);
	int $mirroredBehavior = abRTJointMirroredBehavior($aJnts[1]);
	
	float $midJntTx = `getAttr ($aFkJnts[1]+".tx")`;
	float $endJntTx = `getAttr ($aFkJnts[2]+".tx")`;
	
	// create up stretch and low stretch attribute names (for leg you can break stretch into kneeStretch and ankleStretch)
	string $upStretchAmtAtt, $lowStretchAmtAtt;
	if ($name == "leg"){
		$upStretchAmtAtt = "kneeStretch";
		$lowStretchAmtAtt = "ankleStretch";
	}else if ($name == "arm"){
		$upStretchAmtAtt = "elbowStretch";
		$lowStretchAmtAtt = "wristStretch";
	}else{
		$upStretchAmtAtt = "upStretch";
		$lowStretchAmtAtt = "lowStretch";
	}
	
	string $refStrMultDiv = abRTCreateNode("multiplyDivide", ($name+"RefStr"), $prefix, $limbName);
	string $strAttPlsMns = abRTCreateNode("plusMinusAverage", ($name+"TotStrAmt"), $prefix, $limbName);
	string $lowJntStrPlsMns = abRTCreateNode("plusMinusAverage", ($name+"LowStr"), $prefix, $limbName);
	string $upJntStrPlsMns = abRTCreateNode("plusMinusAverage", ($name+"UpStr"), $prefix, $limbName);
	string $strDenomPlsMns = abRTCreateNode("plusMinusAverage", ($name+"StrDenom"), $prefix, $limbName);
	string $strNumMultDiv = abRTCreateNode("multiplyDivide", ($name+"StrNum"), $prefix, $limbName);
	string $strScalarMultDiv = abRTCreateNode("multiplyDivide", ($name+"StrScalar"), $prefix, $limbName);
	string $strClmp = abRTCreateNode("clamp", ($name+"Str"), $prefix, $limbName);
	string $strMultDiv = abRTCreateNode("multiplyDivide", ($name+"Str"), $prefix, $limbName);
	
	setAttr ($strScalarMultDiv+".operation") 2; // divide
	setAttr ($strClmp+".minR") 1;
	
	// make distance node
	string $aDist[] = abRTMakeDistanceDim({(abRTRigNamer(($name+"StrDist"),$prefix,"dist")),(abRTRigNamer(($name+"StrDist"),$prefix,"dist_sp")),(abRTRigNamer(($name+"StrDist"),$prefix,"dist_ep"))}, $aIkJnts[0], $aIkJnts[2], $grp);
	string $distShape = $aDist[3];
	abRTParent($aDist[1], $grp);
	abRTParent($aDist[2], $grp);
	pointConstraint $aIkJnts[0] $aDist[1];
	pointConstraint $stretchTarget $aDist[2];
	
	// adjust distance to current scale
	string $rootCtrl = abRTGetFromUI("rootCtrl");
	string $distanceNodeAtt;
	if ($rootCtrl == ""){
		$distanceNodeAtt = $distShape+".distance";
	}else{
		string $scaleDistMltDiv = abRTCreateNode("multiplyDivide", ($name+"DistScaleAdjust"), $prefix, $limbName);
		setAttr ($scaleDistMltDiv+".operation") 2;
		connectAttr ($distShape+".distance") ($scaleDistMltDiv+".input1X");
		connectAttr ($rootCtrl+".masterScale") ($scaleDistMltDiv+".input2X");
		$distanceNodeAtt = $scaleDistMltDiv+".outputX";
	}
	
	
	// create stretch attributes
	string $stretchyAtt = "stretchy"+capitalizeString($name);
	string $stretchAmtAtt = $name+"Stretch";
	addAttr -ln $stretchyAtt -at double -min 0 -max 1 -dv 0 -keyable true $ikCtrl;
	
	// make the stretch attr a bit less sensitive
	$stretchAttMultDiv  = abRTCreateNode("multiplyDivide", ($name+"StrAtt"), $prefix, $limbName);
	setAttr ($stretchAttMultDiv+".operation") 2; // divide
	setAttr ($stretchAttMultDiv+".input2") 10 10 10;
	addAttr -ln $stretchAmtAtt -at double -min -9.9 -max 20 -dv 0 -keyable true $statCtrl;
	
	addAttr -ln $upStretchAmtAtt -at double -min -9.9 -max 20 -dv 0 -keyable true $statCtrl;
	addAttr -ln $lowStretchAmtAtt -at double -min -9.9 -max 20 -dv 0 -keyable true $statCtrl;
	
	// create max stretch attribute
	addAttr -ln "maxStretch" -at double -min 1 -max 10 -dv 3 -keyable true $ikCtrl;
	connectAttr ($ikCtrl+".maxStretch") ($strClmp+".maxR");
	
	// start connecting
	// stretchAttMultDiv 
	connectAttr ($statCtrl+"."+$stretchAmtAtt) ($stretchAttMultDiv+".input1X");
	connectAttr ($statCtrl+"."+$upStretchAmtAtt) ($stretchAttMultDiv+".input1Y");
	connectAttr ($statCtrl+"."+$lowStretchAmtAtt) ($stretchAttMultDiv+".input1Z");
	
	// strAttPlsMns -- add full limb stretch and individual limb stretches together
	connectAttr ($stretchAttMultDiv+".outputX") ($strAttPlsMns+".input2D[0].input2Dx");
	connectAttr ($stretchAttMultDiv+".outputX") ($strAttPlsMns+".input2D[0].input2Dy");
	connectAttr ($stretchAttMultDiv+".outputY") ($strAttPlsMns+".input2D[1].input2Dx");
	connectAttr ($stretchAttMultDiv+".outputZ") ($strAttPlsMns+".input2D[1].input2Dy");
	
	// refStrMultDiv 
	connectAttr ($strAttPlsMns+".output2D.output2Dx") ($refStrMultDiv+".input1X");
	connectAttr ($strAttPlsMns+".output2D.output2Dy") ($refStrMultDiv+".input1Y");
	
	setAttr ($refStrMultDiv+".input2X") $midJntTx; // knee, elbow
	setAttr ($refStrMultDiv+".input2Y") $endJntTx; // ankle, wrist
	connectAttr ($refStrMultDiv+".outputX") ($upJntStrPlsMns+".input1D[0]");
	connectAttr ($refStrMultDiv+".outputY") ($lowJntStrPlsMns+".input1D[0]");
	
	// lowJntStrPlsMns 
	setAttr ($lowJntStrPlsMns+".input1D[1]") $endJntTx;
	connectAttr ($lowJntStrPlsMns+".output1D") ($aFkJnts[2]+".tx");
	connectAttr ($lowJntStrPlsMns+".output1D") ($strDenomPlsMns+".input1D[0]");
	connectAttr ($lowJntStrPlsMns+".output1D") ($strMultDiv+".input1Y");
	
	// upJntStrPlsMns 
	setAttr ($upJntStrPlsMns+".input1D[1]") $midJntTx;
	connectAttr ($upJntStrPlsMns+".output1D") ($aFkJnts[1]+".tx");
	connectAttr ($upJntStrPlsMns+".output1D") ($strDenomPlsMns+".input1D[1]");
	connectAttr ($upJntStrPlsMns+".output1D") ($strMultDiv+".input1X");
	
	// strNumMultDiv 
	connectAttr $distanceNodeAtt ($strNumMultDiv+".input1X");
	connectAttr ($ikCtrl+"."+$stretchyAtt) ($strNumMultDiv+".input2X");
	connectAttr ($strNumMultDiv+".outputX") ($strScalarMultDiv+".input1X");
	
	// strDenomPlsMns
	connectAttr ($strDenomPlsMns+".output1D") ($strScalarMultDiv+".input2X");
	
	// strScalarMultDiv
	if ($mirroredBehavior && $prefix == "r"){
		// if behavior has been mirrored on the skeleton and this limb is on the right side, then the tx translations have to be reversed
		
		string $negateTxMltDiv = abRTCreateNode("multiplyDivide", ($name+"NegateTx"), $prefix, $limbName);
		setAttr ($negateTxMltDiv+".input2X") -1;
		connectAttr ($strScalarMultDiv+".outputX") ($negateTxMltDiv+".input1X");
		connectAttr ($negateTxMltDiv+".outputX") ($strClmp+".inputR");
	}else{
		connectAttr ($strScalarMultDiv+".outputX") ($strClmp+".inputR");
	}
	
	// strClmp
	connectAttr ($strClmp+".outputR") ($strMultDiv+".input2X");
	connectAttr ($strClmp+".outputR") ($strMultDiv+".input2Y");
	
	// strMultDiv
	connectAttr ($strMultDiv+".outputX") ($aIkJnts[1]+".tx");
	connectAttr ($strMultDiv+".outputY") ($aIkJnts[2]+".tx");
	
	
	// expose stretch percentage for attaching volume blendshapes or other deformers
	// create and connect stretchValue attribute
	
	addAttr -ln "stretchValue" -at double -keyable false $ikCtrl;
	setAttr -cb true ($ikCtrl+".stretchValue");
	
	connectAttr ($strClmp+".outputR") ($ikCtrl+".stretchValue");
	
}


global proc string[] abRTMakeDistanceDim(string $aNames[], string $spObj, string $epObj, string $grp){
	/*
	Creates a distanceDim node named $aNames[1], with startpoint named $aNames[1], and endpoint named $aName[2]
	startPoint is located at $spPob, endPoint is located at $epObj
	locs and distanceDim are placed in $grp
	returns {distanceDimName, startPointLocName, endPointLocName, distanceDimShapeName} 
	*/
	
	string $aRet[], $aStr[];
	
	string $distanceDimShape = `distanceDimension -sp 12 -24 -40 -ep 13 -20 -40`; // distanceDimension seems not to create a new loc if there's an existing loc at the same point in space -- strange.
	
	// get sp and ep locs
	string $attStr = `connectionInfo -sourceFromDestination ($distanceDimShape+".startPoint")`;
	string $spLocShape = `match "[A-Za-z0-9_]+" $attStr`;
	$attStr = `connectionInfo -sourceFromDestination ($distanceDimShape+".endPoint")`;
	string $epLocShape = `match "[A-Za-z0-9_]+" $attStr`;
	
	$aStr = `listRelatives -p -fullPath -type transform $distanceDimShape`;
	string $distanceDim = $aStr[0];
	$aStr = `listRelatives -p -fullPath -type transform $spLocShape`;
	string $spLoc = $aStr[0];
	$aStr = `listRelatives -p -fullPath -type transform $epLocShape`;
	string $epLoc = $aStr[0];
	
	// snap the locs to the appropriate location
	select -r $spObj $spLoc;
	abRTPointOrient(1);
	select -r $epObj $epLoc;
	abRTPointOrient(1);
	
	if ($aNames[0] != ""){
		$aStr = abRTRename($distanceDim, $aNames[0]);
		$distanceDim = $aStr[1];
	}
	if ($aNames[1] != ""){
		$aStr = abRTRename($spLoc, $aNames[1]);
		$spLoc = $aStr[1];
	}
	if ($aNames[2] != ""){
		$aStr = abRTRename($epLoc, $aNames[2]);
		$epLoc = $aStr[1];
	}
	if ($grp != "" && `objExists $grp`){
		$distanceDim = abRTParent($distanceDim, $grp);
		$spLoc = abRTParent($spLoc, $grp);
		$epLoc = abRTParent($epLoc, $grp);
	}
	
	$aStr = `listRelatives -type shape $distanceDim`;
	$distanceDimShape = $aStr[0];
	
	// make it invisible
	setAttr ($distanceDim+".v") 0;
	setAttr ($spLoc+".v") 0;
	setAttr ($epLoc+".v") 0;
	
	$aRet[size($aRet)] = $distanceDim; 
	$aRet[size($aRet)] = $spLoc;
	$aRet[size($aRet)] = $epLoc;
	$aRet[size($aRet)] = $distanceDimShape;
	
	return $aRet;
}


global proc string[] abRTAddFkControls(string $aJnts[], string $aRootNames[], int $aJntsToAlign[], string $fkChainUpJnt, string $localAlignParentJnt, string $wireType, string $ctrlGrp, string $limbName){
	/*
	adds controls to a joints (in a chain) specified in $aJnts, names them using $aRootNames, and places them in $ctrlGrp 
	$aJntsToAlign is joints (by index in $aJnts) to add the align attribute to
	$fkChainUpJnt is joint to parent $aJnts[0] to
	$localAlignParentJnt is joint to use as parent space for local align (can be "")
	$wireType is wire to use for controls ("circle", "sphere") -- it must be a valid type.  The orientation of the wire can also be specified with "|" to catenate, and then 0-5 for the orientation, in the form of "circle|1".
	$limbName is name of attribute in charVars to record newly created nodes (for rig removal)
	first control in $aJnts will have align attribute
	returns array {joint1, ctrlCurve1, joint2, ctrlCurve2}
	*/
	
	int $i, $wireOrientation;
	float $ctrlSize, $jntRadius, $aFlt[];
	string $aRet[], $aRel[], $ctrl, $jnt, $parFrzGrp, $ptFrzGrp, $upJnt, $prefix, $ptCons, $parCons, $orCons, $parConsWeightAttr, $orConsWeightAttr, $plsMnsAvg, $aStr[];
	string $str, $alignOffsetGrp, $armAutoAlignBlnd;
	string $rootCtrl = abRTGetFromUI("rootCtrl");
	
	// get wireOrientation
	$aStr = stringToStringArray($wireType, "|");
	if (size($aStr) == 1){
		$wireOrientation = 0;
	}else if (size($aStr) == 2){
		$wireType = $aStr[0];
		$wireOrientation = int($aStr[1]);
	}
	
	if (size($aJnts) > 0){
		
		$prefix = abRTGetObjSide($aJnts[0]);
		
		for ($i=(size($aJnts)-1);$i>=0;$i--){
			
			// work backwards down the chain
			$jnt = $aJnts[$i];
			
			// create curve
			$jntRadius = `getAttr ($jnt+".radius")`;
			$ctrlSize = 6 * $jntRadius + 8;
			
			$ctrl = abRTMakeWireController($wireType, $wireOrientation, {}, $ctrlSize);
			
			// put in ctrlGrp
			if ($ctrlGrp != "" && `objExists $ctrlGrp`)
				$ctrl = abRTParent($ctrl, $ctrlGrp);
			
			// rename it
			$aStr = abRTRename($ctrl, abRTRigNamer($aRootNames[$i], $prefix, "fkCtrl"));
			$ctrl = $aStr[1];
			
			// snap to joint
			abRTSnapToPosition($jnt, $ctrl);
			
			$aRel = `listRelatives -p -fullPath -type joint $jnt`;
			$upJnt = (size($aRel) == 1) ? $aRel[0] : "";
			
			// add attribute to change rotate order
			setAttr -lock false -channelBox true ($ctrl+".rotateOrder");
			
			if ($i == 0 && $fkChainUpJnt != ""){
				$upJnt = $fkChainUpJnt;
			}
			
			
			if ($upJnt == ""){
				parentConstraint $ctrl $jnt;
				continue;
			}
			
			int $addAlignAtt = (abRTGetPosInIntArray($i, $aJntsToAlign) != -1);
			
			if (!$addAlignAtt){
				
				// make null parented to upJnt, positioned at current joint
				string $upJntNull = `group -em -w -n (abRTRigNamer(($aRootNames[$i]+"_upJntFkCtrl"), $prefix, "grp"))`;
				abRTSnapToPosition($jnt, $upJntNull);
				
				if ($ctrlGrp != "" && `objExists $ctrlGrp`)
					$upJntNull = abRTParent($upJntNull, $ctrlGrp);
				
				parentConstraint -mo $upJnt $upJntNull;
				
				// groupFrz ctrl twice then pointConstrain bottom frzGrp to jnt (orient to upJntNull)
				$ctrl = abRTGroupFreezeReturnObj($ctrl, true);
				$ctrl = abRTGroupFreezeReturnObj($ctrl, true);
				
				// ctrlFrzGrp it the one that gets rotated
				$ctrlFrzGrp = firstParentOf($ctrl);
				$parFrzGrp = firstParentOf($ctrlFrzGrp);
				
				pointConstraint $jnt $parFrzGrp;
				
				orientConstraint $upJntNull $ctrlFrzGrp;
				
			}else{
				
				$ctrl = abRTSetUpFkAlignJntCtrl($ctrl, $jnt, $upJnt, $localAlignParentJnt, $aRootNames[$i], $prefix, $ctrlGrp, $limbName, true);
			}
			
			// constrain jnt to ctrl
			orientConstraint $ctrl $jnt;
			
			abRTHideAttr($ctrl, {"tx","ty","tz","sx","sy","sz","v"});
			
			$aRet[$i*2] = $jnt;
			$aRet[$i*2+1] = $ctrl;
		}
	}
	
	return $aRet;
	
}


global proc string abRTSetUpFkAlignJntCtrl(string $ctrl, string $jnt, string $upJnt, string $localAlignParentJnt, string $rootName, string $prefix, string $ctrlGrp, string $limbName, int $useRootCtrlOffset){
	// sets up an FK joint control ($ctrl) for joint $jnt with an align attribute on $ctrl
	// $upJnt is next joint up in the chain (or object to parent to)
	// $localAlignParentJnt is the jnt space that the local align will be relative to (spineHi for arm, spineLow for leg).  Can be empty.
	// $rootName is base name to use
	// $ctrlGrp is grp to place the controls in
	// $useRootCtrlOffset (bool), if true, will adjust for rootCon rotations while ctrl is in fkAlign mode (not always needed)
	// returns new control position in hierarchy (inside a couple of frzGrps)
	
	string $aStr[], $str, $ret;
	string $rootCtrl = ($useRootCtrlOffset) ? abRTGetFromUI("rootCtrl") : "";
	
	if ($localAlignParentJnt != ""){
		if (!objExists($localAlignParentJnt)){
			$localAlignParentJnt = "";
		}
	}
	
	// make null parented to upJnt, positioned at current joint
	string $upJntNull = `group -em -w -n (abRTRigNamer(($rootName+"_upJntFkCtrlAlign"), $prefix, "grp"))`;
	abRTSnapToPosition($jnt, $upJntNull);
	
	if ($ctrlGrp != "" && `objExists $ctrlGrp`)
		$upJntNull = abRTParent($upJntNull, $ctrlGrp);
	
	
	parentConstraint -mo $upJnt $upJntNull;
	
	// groupFrz ctrl twice then pointConstrain bottom frzGrp to jnt (orient to upJntNull)
	$ctrl = abRTGroupFreezeReturnObj($ctrl, true);
	$ctrl = abRTGroupFreezeReturnObj($ctrl, true);
	
	// ctrlFrzGrp it the one that gets rotated
	string $ctrlFrzGrp = firstParentOf($ctrl);
	string $parFrzGrp = firstParentOf($ctrlFrzGrp);
	
	pointConstraint $jnt $parFrzGrp;
	
	// make 2 grps that ctrlFrzGrp will be orientConstrained to, one aligned and one not
	string $alignFalseGrp = `group -em -w -n (abRTRigNamer(($rootName+"_alignFalse"), $prefix, "grp"))`;
	string $alignTrueGrp = `group -em -w -n (abRTRigNamer(($rootName+"_alignTrue"), $prefix, "grp"))`;
	
	// two grps that will be target for align (two types of align, world and local)
	string $alignTrueWorldTargGrp, $alignTrueLocalTargGrp;
	$alignTrueWorldTargGrp = `group -em -w -n (abRTRigNamer(($rootName+"_alignTrueWrldTarg"), $prefix, "grp"))`;
	if ($localAlignParentJnt != "")
		$alignTrueLocalTargGrp = `group -em -w -n (abRTRigNamer(($rootName+"_alignTrueLocTarg"), $prefix, "grp"))`;
	
	abRTSnapToPosition($jnt, $alignTrueGrp);
	abRTSnapToPosition($jnt, $alignFalseGrp);
	abRTSnapToPosition($jnt, $alignTrueWorldTargGrp);
	if ($localAlignParentJnt != "")
		abRTSnapToPosition($localAlignParentJnt, $alignTrueLocalTargGrp);
	
	$alignFalseGrp = abRTParent($alignFalseGrp, $parFrzGrp);
	$alignTrueGrp = abRTParent($alignTrueGrp, $parFrzGrp);
	$alignTrueWorldTargGrp = abRTParent($alignTrueWorldTargGrp, $parFrzGrp);
	if ($localAlignParentJnt != "")
		$alignTrueLocalTargGrp = abRTParent($alignTrueLocalTargGrp, $parFrzGrp);
	
	// grpFreeze alignFalseGrp and parent
	$alignFalseGrp = abRTGroupFreezeReturnObj($alignFalseGrp, true);
	string $alignFalseGrpFrz = firstParentOf($alignFalseGrp);
	
	parentConstraint -mo $upJntNull $alignFalseGrpFrz;
	
	if ($localAlignParentJnt != ""){
		
		// grpFreeze local target grp and snap it to jnt (and grpFreeze again) and constrain
		$alignTrueLocalTargGrp = abRTGroupFreezeReturnObj($alignTrueLocalTargGrp, true);
		abRTSnapToPosition($jnt, $alignTrueLocalTargGrp);
		$alignTrueLocalTargGrp = abRTGroupFreezeReturnObj($alignTrueLocalTargGrp, true);
		
		parentConstraint $localAlignParentJnt (firstParentOf(firstParentOf($alignTrueLocalTargGrp)));
		pointConstraint $jnt (firstParentOf($alignTrueLocalTargGrp));
	}
	
	
	if ($rootCtrl != ""){
		string $autoAlignGrp = `group -em -name (abRTRigNamer(($rootName+"_autoAlign"), $prefix, "rigGrp"))`;
		
		// snap group to first fkJnt
		$aStr = `pointConstraint -offset 0 0 0 -weight 1 $jnt $autoAlignGrp`;
		for ($str in $aStr)
			delete $str;
		
		// put it in $parFrzGrp and parent alignTrueGrp to it
		$autoAlignGrp = abRTParent($autoAlignGrp, $parFrzGrp);
		$autoAlignGrp  = abRTGroupFreezeReturnObj($autoAlignGrp, true);
		$alignTrueWorldTargGrp = abRTParent($alignTrueWorldTargGrp, $autoAlignGrp);
		
		connectAttr ($rootCtrl+".r") ($autoAlignGrp+".r");
	}
	
	
	// orient constrain $alignTrueGrp to $alignTrueWorldTargGrp and $alignTrueLocalTargGrp
	string $alignTrueWorldOrWtAtt, $alignFalseLocalOrWtAtt;
	
	if ($localAlignParentJnt != ""){
		
		$aStr = `orientConstraint $alignTrueWorldTargGrp $alignTrueLocalTargGrp $alignTrueGrp`;
		string $alignTrueOrCons = $aStr[0];
		
		$aStr = `orientConstraint -q -wal $alignTrueOrCons`;
		
		$alignTrueWorldOrWtAtt = $alignTrueOrCons+"."+$aStr[0];
		$alignFalseLocalOrWtAtt = $alignTrueOrCons+"."+$aStr[1];
		
	}else{
		
		// no localAlignParent, so just align alignTrueGrp to follow alignTrueWorldTargGrp (which is the actual align group)
		orientConstraint $alignTrueWorldTargGrp $alignTrueGrp;
	}
	
	
	// orient constrain ctrlFrzGrp to align true and false grps
	$aStr = `orientConstraint $alignTrueGrp $alignFalseGrp $ctrlFrzGrp`;
	string $orCons = $aStr[0];
	
	$aStr = `orientConstraint -q -wal $orCons`;
	
	string $alignTrueOrWtAtt = $orCons+"."+$aStr[0];
	string $alignFalseOrWtAtt = $orCons+"."+$aStr[1];
	
	// add align attributes and connect them
	addAttr -ln "align" -at double -dv 0 -min 0 -max 1 -keyable true $ctrl;
	connectAttr ($ctrl+".align") $alignTrueOrWtAtt;
	
	// need to create plusMins to reverse align which is plugged into parent constraint
	string $plsMnsAvg  = abRTCreateNode("plusMinusAverage", $rootName, $prefix, $limbName);
	setAttr ($plsMnsAvg+".input1D[0]") 1;
	setAttr ($plsMnsAvg+".operation") 2;
	connectAttr ($ctrl+".align") ($plsMnsAvg+".input1D[1]");
	connectAttr ($plsMnsAvg+".output1D") $alignFalseOrWtAtt;
	
	// do the same for local align att, which blends between localAlignTargetGrp orient constraints
	if ($localAlignParentJnt != ""){
		
		// add align attributes and connect them
		addAttr -ln "localAlign" -at double -dv 1 -min 0 -max 1 -keyable true $ctrl;
		connectAttr ($ctrl+".localAlign") $alignFalseLocalOrWtAtt;
		
		// need to create plusMins to reverse align which is plugged into parent constraint
		string $alignTruePlsMnsAvg  = abRTCreateNode("plusMinusAverage", ($rootName+"AlignTrue"), $prefix, $limbName);
		setAttr ($alignTruePlsMnsAvg+".input1D[0]") 1;
		setAttr ($alignTruePlsMnsAvg+".operation") 2;
		connectAttr ($ctrl+".localAlign") ($alignTruePlsMnsAvg+".input1D[1]");
		connectAttr ($alignTruePlsMnsAvg+".output1D") $alignTrueWorldOrWtAtt;
	}
	
	
	return $ctrl;
}


global proc string abRTMakeIkHandle(string $startJnt, string $endJnt, string $name, string $parent, string $grp){
	// creates an IK handle 
	
	string $aStr[], $ikHandle;
	
	$aStr = `ikHandle -n $name -solver "ikRPsolver" -startJoint $startJnt -endEffector $endJnt`;
	$ikHandle = $aStr[0];
	
	if ($grp != "") $ikHandle = abRTParent($ikHandle, $grp);
	
	if ($parent != "") parentConstraint -mo $parent $ikHandle;
	
	setAttr ($ikHandle+".v") 0;
	
	return $ikHandle;
}


global proc string abRTMakeLocator(string $name){
	// creates a locator named $name.  returns full path to locator
	
	string $ret;
	string $aStr[] = `spaceLocator`;
	$aStr = abRTRename($aStr[0], $name);
	$ret = $aStr[1];
	return $ret;
	
}


global proc string abRTMakeLocatorV2(string $name, string $snapToTarget, string $grp){
	// creates a locator named $name in the position of $snapToTarget, and puts it in $grp;  returns full path to locator
	
	string $ret;
	
	string $aStr[] = `spaceLocator`;
	
	$aStr = abRTRename($aStr[0], $name);
	$ret = $aStr[1];
	
	if (objExists($snapToTarget))
		abRTSnapToPosition($snapToTarget, $ret);
	
	if (objExists($grp))
		$ret = abRTParent($ret, $grp);
	
	return $ret;
}


global proc abRTShowAttr(string $obj, string $aAttr[]){
	// unlocks and makes keyable $obj's attributes in $aAttr
	
	string $attr, $objAttr;
	     
	for ($attr in $aAttr){
		$objAttr = $obj+"."+$attr;
		setAttr -lock false $objAttr;
		setAttr -keyable true $objAttr;
		setAttr -channelBox true $objAttr;
	}
}


global proc abRTHideAttr(string $obj, string $aAttr[]){
	// hides $obj's attributes in $aAttr
	
	string $attr, $objAttr;
	string $aLock[] = {"tx","ty","tz","rx","ry","rz","sx","sy","sz"}; // these atts are locked if encountered in $aAttr
	
	for ($attr in $aAttr){
		
		if (!attributeExists($attr, $obj))
			continue;
		
		$objAttr = $obj+"."+$attr;
		setAttr -keyable false $objAttr;
		setAttr -channelBox false $objAttr;
		if (abRTGetPosInStrArray($attr, $aLock) != -1) setAttr -lock true $objAttr; // only need to lock t, r, and s
	}
}


global proc string[] abRTMakePvControl(string $aIkJnts[], string $ikHandle, string $bindJnt, int $offsetDir, string $nameRoot, string $ctrlGrp){
	/*
	makes a pv control for joint chain where $aIkJnts[1] is the joint in the middle of the ik chain, $ikHandle is the ikHandle
	$offsetDir is direction to offset ==> +x,+y,+z,-x,-y,-z == 0,1,2,3,4,5
	$bindJnt is the joint connected to the pv control with a line
	$nameRoot is desired rootname of newly created pv -- "elbow", "arm", "knee", whatever -- will be combined with prefix and charname to make a unique name
	$ctrlGrp is group to place pv and pv group in
	returns string[] {pvControlPath, pvConstraintName, pvControlPathGrp, pvLine(annotation)}
	*/
	
	string $aRet[], $aStr[], $placeInGrp, $jnt;
	string $prefix = abRTGetObjSide($aIkJnts[0]);
	float $aTrans[], $aTrans2[], $aJntTrans[];
	int $facingAxis;
	
	if (size($aIkJnts) < 3) return $aRet;
	
	float $aIKUpLegTrans[] = `joint -q -p -a $aIkJnts[0]`;
	float $aIKKneeTrans[] =`joint -q -p -a $aIkJnts[1]`;
	float $pvOffset = sqrt(pow(($aIKUpLegTrans[0] - $aIKKneeTrans[0]), 2) + pow(($aIKUpLegTrans[1] - $aIKKneeTrans[1]), 2) + pow(($aIKUpLegTrans[2] - $aIKKneeTrans[2]), 2));
	
	// get bind joint orientation
	$facingAxis = $offsetDir;
	
	// make pv control
	string $pvCtrl = abRTMakeWireController("sphere", $facingAxis, {}, 4);
	$aStr = abRTRename($pvCtrl, abRTRigNamer($nameRoot, $prefix, "pvCtrl"));
	$pvCtrl = $aStr[1];
	
	$pvCtrl = abRTParent($pvCtrl, $ctrlGrp);
	
	// align with startJnt
	abRTSnapToPosition($aIkJnts[0], $pvCtrl);
		
	float $scale = float(abRTGetGlobal("globalScale"));
	
	// make 1 degree curve snapped to joints to determine pv location
	string $curveCmd = "curve -d 1";
	
	for ($i=0;$i<3;$i++){
		$aJntTrans = `joint -q -p $aIkJnts[$i]`;
		$curveCmd += " -p "+$aJntTrans[0]+" "+$aJntTrans[1]+" "+$aJntTrans[2];
	}
	
	string $curve = eval($curveCmd);
	
	select -r ($curve+".cv[1]");
	moveVertexAlongDirection -n $pvOffset;
	select -clear;
	
	$aTrans = `xform -q -ws -t ($curve+".cv[1]")`;
	xform -ws -t $aTrans[0] $aTrans[1] $aTrans[2] $pvCtrl;
	
	delete $curve;
	
	// freeze pvCtrl transforms
	makeIdentity -apply true -t 1 -r 1 -s 1 $pvCtrl;
	
	string $pvGrp = abRTGroupFreeze($pvCtrl, 1);
	$pvCtrl = $pvGrp+"|"+abRTStripPath($pvCtrl);
	
	$aStr = `poleVectorConstraint -name (abRTRigNamer($nameRoot, $prefix, "pvCons")) $pvCtrl $ikHandle`;
	string $pvCons = $aStr[0];
	
	string $bindJntLoc = abRTMakeLocator(abRTRigNamer($nameRoot, $prefix, "lineLoc"));
	$bindJntLoc = abRTParent($bindJntLoc, $pvGrp);
	pointConstraint $bindJnt $bindJntLoc;
	string $line = abRTConnectWithLine($bindJntLoc, $pvCtrl);
	
	// make it semi-invisible
	setAttr ($bindJntLoc+".s") .01 .01 .01;
	
	// hide undesired attributes
	abRTHideAttr($pvCtrl, {"rx","ry","rz","sx","sy","sz","v"});
	
	// fill aRet[]
	$aRet[size($aRet)] = $pvCtrl;
	$aRet[size($aRet)] = $pvCons;
	$aRet[size($aRet)] = $pvGrp;
	$aRet[size($aRet)] = $line;
	$aRet[size($aRet)] = $bindJntLoc;
	
	return $aRet;
	
}


global proc string[] abRTGetRigGrpCtrlCurves(string $rigGrp){
	// returns all control curves in $rigGrp 
	
	if (!objExists($rigGrp) || `nodeType $rigGrp` != "transform") return {};
	
	string $charName = abRTStripPath(`substitute "_rig_grp" $rigGrp ""`);
	string $aCurves[] = `ls -type transform ($charName+"_*_ctrl")`;
	return $aCurves;
}


global proc abRTMakeCharSetFromSel(){
	// returns animatable nurbsCurve attributes of all children of selected transform
	
	string $rigGrpSuffix = "_rig_grp";
	string $rigGrp = abRTGetRigGrpFromSelCtrl("");
	
	if ($rigGrp != ""){
		
		string $aCSel[] = `ls -sl`;
		
		string $aCurves[] = abRTGetRigGrpCtrlCurves($rigGrp);
		string $aStr[], $curve;
		
		select -r $aCSel;
		
		if (size($aCurves) == 0){
			warning "Unable to find any valid control curves.  You didn't rename anything, did you?";
			return;
		}
		
		string $name = "abAutoRigChar";
		
		if (endsWith($rigGrp, $rigGrpSuffix) && size($rigGrp) > size($rigGrpSuffix)){
			$name = shortNameOf($rigGrp);
			$name = `substitute $rigGrpSuffix $rigGrp ""`;
		}
		
		// strip out rigSettings (doesn't need to be keyed)
		for ($curve in $aCurves){
			if (`match "_rigSettings_" $curve` == "_rigSettings_") continue;
			$aStr[size($aStr)] = $curve;
		}
		$aCurves = $aStr;
		
		$name += "_cs";
		
		$name = `character -n $name $aCurves`;
		
		if ($name != "") print ("Created character set "+$name);
	}
	
}


global proc abRTArraySetAtt(string $type, string $nodeAtt, string $aStr[], int $aInt[]){
	// sets $nodeAtt (string or int32 array) to values in $aStr or $aInt
	// $nodeAtt is in form of node.att
	
	string $cmd;
	int $int, $i;
	
	if ($type == "stringArray"){
		
		if (size($aStr) > 0){
			for ($i=0;$i<size($aStr);$i++) $aStr[$i] = substituteAllString($aStr[$i], "\"", "\\\"");
			$cmd = "setAttr -type \"stringArray\" "+$nodeAtt+" "+size($aStr)+" \""+stringArrayToString($aStr, "\" \"")+"\";";
		}
		
	}else if ($type == "Int32Array"){
		
		if (size($aInt) > 0){
			$cmd = "setAttr -type \"Int32Array\" "+$nodeAtt+" "+size($aInt);
			for ($int in $aInt) $cmd += " "+$int;
		}
		$cmd += ";";
		
	}
	
	eval $cmd;
}


global proc abRTMakeAbxPickerUI(){
	// a UI for creating an abxPickerNode
	
	string $aCharSheets[], $charSheet;
	
	$aCharSheets = {"Original", "Advanced"};
	int $lmargin = 3;
	int $rmargin = 3;
	
	if (`window -exists abRTMkPkrWin`) deleteUI -window abRTMkPkrWin;
	
	window -t "Create Char Sheet" -w 175 -h 160 -menuBar false -minimizeButton false -maximizeButton false abRTMkPkrWin;
	
	formLayout -numberOfDivisions 100 abRTMkPkrForm;
	
	text -l "Character Sheet Template" abRTMkPkrTxt;
	
	textScrollList -allowMultiSelection false abRTMkPkrTxtScrllLst;
	
	for ($charSheet in $aCharSheets)
		textScrollList -e -a $charSheet abRTMkPkrTxtScrllLst;
	
	textScrollList -e -sii 1 abRTMkPkrTxtScrllLst;
	
	separator abRTMkPkrSep;
	button -label "Create Character Sheet" -h 28 -command "string $abRTgaStr[] = `textScrollList -q -si abRTMkPkrTxtScrllLst`; abRTMakeAbxPickerForSelCtrl($abRTgaStr[0]);" abRTMkPkrBn;
	
	formLayout -e
	
	-af abRTMkPkrTxt top 7
	-af abRTMkPkrTxt left ($lmargin*2)
	
	-af abRTMkPkrBn bottom 4
	-af abRTMkPkrBn left $lmargin
	-af abRTMkPkrBn right $rmargin
	
	-ac abRTMkPkrSep bottom 4 abRTMkPkrBn
	-af abRTMkPkrSep left $lmargin
	-af abRTMkPkrSep right $rmargin
	
	-ac abRTMkPkrTxtScrllLst bottom 4 abRTMkPkrSep
	-ac abRTMkPkrTxtScrllLst top 9 abRTMkPkrTxt
	-af abRTMkPkrTxtScrllLst left $lmargin
	-af abRTMkPkrTxtScrllLst right $rmargin
	
	abRTMkPkrForm
	;
	
	showWindow abRTMkPkrWin;
	
}


global proc abRTMakeAbxPickerForSelCtrl(string $charSheet){
	// select a control on a char, run this, and you'll get a fun new character sheet for abxPicker
	// $charSheet can be "Original" or "Advanced".
	
	string $charName = abRTGetCharNameFromCtrl("", false);
	
	if ($charName == "")
		return;
	
	string $pikrName = substituteAllString($charName, "_", "")+"_PIKR";
	
	if (objExists($pikrName)) delete $pikrName;
	
	abRTMakeAbxPickerNode($charName, $charSheet);
	
}


global proc abRTMakeAbxPickerNode(string $charName, string $charSheet){
	// creates a geometryVarGroup node with info for prebuild picker sheet (using abxPicker)
	// can choose different character sheets with different $charsheets
	
	int $i, $size, $aWidth[], $aHeight[], $charPrefix, $mirrorPicker;
	float $pickerScale;
	string $aStr[], $aData[], $aOverlay[], $aCommand[], $aImage[], $aLabel[], $cn, $ns;
	string $strippedCharName = substituteAllString($charName, "_", "");
	string $node = `createNode geometryVarGroup -n ($strippedCharName+"_PIKR")`;
	
	string $lcs = tolower($charSheet);
	
	// separate charName and nameSpace (if any)
	$aStr = stringToStringArray($charName, ":");
	
	if (size($aStr) == 2){
		
		$cn = $aStr[1];
		$ns = $aStr[0];
	}else{
		$cn = $charName;
	}
	
	if (tolower($lcs) == "advanced"){
		
		$size = 96;
		$aData = {"281:122:0.5:0.75:1","38:122:1:0.5:0.5","62:122:1:0:0","259:122:0:0.5:1","88:147:1:0.5:1","228:147:0:1:1","88:123:1:0:0","228:122:0:0.5:1","121:123:1:0:0","194:123:0:0.5:1","146:212:1:1:0","123:229:1:1:0","154:253:1:1:0","149:48:0.5:0.75:1","158:109:1:1:0","135:35:0:0.75:0.75","191:164:0.38:0.75:0","135:49:0:0.75:0.75","185:49:0:0.75:0.75","203:342:0.5:0.75:1","89:286:1:0.5:1","223:286:0:1:1","194:108:0:1:1","66:320:0.6:0.6:0.6","241:320:0.6:0.6:0.6","304:122:0.6:0.6:0.6","10:122:0.6:0.6:0.6","110:273:1:0:0","110:298:1:0:0","110:320:1:0:0","90:320:1:0:0","223:320:0:0.5:1","203:320:0:0.5:1","203:298:0:0.5:1","203:271:0:0.5:1","135:276:0.38:0.75:0","185:277:0.38:0.75:0","273:142:0.5:0.75:1","98:360:0.2:0.2:0.2","156:77:0.4:0.5:0.7","194:143:0.5:0.75:1","147:182:1:1:0","147:153:1:1:0","121:108:0:1:1","122:144:1:0.5:0.5","193:249:0.5:0.75:1","122:251:1:0.5:0.5","246:340:0.4:0.5:0.7","89:341:1:0.5:0.5","67:340:0.7:0.4:0.4","10:143:1:0.5:0.5","261:163:0.4:0.5:0.7","254:180:0.4:0.5:0.7","249:197:0.4:0.5:0.7","276:163:0.4:0.5:0.7","290:163:0.4:0.5:0.7","304:163:0.4:0.5:0.7","318:163:0.4:0.5:0.7","276:180:0.4:0.5:0.7","276:198:0.4:0.5:0.7","290:180:0.4:0.5:0.7","290:198:0.4:0.5:0.7","304:181:0.4:0.5:0.7","304:198:0.4:0.5:0.7","318:181:0.4:0.5:0.7","318:198:0.4:0.5:0.7","244:215:0.4:0.5:0.7","271:221:0.4:0.5:0.7","288:221:0.4:0.5:0.7","304:221:0.4:0.5:0.7","320:221:0.4:0.5:0.7","63:164:0.7:0.4:0.4","69:180:0.7:0.4:0.4","48:164:0.7:0.4:0.4","34:164:0.7:0.4:0.4","20:164:0.7:0.4:0.4","6:164:0.7:0.4:0.4","76:196:0.7:0.4:0.4","6:180:0.7:0.4:0.4","6:196:0.7:0.4:0.4","20:180:0.7:0.4:0.4","20:196:0.7:0.4:0.4","34:180:0.7:0.4:0.4","34:196:0.7:0.4:0.4","48:180:0.7:0.4:0.4","48:196:0.7:0.4:0.4","73:216:0.7:0.4:0.4","51:221:0.7:0.4:0.4","35:221:0.7:0.4:0.4","19:221:0.7:0.4:0.4","3:221:0.7:0.4:0.4","4:6:0.4:0.7:0.4","226:107:0.4:0.7:0.4","60:108:0.4:0.7:0.4","227:6:0.6:0.6:0.6","248:33:0.6:0.6:0.6"};
		$aWidth = {16,16,16,16,16,16,16,16,16,16,36,86,21,32,13,61,9,11,11,38,16,16,16,21,21,21,21,16,16,16,16,16,16,16,16,9,10,53,132,16,16,36,36,16,16,16,16,16,38,16,53,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,16,13,13,13,13,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,16,13,13,13,13,62,47,47,108,87};
		$aHeight = {16,16,16,16,16,16,16,16,16,16,12,16,16,21,28,8,52,10,10,14,16,16,11,16,16,16,16,16,16,16,16,16,16,16,16,34,34,15,14,16,16,12,12,11,16,16,16,16,14,16,15,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,16,15,15,15,15,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,16,15,15,15,15,21,11,11,22,19};
		$aOverlay = {"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""};
		$aCommand = {"abxPickerSelect \" @_lf_arm_ik_ctrl\"","abxPickerSelect \" @_rt_arm_ik_ctrl\"","abxPickerSelect \" @_rt_wrist_fk_ctrl\"","abxPickerSelect \" @_lf_wrist_fk_ctrl\"","abxPickerSelect \" @_rt_elbow_pv_ctrl\";setToolTo moveSuperContext","abxPickerSelect \" @_lf_elbow_pv_ctrl\";setToolTo moveSuperContext","abxPickerSelect \" @_rt_elbow_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_elbow_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_rt_upArm_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_upArm_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_spineLow_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_cog_ctrl\"","abxPickerSelect \" @_hip_ctrl\"","abxPickerSelect \" @_head_ctrl\"","abxPickerSelect \" @_neck_ctrl\"","abxPickerSelect \" @_eyeMaster_ctrl\"","abxPickerSelect \" @_masterSpine_ctrl\"","abxPickerSelect \" @_rt_eye_ctrl\";setToolTo moveSuperContext","abxPickerSelect \" @_lf_eye_ctrl\";setToolTo moveSuperContext","abxPickerSelect \" @_lf_heel_ik_ctrl\"","abxPickerSelect \" @_rt_knee_pv_ctrl\";setToolTo moveSuperContext","abxPickerSelect \" @_lf_knee_pv_ctrl\";setToolTo moveSuperContext","abxPickerSelect \" @_lf_clavicle_fk_ctrl\";setToolTo RotateSuperContext","if (!`exists abAutoRig`){source abAutoRig.mel;}abRTInit(); string $abRTgaSel[] = `ls -sl`;select -r @_rt_foot_ctrl;abRTFkIkSwitch(2);select -r $abRTgaSel","if (!`exists abAutoRig`){source abAutoRig.mel;}abRTInit(); string $abRTgaSel[] = `ls -sl`;select -r @_lf_foot_ctrl;abRTFkIkSwitch(2);select -r $abRTgaSel","if (!`exists abAutoRig`){source abAutoRig.mel;}abRTInit(); string $abRTgaSel[] = `ls -sl`;select -r @_lf_hand_ctrl;abRTFkIkSwitch(2);select -r $abRTgaSel","if (!`exists abAutoRig`){source abAutoRig.mel;}abRTInit(); string $abRTgaSel[] = `ls -sl`;select -r @_rt_hand_ctrl;abRTFkIkSwitch(2);select -r $abRTgaSel","abxPickerSelect \" @_rt_upLeg_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_rt_knee_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_rt_ankle_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_rt_ball_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_ball_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_ankle_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_knee_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_upLeg_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_rt_upLeg_fk_ctrl @_rt_knee_fk_ctrl @_rt_ankle_fk_ctrl @_rt_ball_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_upLeg_fk_ctrl @_lf_knee_fk_ctrl @_lf_ankle_fk_ctrl @_lf_ball_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_hand_ctrl\"","abxPickerSelect \" @_root_ctrl\"","abxPickerSelect \" @_jaw_ctrl\"","abxPickerSelect \" @_lf_shoulder_ctrl\"","abxPickerSelect \" @_spineMid_1_ctrl\"","abxPickerSelect \" @_spineHigh_ctrl\"","abxPickerSelect \" @_rt_clavicle_fk_ctrl\"","abxPickerSelect \" @_rt_shoulder_ctrl\"","abxPickerSelect \" @_lf_hip_ctrl\"","abxPickerSelect \" @_rt_hip_ctrl\"","abxPickerSelect \" @_lf_foot_ctrl\"","abxPickerSelect \" @_rt_heel_ik_ctrl\"","abxPickerSelect \" @_rt_foot_ctrl\"","abxPickerSelect \" @_rt_hand_ctrl\"","abxPickerSelect \" @_lf_thumbBase_fk_ctrl\"","abxPickerSelect \" @_lf_thumbMid_fk_ctrl\"","abxPickerSelect \" @_lf_thumbTip_fk_ctrl\"","abxPickerSelect \" @_lf_indexBase_fk_ctrl\"","abxPickerSelect \" @_lf_middleBase_fk_ctrl\"","abxPickerSelect \" @_lf_ringBase_fk_ctrl\"","abxPickerSelect \" @_lf_pinkyBase_fk_ctrl\"","abxPickerSelect \" @_lf_indexMid_fk_ctrl\"","abxPickerSelect \" @_lf_indexTip_fk_ctrl\"","abxPickerSelect \" @_lf_middleMid_fk_ctrl\"","abxPickerSelect \" @_lf_middleTip_fk_ctrl\"","abxPickerSelect \" @_lf_ringMid_fk_ctrl\"","abxPickerSelect \" @_lf_ringTip_fk_ctrl\"","abxPickerSelect \" @_lf_pinkyMid_fk_ctrl\"","abxPickerSelect \" @_lf_pinkyTip_fk_ctrl\"","abxPickerSelect \" @_lf_masterThumb_ctrl\"","abxPickerSelect \" @_lf_masterIndex_ctrl\"","abxPickerSelect \" @_lf_masterMiddle_ctrl\"","abxPickerSelect \" @_lf_masterRing_ctrl\"","abxPickerSelect \" @_lf_masterPinky_ctrl\"","abxPickerSelect \" @_rt_thumbBase_fk_ctrl\"","abxPickerSelect \" @_rt_thumbMid_fk_ctrl\"","abxPickerSelect \" @_rt_indexBase_fk_ctrl\"","abxPickerSelect \" @_rt_middleBase_fk_ctrl\"","abxPickerSelect \" @_rt_ringBase_fk_ctrl\"","abxPickerSelect \" @_rt_pinkyBase_fk_ctrl\"","abxPickerSelect \" @_rt_thumbTip_fk_ctrl\"","abxPickerSelect \" @_rt_pinkyMid_fk_ctrl\"","abxPickerSelect \" @_rt_pinkyTip_fk_ctrl\"","abxPickerSelect \" @_rt_ringMid_fk_ctrl\"","abxPickerSelect \" @_rt_ringTip_fk_ctrl\"","abxPickerSelect \" @_rt_middleMid_fk_ctrl\"","abxPickerSelect \" @_rt_middleTip_fk_ctrl\"","abxPickerSelect \" @_rt_indexMid_fk_ctrl\"","abxPickerSelect \" @_rt_indexTip_fk_ctrl\"","abxPickerSelect \" @_rt_masterThumb_ctrl\"","abxPickerSelect \" @_rt_masterIndex_ctrl\"","abxPickerSelect \" @_rt_masterMiddle_ctrl\"","abxPickerSelect \" @_rt_masterRing_ctrl\"","abxPickerSelect \" @_rt_masterPinky_ctrl\"","if (!`exists abAutoRig`){source abAutoRig.mel;}abRTInit(); select -r @_cog_ctrl;abRTSelectAllCharControls()","abxPickerSelect \" @_lf_upArm_fk_ctrl @_lf_elbow_fk_ctrl @_lf_wrist_fk_ctrl\"","abxPickerSelect \" @_rt_upArm_fk_ctrl @_rt_elbow_fk_ctrl @_rt_wrist_fk_ctrl\"","if (!`exists abAutoRig`){source abAutoRig.mel;}abRTInit(); string $abRTgaSel[] = `ls -sl`;select -r @_cog_ctrl;abRTResetCharPose(1);select -r $abRTgaSel","if (!`exists abAutoRig`){source abAutoRig.mel;}abRTInit(); abRTResetCharPose(0)"};
		$aImage = {"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""};
		$aLabel = {"IK","IK","FK","FK","PV","PV","","","","","","Cog","","","","","","R","L","IK","PV","PV","","SW","SW","SW","SW","","","","","","","","","","","L Hand","","","","","","","","","","","IK","","R Hand","","","","","","","","","","","","","","","","T","I","M","R","P","","","","","","","","","","","","","","","","T","I","M","R","P","Sellect All","","","Reset All To Default","Reset Selected"};
		$charPrefix = true;
		$mirrorPicker = false;
		$pickerScale = 1;
		
	}else{
		
		$size = 45;
		$aData = {"156:56:0.5:0.75:1","4:55:1:0.5:0.5","23:55:1:0:0","137:56:0:0.5:1","42:75:1:0.5:1","118:76:0:1:1","42:55:1:0:0","118:56:0:0.5:1","61:55:1:0:0","99:56:0:0.5:1","80:93:1:1:0","80:112:1:1:0","80:74:0.75:0.75:0","80:55:1:1:0","43:129:1:1:0","80:141:1:1:0","73:16:0.5:0.75:1","80:36:1:1:0","58:5:0:0.75:0.75","67:74:0.38:0.75:0","58:16:0:0.75:0.75","108:16:0:0.75:0.75","62:178:1:0.5:0.5","97:178:0.5:0.75:1","21:152:1:0.5:1","138:152:0:1:1","61:43:1:0.5:1","99:43:0:1:1","2:178:0.6:0.6:0.6","152:178:0.6:0.6:0.6","151:37:0.6:0.6:0.6","4:36:0.6:0.6:0.6","43:142:1:0:0","43:160:1:0:0","43:178:1:0:0","25:178:1:0:0","134:178:0:0.5:1","116:178:0:0.5:1","116:160:0:0.5:1","116:142:0:0.5:1","62:142:0.38:0.75:0","103:142:0.38:0.75:0","28:43:0.38:0.75:0","118:43:0.38:0.75:0","24:196:0.2:0.2:0.2"};
		$aWidth = {16,16,16,16,16,16,16,16,16,16,16,16,16,16,89,16,31,16,61,9,11,11,16,16,16,16,16,16,21,21,21,21,16,16,16,16,16,16,16,16,9,10,30,30,127};
		$aHeight = {16,16,16,16,16,16,16,16,16,16,16,14,16,16,9,16,16,16,8,52,10,10,16,16,16,16,9,9,16,16,16,16,16,16,16,16,16,16,16,16,34,34,9,9,8};
		$aOverlay = {"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""};
		$aCommand = {"abxPickerSelect \" @_lf_arm_ik_ctrl\"","abxPickerSelect \" @_rt_arm_ik_ctrl\"","abxPickerSelect \" @_rt_hand_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_hand_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_rt_elbow_pv_ctrl\";setToolTo moveSuperContext","abxPickerSelect \" @_lf_elbow_pv_ctrl\";setToolTo moveSuperContext","abxPickerSelect \" @_rt_elbow_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_elbow_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_rt_upArm_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_upArm_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_spineMid_ctrl\"","abxPickerSelect \" @_spineLow_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_spineShaper_ctrl\";setToolTo moveSuperContext","abxPickerSelect \" @_spineHigh_ctrl\"","abxPickerSelect \" @_cog_ctrl\"","abxPickerSelect \" @_hip_ctrl\"","abxPickerSelect \" @_head_fk_ctrl\"","abxPickerSelect \" @_neck_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_eyeMaster_ctrl\"","abxPickerSelect \" @_spineHigh_ctrl @_spineShaper_ctrl @_spineMid_ctrl @_spineLow_ctrl\"","abxPickerSelect \" @_rt_eye_ctrl\";setToolTo moveSuperContext","abxPickerSelect \" @_lf_eye_ctrl\";setToolTo moveSuperContext","abxPickerSelect \" @_rt_heel_ik_ctrl\"","abxPickerSelect \" @_lf_heel_ik_ctrl\"","abxPickerSelect \" @_rt_knee_pv_ctrl\";setToolTo moveSuperContext","abxPickerSelect \" @_lf_knee_pv_ctrl\";setToolTo moveSuperContext","abxPickerSelect \" @_rt_clavicle_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_clavicle_fk_ctrl\";setToolTo RotateSuperContext","setAttr ($pickrPrefix+\"@_rt_foot_ctrl.ikFkBlend\") (`getAttr ($pickrPrefix+\"@_rt_foot_ctrl.ikFkBlend\")` < .5)","setAttr ($pickrPrefix+\"@_lf_foot_ctrl.ikFkBlend\") (`getAttr ($pickrPrefix+\"@_lf_foot_ctrl.ikFkBlend\")` < .5)","setAttr ($pickrPrefix+\"@_lf_hand_ctrl.ikFkBlend\") (`getAttr ($pickrPrefix+\"@_lf_hand_ctrl.ikFkBlend\")` < .5)","setAttr ($pickrPrefix+\"@_rt_hand_ctrl.ikFkBlend\") (`getAttr ($pickrPrefix+\"@_rt_hand_ctrl.ikFkBlend\")` < .5)","abxPickerSelect \" @_rt_upLeg_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_rt_knee_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_rt_ankle_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_rt_ball_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_ball_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_ankle_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_knee_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_upLeg_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_rt_upLeg_fk_ctrl @_rt_knee_fk_ctrl @_rt_ankle_fk_ctrl @_rt_ball_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_upLeg_fk_ctrl @_lf_knee_fk_ctrl @_lf_ankle_fk_ctrl @_lf_ball_fk_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_rt_upArm_fk_ctrl @_rt_elbow_fk_ctrl @_rt_hand_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_lf_upArm_fk_ctrl @_lf_elbow_fk_ctrl @_lf_hand_ctrl\";setToolTo RotateSuperContext","abxPickerSelect \" @_root_ctrl\""};
		$aImage = {"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""};
		$aLabel = {"IK","IK","FK","FK","PV","PV","","","","","","","","","","","","","","","","","IK","IK","PV","PV","","","SW","SW","SW","SW","","","","","","","","","","","","",""};
		$charPrefix = true;
		$mirrorPicker = false;
		$pickerScale = 1;
	}
	
	// update $aCommand with charName
	for ($i=0;$i<size($aCommand);$i++)
		$aStr[$i] = substituteAllString($aCommand[$i], "@", $cn);
	$aCommand = $aStr;
	
	addAttr -ln "bgImage" -dt "string" $node;
	addAttr -ln "bgColor" -dt "string" $node;
	addAttr -ln "count" -at "long" $node;
	addAttr -ln "data" -dt "stringArray" $node;
	addAttr -ln "width" -dt "Int32Array" $node;
	addAttr -ln "height" -dt "Int32Array" $node;
	addAttr -ln "overlay" -dt "stringArray" $node;
	addAttr -ln "command" -dt "stringArray" $node;
	addAttr -ln "image" -dt "stringArray" $node;
	addAttr -ln "label" -dt "stringArray" $node;
	addAttr -ln "charPrefix" -at "bool" $node;
	addAttr -ln "mirrorPicker" -at "bool" $node;
	addAttr -ln "pickerScale" -at "float" $node;
	
	
	abRTArraySetAtt("Int32Array", ($node+".width"), {}, $aWidth);
	abRTArraySetAtt("Int32Array", ($node+".height"), {}, $aHeight);
	
	abRTArraySetAtt("stringArray", ($node+".data"), $aData, {});
	abRTArraySetAtt("stringArray", ($node+".overlay"), $aOverlay, {});
	abRTArraySetAtt("stringArray", ($node+".command"), $aCommand, {});
	abRTArraySetAtt("stringArray", ($node+".image"), $aImage, {});
	abRTArraySetAtt("stringArray", ($node+".label"), $aLabel, {});
	
	setAttr -type "string" ($node+".bgColor") "0.400000006:0.400000006:0.400000006";
	setAttr ($node+".count") $size;
	setAttr ($node+".charPrefix") $charPrefix;
	setAttr ($node+".mirrorPicker") $mirrorPicker;
	setAttr ($node+".pickerScale") $pickerScale;
	
}


global proc abRTSelectAllCharControls(){
	// selects all character control curves for chars with one selected curve
	
	string $ctrl, $aCharNames[], $charName, $aNewSel[];
	
	//string $aSel[] = `ls -sl "*_ctrl"`;
	string $aSel[] = abRTStringArrayMatch(`ls -sl`, ".+_ctrl$");
	
	if (size($aSel) == 0){
		warning "Select a character control curve.";
		return;
	}
	
	select -clear;
	
	for ($ctrl in $aSel){
		
		// if this character has already been selected, then skip it
		$charName = abRTGetCharNameFromCtrl($ctrl, false);
		if ($charName == "") continue;
		
		if (abRTGetPosInStrArray($charName, $aCharNames) != -1) continue;
		
		$aNewSel = stringArrayCatenate($aNewSel, `ls ($charName+"_*_ctrl")`);
		$aCharNames[size($aCharNames)] = $charName;
		
	}
	
	select -r $aNewSel;
	
}


global proc string abRTGetCharNameFromCtrl(string $ctrl, int $stripRef){
	// returns charname from $ctrl (or nothing)
	// if $ctrl == "", it will use a single selected curve
	// $stripRef will strip the prefixed reference, if true
	
	string $aSel[], $charName, $aCharName[];
	string $rigGrpSuffix = "_rig_grp";
	
	string $rigGrp = abRTGetRigGrpFromSelCtrl($ctrl);
	
	if ($rigGrp == "") return $rigGrp;
	
	$rigGrp = abRTStripPath($rigGrp);
	$charName = substring($rigGrp, 1, (size($rigGrp) - size($rigGrpSuffix)));
	
	if ($stripRef){
		
		$aCharName = stringToStringArray($charName, ":");
		
		if (size($aCharName) > 1)
			$charName = $aCharName[size($aCharName)-1];
	}
	
	return $charName;
	
}


//==========================================================================================================\\
//==========================================================================================================\\
//==================== 				split joint weighter			====================\\
//==========================================================================================================\\
//==========================================================================================================\\

global proc abRTSplitJointWeighterUI(){
	// displays split joint weight UI
	
	string $aLimbAttLabels[], $tAttLabels[], $formCmd, $aFormCmd[];
	string $charName, $rigSettingsCtrl, $limb;
	int $ctlKey, $mods;
	
	$mods = `getModifiers`;
	if ($mods / 4 % 2)
		$ctlKey = true;
	
	int $incLowLimbs = true;
	
	$charName = abRTGetCharNameFromCtrl("", false);
	
	
	if ($charName == "")
		return;
	
	$rigSettingsCtrl = $charName+"_rigSettings_ctrl";
	
	if (!objExists($rigSettingsCtrl)){
		
		warning ($charName+"_rigSettings_ctrl does not exist.  I quit.");
		return;
	}
	
	$aLimbAttLabels = `listAttr -k -string "*UpArm" $rigSettingsCtrl`;
	
	if ($incLowLimbs){
		
		$tAttLabels = `listAttr -k -string "*Forearm" $rigSettingsCtrl`;
		
		if (size($tAttLabels) == 0){
			$tAttLabels = `listAttr -k -string "*Forearm_1" $rigSettingsCtrl`;
			for ($i=0;$i<size($tAttLabels);$i++){
				// strip the trailing _1
				$tAttLabels[$i] = substring($tAttLabels[$i], 1, (size($tAttLabels[$i])-size("_1")));
			}
		}
		
		if (size($tAttLabels) > 0)
			$aLimbAttLabels = stringArrayCatenate($aLimbAttLabels, $tAttLabels);
	}
	
	$aLimbAttLabels = stringArrayCatenate($aLimbAttLabels, `listAttr -k -string "*UpLeg" $rigSettingsCtrl`);
	
	if ($incLowLimbs){
		
		$tAttLabels = `listAttr -k -string "*LowLeg" $rigSettingsCtrl`;
		
		if (size($tAttLabels) == 0){
			$tAttLabels = `listAttr -k -string "*LowLeg_1" $rigSettingsCtrl`;
			for ($i=0;$i<size($tAttLabels);$i++){
				// strip the trailing _1
				$tAttLabels[$i] = substring($tAttLabels[$i], 1, (size($tAttLabels[$i])-size("_1")));
			}
		}
		
		if (size($tAttLabels) > 0)
			$aLimbAttLabels = stringArrayCatenate($aLimbAttLabels, $tAttLabels);
	}
	
	
	if (`window -exists abRTSpltJntWtrWin`)
		deleteUI -window abRTSpltJntWtrWin;
	
	window -t "Split Joint Weighter" -w 182 -h 402 -menuBar false -minimizeButton false -maximizeButton false abRTSpltJntWtrWin;
	
	formLayout -numberOfDivisions 100 abRTSpltJntWtrForm;
	
	button -l ("Selected Char: "+$charName) -c ("$gStr = abRTGetCharNameFromCtrl(\"\", false); if ($gStr != \"\") abRTSplitJointWeighterUI();") abRTSpltJntWtrSelCharBn;
	
	textScrollList -h 40 -allowMultiSelection true abRTSpltJntWtrTxtScrllLst;
	
	text -l "Start Value:" -align "left" abRTSpltJntWtrStartTxt;
	text -l "End Value:" -align "left" abRTSpltJntWtrEndTxt;
	floatField -min 0 -max 1 -v 0 abRTSpltJntWtrStartFltFld;
	floatField -min 0 -max 1 -v 1 abRTSpltJntWtrEndFltFld;
	
	text -l "Blend Type:" -align "left" abRTSpltJntWtrBlndTypeTxt;
	
	optionMenu abRTSpltJntWtrBlendOpMn;
	menuItem -label "Linear" -p abRTSpltJntWtrBlendOpMn;
	menuItem -label "Ease In" -p abRTSpltJntWtrBlendOpMn;
	menuItem -label "Ease In Extra" -p abRTSpltJntWtrBlendOpMn;
	menuItem -label "Ease In Super" -p abRTSpltJntWtrBlendOpMn;
	menuItem -label "Ease In Mega" -p abRTSpltJntWtrBlendOpMn;
	menuItem -label "Ease Out" -p abRTSpltJntWtrBlendOpMn;
	menuItem -label "Ease Out Extra" -p abRTSpltJntWtrBlendOpMn;
	menuItem -label "Ease Out Super" -p abRTSpltJntWtrBlendOpMn;
	menuItem -label "Ease Out Mega" -p abRTSpltJntWtrBlendOpMn;
	
	checkBox -l "Blend From Second Value" -ann "If enabled, the first split joint value will be the blend value just after the start value.  Otherwise, the first split value will be set to the start value."  abRTSpltJntWtrUpLmbStrtBlndChkBx;
	checkBox -l "Blend To Next To Last Value" -v true -ann "If enabled, the last split joint value will be the blend value just before the end value.  Otherwise, the last split value will be set to the end value."  abRTSpltJntWtrUpLmbEndBlndChkBx;
	
	button -h 28 -l "Apply Weights To Selected" -c ("abRTSplitJointWeighter(`textScrollList -q -si abRTSpltJntWtrTxtScrllLst`, `floatField -q -v abRTSpltJntWtrStartFltFld`, `floatField -q -v abRTSpltJntWtrEndFltFld`, `optionMenu -q -sl abRTSpltJntWtrBlendOpMn`, \""+$rigSettingsCtrl+"\", `checkBox -q -v abRTSpltJntWtrUpLmbStrtBlndChkBx`, `checkBox -q -v abRTSpltJntWtrUpLmbEndBlndChkBx`, true)") abRTSpltJntWtrApplyBn;
	
	popupMenu -button 3 -p abRTSpltJntWtrApplyBn abRTSpltJntWtrStartEndSettingsPopUpMn;
	menuItem -l "Set Start/End ChackBoxes To UpLimb Defaults" -c ("checkBox -e -v 0 abRTSpltJntWtrUpLmbStrtBlndChkBx;checkBox -e -v 1 abRTSpltJntWtrUpLmbEndBlndChkBx;") -p abRTSpltJntWtrStartEndSettingsPopUpMn;
	menuItem -l "Set Start/End ChackBoxes To LowLimb Defaults" -c ("checkBox -e -v 1 abRTSpltJntWtrUpLmbStrtBlndChkBx;checkBox -e -v 1 abRTSpltJntWtrUpLmbEndBlndChkBx;") -p abRTSpltJntWtrStartEndSettingsPopUpMn;
	
	
	for ($limb in $aLimbAttLabels)
		textScrollList -e -a $limb abRTSpltJntWtrTxtScrllLst;
	
	int $lmargin = 3;
	int $rmargin = 3;
	
	
	formLayout -e
	
	-af abRTSpltJntWtrApplyBn "bottom" 5
	-af abRTSpltJntWtrApplyBn "left" $lmargin
	-af abRTSpltJntWtrApplyBn "right" $rmargin
	
	-ac abRTSpltJntWtrUpLmbEndBlndChkBx "bottom" 12 abRTSpltJntWtrApplyBn
	-af abRTSpltJntWtrUpLmbEndBlndChkBx "left" ($lmargin*2)
	
	-ac abRTSpltJntWtrUpLmbStrtBlndChkBx "bottom" 8 abRTSpltJntWtrUpLmbEndBlndChkBx
	-af abRTSpltJntWtrUpLmbStrtBlndChkBx "left" ($lmargin*2)
	
	-ac abRTSpltJntWtrBlndTypeTxt "bottom" 12 abRTSpltJntWtrUpLmbStrtBlndChkBx
	-af abRTSpltJntWtrBlndTypeTxt "left" ($lmargin*2)
	
	-ac abRTSpltJntWtrBlendOpMn "bottom" 8 abRTSpltJntWtrUpLmbStrtBlndChkBx
	-ac abRTSpltJntWtrBlendOpMn "left" $lmargin abRTSpltJntWtrBlndTypeTxt
	-af abRTSpltJntWtrBlendOpMn "right" $rmargin
	
	-ac abRTSpltJntWtrEndTxt "bottom" 9 abRTSpltJntWtrBlendOpMn
	-af abRTSpltJntWtrEndTxt "left" ($lmargin*2)
	
	-ac abRTSpltJntWtrEndFltFld "bottom" 5 abRTSpltJntWtrBlendOpMn
	-ac abRTSpltJntWtrEndFltFld "left" $lmargin abRTSpltJntWtrEndTxt
	-af abRTSpltJntWtrEndFltFld "right" $rmargin
	
	-ac abRTSpltJntWtrStartTxt "bottom" 7 abRTSpltJntWtrEndFltFld
	-af abRTSpltJntWtrStartTxt "left" ($lmargin*2)
	
	-ac abRTSpltJntWtrStartFltFld "bottom" 3 abRTSpltJntWtrEndFltFld
	-ac abRTSpltJntWtrStartFltFld "left" $lmargin abRTSpltJntWtrStartTxt
	-af abRTSpltJntWtrStartFltFld "right" $rmargin
	
	-af abRTSpltJntWtrSelCharBn "top" 5
	-af abRTSpltJntWtrSelCharBn "left" $lmargin
	-af abRTSpltJntWtrSelCharBn "right" $rmargin
	
	-ac abRTSpltJntWtrTxtScrllLst "top" 5 abRTSpltJntWtrSelCharBn
	-ac abRTSpltJntWtrTxtScrllLst "bottom" 5 abRTSpltJntWtrStartFltFld
	-af abRTSpltJntWtrTxtScrllLst "left" $lmargin
	-af abRTSpltJntWtrTxtScrllLst "right" $rmargin
	
	abRTSpltJntWtrForm
	;
	
	showWindow abRTSpltJntWtrWin;
	
}


global proc abRTSplitJointWeighter(string $aAttLabelPrefixes[], float $start, float $end, int $blendType, string $rigSettingsCtrl, int $blendFromSecondVal, int $blendToNextToLastVal, int $verbose){
	// $aAttLabelPrefixes is array of limb weight attribute baseNames on $rigSettingsCtrl
	// $blendType relates to options in splitJointWeighterUI
	// $blendFromSecondVal and $blendToNextToLastVal, offset first and last vals from start and end
	// if $verbose, a message showing the number of joints affected will be shown in the status line
	
	
	string $attLabel, $aLimbAtts[], $att, $msg;
	float $attVal, $n, $totLimbAtts, $power, $num, $range, $blendValue;
	int $i, $counter, $isUpLimb;
	
	if (size($aAttLabelPrefixes) == 0){
		warning "Select one or more limbs in the list and try again.";
		return;
	}
	
	$counter = 0;
	
	// $blendValue can be 0: linear, 2 to 5: powers of ease-in, or -2 to -5: powers of ease out
	switch($blendType){
		
		// linear
		case 1: $blendValue = 0;break;
		
		// ease in
		case 2: $blendValue = 2.0;break;
		case 3: $blendValue = 3.0;break;
		case 4: $blendValue = 4.0;break;
		case 5: $blendValue = 5.0;break;
		
		// ease out
		case 6: $blendValue = -2.0;break;
		case 7: $blendValue = -3.0;break;
		case 8: $blendValue = -4.0;break;
		case 9: $blendValue = -5.0;break;
	}
	
	for ($attLabel in $aAttLabelPrefixes){
		
		$aLimbAtts = `listAttr -k -string ($attLabel+"*") $rigSettingsCtrl`;
		
		$totLimbAtts = float(size($aLimbAtts));
		
		if ($blendFromSecondVal)
			$totLimbAtts += 1.0;
		
		if ($blendToNextToLastVal)
			$totLimbAtts += 1.0;
		
		$range = $end-$start;
		
		for ($i=0;$i<size($aLimbAtts);$i++){
			
			$att = $aLimbAtts[$i];
			$num = float($i);
			
			if ($blendFromSecondVal)
				$num += 1.0;
			
			if ($blendValue == 0){
				// linear
				
				$n = $num/($totLimbAtts-1);
				$n *= $range;
				
			}else if ($blendValue >= 2){
				// ease in
				$power = $blendValue;
				
				$n = pow($num/($totLimbAtts-1), $power);
				$n *= $range;
				
			}else if ($blendValue <= -2){
				// ease out
				$power = abs($blendValue);
				
				$n = 1 - pow(1 - ($num/($totLimbAtts-1)), $power);
				$n *= $range;
			}
			
			$attVal = $start + $n;
			
			if (attributeExists($att, $rigSettingsCtrl)){
				
				setAttr ($rigSettingsCtrl+"."+$att) $attVal;
				$counter++;
			}
		}
		
		
		// save settings to rootJnt
		string $aVals[], $globalVarName, $globalValStr, $lowerLimbSection, $charName;
		
		$charName = abRTGetCharNameFromCtrl($rigSettingsCtrl, false);
		
		$aVals = {string($start), string($end), string($blendType), string($blendFromSecondVal), string($blendToNextToLastVal)};
		$globalValStr = stringArrayToString($aVals, ",");
		
		$lowerLimbSection = tolower($attLabel);
		$lowerLimbSection = substitute("left", $lowerLimbSection, "");
		$lowerLimbSection = substitute("right", $lowerLimbSection, "");
		
		$globalVarName = "";
		
		switch($lowerLimbSection){
			
			case "upleg": $globalVarName = "upLegSpltBlndSettings"; break;
			case "lowleg": $globalVarName = "dnLegSpltBlndSettings"; break;
			case "uparm": $globalVarName = "upArmSpltBlndSettings"; break;
			case "forearm": $globalVarName = "dnArmSpltBlndSettings"; break;
		}
		
		if ($globalVarName != ""){
			
			// save it to the rootJnt
			abRTSetRootJntAtt($globalVarName, $globalValStr, $charName);
		}
	}
	
	if ($verbose){
		
		$msg = ($counter != 1) ? "\nUpdated "+$counter+" split joint twist contribution values." : "\nUpdated one single, solitary split joint twist contribution value.";
		
		print $msg;
	}
}


//==========================================================================================================\\
//==========================================================================================================\\


global proc float abRTGetClosestParamOnSurface(string $surface, float $aPointPos[], int $paramType){
	// returns the closest u ($paramType == 1) or v ($paramType == 2) on $surface to point $aPointPos {x, y, z}
	// returns  -1.0 on failure
	// only gives accurate results on cubic (3 degree) surfaces
	
	string $surfShape, $aStr[], $cpNode;
	float $ret = -1.0;
	
	$aStr = `listRelatives -c -type shape $surface`;
	
	if (size($aStr) == 0)
		return $ret;
	
	$surfShape = $aStr[0];
	
	$cpNode = `createNode closestPointOnSurface -n "temp_closestPoint_node"`;
	
	// get surface shape
	connectAttr ($surfShape+".worldSpace") ($cpNode+".inputSurface");
	setAttr ($cpNode+".inPosition") $aPointPos[0] $aPointPos[1] $aPointPos[2];
	
	if ($paramType == 1){
		// u
		$ret = `getAttr ($cpNode+".parameterU")`;
		
	}else if ($paramType == 2){
		// v
		$ret = `getAttr ($cpNode+".parameterV")`;
	}
	
	// delete the cp node
	delete $cpNode;
	
	return $ret;
}
