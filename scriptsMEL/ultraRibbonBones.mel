//ultra_ribbon 
//author: Mads Tuxen
//http://www.grafiskkooperativ.dk/mads
//mail madstuxen@gmail.com


// you need plugin closestPointOnCurve to run the script 
// get it from autodesk maya bonustools

// script creates setup for non flipping total control ik-spline.
// it uses two curves with same parametrisation so just create one and copy it
// select first goal-curve the aim curve and finally rootjoint and then excecute script
// script generates locators and nodes to control the rig. It makes a copy of the rig
// and creates an ik-splinesolver with the copied joints on goal curve. You control twisting and rolling of 
// the rig via this ik splinehandle, although not directly but via connections and nodes
// you now have one curve with your rig and one curve to control the orientation at any given point.
// the rig works by having a locator on aimcurve for each joint on goalcurve. Via closestPointOnCurve they 
// are alligned in u.
// limitations : the last joint is not controled probberly so dont bind to it. You might want to bind 
// the skin after the rig has been set up and start with straight curves and deform them afterwards.
// script assumes that you havent parented anything to your hiracy so if you have
// unparent before running script,and reparent afterwards.
// to get smooth geometry you may need a lot of joints (50 or 100 or more)
// the setup is very good for rollercoasters as well

// 2011 changed code to accomodate for changes in mel


global proc ultraRibbonBones()
{

//use selections to create names and copy joints
string $s[]=`ls -sl`;


string $c1=$s[0];
string $c2=$s[1];
string $joint=$s[2];
select -hi $joint;

string $joints_orig[]=`ls -sl -type joint`;
int $ant=size ($joints_orig);

string $copy_joint[]= `duplicate -rr -rc $joints_orig[0]`;
select -hi $copy_joint[0];
string $copy_joints[]=`ls -sl -type joint`;


// lav ik-splinehandle på curve1 med den kopierede jointchain:

string $main_ik[]=`ikHandle -sj $copy_joints[0] -ee $copy_joints[($ant-1)] 
 -sol ikSplineSolver -ccv 0 -roc 1 -curve $c1   `;
print ($main_ik[0]);


// create ik-handles on original joints
string $ik_handles[];	
for ($i=0;$i<($ant-1);$i++) {
	//string $temp[]=`ikHandle -sj $joints_orig[$i] -ee $joints_orig[($i+1)]`;
	string $temp[]=`ikHandle -sj $joints_orig[$i] -ee $joints_orig[($i+1)] -sol "ikRPsolver"`;
	$ik_handles[$i]=$temp[0];
	}




// create locators and pointconstrain them to joints on copied joints
// create locators and control them closestpointOnCurve and pathanimation

string $aims[];
string $wuo[];
	
for ($i=0;$i<$ant;$i++) {
	string $loc[]=`spaceLocator -p 0 0 0`;
	string $j=$copy_joints[$i];
	pointConstraint $j $loc[0];
	
	string $cpc =`createNode closestPointOnCurve`;
	connectAttr ($c1+".worldSpace") ($cpc+".inCurve");
	connectAttr ($loc[0]+".translate") ($cpc+".inPosition");
	string $wuloc[]=`spaceLocator -p 0 0 0`;
	string $mp=`pathAnimation -c $c2 $wuloc[0]`;
	
	connectAttr  -f ($cpc+".paramU") ($mp+".uValue");
	$aims[$i]=$loc[0];
	$wuo[$i]=$wuloc[0];
	} 
	
// pointconstraine rooten af originalen til den første loc på c1	

pointConstraint $aims[0] $joints_orig[0];	

//pointconstraine ik handles til locators på curve2

for ($i=0;$i<($ant-1);$i++) {
	pointConstraint $aims[($i+1)] $ik_handles[$i];
	}

//lave pole vectorconstraints mellem iks og locators på c2

for ($i=0;$i<($ant-1);$i++) {
	poleVectorConstraint $wuo[$i] $ik_handles[$i];
}







//make ofsetts

for ($i=0;$i<($ant-1);$i++) {
	
	
	float $fi=$i;
	string $md=`createNode multiplyDivide`;
	connectAttr -f ($main_ik[0]+".twist") ($md+".input1X");
	
	
	setAttr ($md+".input2X") ($fi/($ant-2));
	string $pma=`createNode plusMinusAverage`;
	connectAttr -f ($main_ik[0]+".roll") ($pma+".input1D[0]");
	connectAttr  -f ($md+".outputX") ($pma+".input1D[1]");
	connectAttr -f ($pma+".output1D") ($ik_handles[$i]+".twist");
			
	}



group -n "ik_handles_dont_move" $ik_handles ;
group -n "goal_loc_dont_move" $aims;
group -n "aim_loc_dont_move" $wuo;
clear $aims;
clear $wuo;
clear $ik_handles;
setAttr ($copy_joints[0]+".visibility") 0;

}
//ends globalproc
