/*______________________________________________________
Written By : Rob A Coakley robcoakley@gmail.com
	thanks to:
				Henry Foster
				Mariano Antico 
				Ed Whetstone  and
				Hamish McKenzie for great sources 			
__________________________________________________________
*/
////WARNINGS AND DEFAULT SETUPS
global proc plugMR(){//py
	/*(if (!`pluginInfo -query -l Mayatomr`){/////LOAD MR PLUGIN
		confirmDialog -title "rcTools" -m "Loading MentalRay Plugin!";
		if ( catch (loadPlugin "Mayatomr.mll")){
		    confirmDialog -title "rcTools" -m "NO MentalRay Plugin!";
	}}; 
		setAttr -type "string" "defaultRenderGlobals.currentRenderer" "mentalRay";}
		*/
	}
global proc renderMR(){//py
	if (!(`getAttr "defaultRenderGlobals.currentRenderer"` == "mentalRay")){/////RUNTIME (MR NECCESARY)
	string $return=`confirmDialog -title "rcTools" -button "Yes" -button "No"-m "Set Renderer to MentalRay?"-cb "No"-ma"center"-ds "No"`;
	if(!($return=="No")) {
		setAttr -type "string" "defaultRenderGlobals.currentRenderer" "mentalRay";
		miCreateDefaultNodes;   ///DAMNIT you have to force it to make the globals
	}}}
global proc warningCameraCompliant(){//Warning for exception to 1 Render Camera
	string $cameras[]= rcListRenderCameras();
	if ($cameras[0]=="")   confirmDialog -title "rcCameraCompliant" -icn "warning" -ma "center" -message "No Render Camera Set";
	if (size ($cameras) > 1) confirmDialog -title "rcSetImagePrefix" -icn "warning" -ma "center" -message "Too Many Cameras Set";
	if ($cameras[0]=="perspShape") confirmDialog -title "rcSetImagePrefix" -icn "warning" -ma "center" -message "Render Camera Set to Persp";
	}
//PY ENTRY
global proc setupPY(string $script){
	python "import sys"; python "import os";
	python "sys.path.append (os.environ.get('USERPROFILE')+'\\Google Drive\\scripts\\')"
	python ("import " + $script);
	python ("reload("+$script+")");
    }
global proc runPY(string $script,string $command){
	setupPY($script);
	python ($script + "." + $command);
	}
////GROUP/RIG
global proc removeIntermediateShape(){
	string $SC_selection[] = `ls -l -type "mesh" -type "nurbsSurface"` ;
	string $SC_intobjs[];
	int $i=0;
	for ($SC_obj in $SC_selection){
		string $SC_listcons[] = `listConnections -sh 1 $SC_obj`;
		if ( `size $SC_listcons` <= 1   ){
			if ( `size $SC_listcons` == 0  && (`getAttr ($SC_obj + ".intermediateObject")` ) == 1)
				{
				delete $SC_obj;
				$SC_intobjs[$i] = $SC_obj;
				$i++;
				}
			else
				{

				if (  `nodeType  $SC_listcons[0] `== "displayLayer" )
					{
					delete $SC_obj;
					$SC_intobjs[$i] = $SC_obj;
					$i++;
					}
				}
			}
	}}	
global proc rcCombine(){
	string $sel[] = `ls -sl` ;
	string $selShape[];
	if ( size ( $sel ) < 2 ) { warning "Please select at least two objects." ;} 
		else {
		// > Make sure every object is a polygon
		for ( $i = 0 ; $i < size ( $sel ) ; $i++ ){
			string $selShapeT[] = `listRelatives -c $sel[$i]` ;
			if ( `nodeType $selShapeT[0]` == "mesh" ) $selShape[$i] = $selShapeT[0] ;
		}
		// <
		// > Create polyUnite node and output mesh
		createNode polyUnite ;
		string $polyUniteNodeName[] = `ls -sl` ;
		polyCube -ch 0 -n meshCombine ;
		string $polyCubeNodeName[] = `ls -sl` ;
		string $polyCubeNodeShape[] = `listRelatives -c $polyCubeNodeName[0]` ;
		string $connectFrom = $polyUniteNodeName[0] + ".output" ;
		string $connectTo = $polyCubeNodeShape[0] + ".inMesh" ;
		connectAttr -f $connectFrom $connectTo ;
		// <
		// > Connect all obj to polyUnite node
		for ( $i = 0 ; $i < size ( $selShape ) ; $i++ ){
			string $connectFrom = $selShape[$i] + ".worldMesh" ;
			string $connectTo = $polyUniteNodeName[0] + ".inputPoly[" + $i + "]" ;
			connectAttr -f $connectFrom $connectTo ;
			string $connectFrom = $selShape[$i] + ".worldMatrix[0]" ;
			string $connectTo = $polyUniteNodeName[0] + ".inputMat[" + $i + "]" ;
			connectAttr -f $connectFrom $connectTo ;
			}
		}
		//delete $sel;
		DeleteHistory;
	}

global proc rcCtGrp()       {	
	string $textfield;
	string $prompt =`promptDialog -title "Ctrl_GRP" -m "Name:" -tx "Ctrl_" -button "Create&Hide" -button "Create"`;
	string $CtrlName =`promptDialog -query -text`;
	string $selSet[] = `ls -sl`;
	string $Ctrl_group = `group -n $CtrlName`; 
	xform -os -piv 0 0 0;
	select -add $selSet[0];
	string $selLast[] = `ls -sl -tail 1`;
	string $copyToObj = $selLast[0];
	select -deselect $copyToObj;
	$selSet = `ls -sl`;
	float $pivotSel[] = `xform -q -piv -ws $copyToObj`;
	for ($each in $selSet) move -a $pivotSel[0] $pivotSel[1] $pivotSel[2] ($each + ".rotatePivot") ($each + ".scalePivot");
	toggle -selectHandle;
	if ($prompt=="Create&Hide") setAttr ($selLast[0] +".visibility") 0;
	}
global proc Ctrl_MPath() {
	//toggle -selectHandle;
	string $selSet[] = `ls -sl`;
	string $Ctrl_locator[] = `spaceLocator -p 0 0 0 -n "Ctrl_0"`;
	xform -os -piv 0 0 0;
	float $selectedXform[] = `xform -q -ws -piv $selSet[0]`;
	float $moveToX = $selectedXform[0]; float $moveToY = $selectedXform[1]; float $moveToZ = $selectedXform[2];
	move -a $moveToX $moveToY $moveToZ -rpr ( "|" + $Ctrl_locator[0]);
	select -add $selSet[0] ;pointConstraint -offset 0 0 0 -weight 1;
	select -r ( "|" + $Ctrl_locator[0]);
	string $Ctrl_group = `group -em -n "X_Mpath_0"`;
	xform -os -piv 0 0 0;
	float $selectedXform[] = `xform -q -ws -piv $selSet[0]`;
	float $moveToX = $selectedXform[0]; float $moveToY = $selectedXform[1]; float $moveToZ = $selectedXform[2];
	move -a $moveToX $moveToY $moveToZ -rpr $Ctrl_group;
	select -r ( "|" + $Ctrl_locator[0]);
	select -add $Ctrl_group ;parent;
	//makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;	
	}
global proc Ctrl_Curve()  {
	string $sel[] = `ls -sl`;
	string $selSet[]; string $selSub[];
	$selSub = `listRelatives -type "joint" -children $sel[0]`;
	//Build List
	$selSet[0]= $sel[0]; $selSet[size($selSet)]= $selSub[0];
	
	while(!($selSub[0]==""))
	{
	select $selSub[0];
	$selSub = `listRelatives -type "joint" -children $selSub[0]`;
	if (!($selSub[0]=="")) $selSet[size($selSet)]= $selSub[0];
	}
	//Build Curve Command
	string $CurveCommand="curve -n \"Ctrl_Curve\" -d 3 ";
	for($each in  $selSet)
	{ 
			select $each;
			float $pos[]= `xform -q -t -ws $each`;
			$CurveCommand+= " -p "+ $pos[0]+ " "+$pos[1]+ " "+$pos[2];
	}
	$CurveCommand+= ";";
	//Build Curve
	string $curve=`eval $CurveCommand`;
	select $curve;
	string $curveShape[] = `pickWalk -d "down"`;
	int $numSpans = `getAttr ( $curveShape[1] + ".spans" )`;
	int $degree   = `getAttr ( $curveShape[1] + ".degree" )`;
	int $numCVs   = $numSpans + $degree;
	select -cl;
	string $clusterSet[];
	for ($cv=0;$cv<$numCVs;$cv++)
	{
		select ($curve+".cv["+$cv +"]");
		string $cluster[]= `newCluster "-envelope 1"`;
		select -r $selSet[$cv];
		select -add $cluster[1];
		doCreatePointConstraintArgList 1 { "0","0","0","0","0","0","0","1","","1" };
		pointConstraint -offset 0 0 0 -weight 1;
		$clusterSet[size($clusterSet)]=$cluster[1];
		
	}
	select $clusterSet;
	string $clusterGrp= `group`;
	HideSelectedObjects;
	rename $clusterGrp "X_Ctrl_Clusters";
	

	
	}
global proc Ctrl_Rename(){
	string $selSet[] = `ls -sl`;
	string $text;
	string $result = `promptDialog
    -title "Rename Object"
    -message " Name:"
    -button "OK" -button "Cancel"
    -defaultButton "OK" -cancelButton "Cancel"
    -dismissString "Cancel"`;
    if ($result == "OK") {
    $text = `promptDialog -query -text`;
    rename $selSet[0] $text;
    }
	}
global proc Ctrl_Joints(){

    string $sel []=`ls -sl`;
    string $curve =$sel [0];
    string $check =`checkBoxGrp -q -v1 rebuildCheck`;
    if ($check==1 )
    {
    	    rebuildCurve -rt 0 -s 25;

    }
    else
    {
    }
    string $lcr []=`spaceLocator`;
    string $loc =$lcr [0];

    string $path =`pathAnimation  -stu 1 -etu 1000 -f on  $curve $loc `; 
    int $numbers []=`intFieldGrp -q -v numberInt`;

    float $locPos []=`xform -q -ws  -t $loc`;
    int $divFacter =1000 / $numbers [0];

    select -cl;
    $i=`currentTime -q`;
    
    for ($i=1; $i<1000; $i=$i+$divFacter)
        //--------- Loop to make joint chain
    {
        currentTime $i;
        float $lcPos []=`xform -q  -ws -t locator1`;
        string $joints =`joint -a -p $lcPos [0] $lcPos [1] $lcPos [2]`;

    }
    string $selJoint []=`ls -sl`;
    string $jnt =$selJoint [0]; 


    $i =1;
            for ( $i=1; $i<$numbers[0]+1; $i++) //--------- loop for getting 1st joint
                {
                    pickWalk -d up;
                }    
    
    joint -e -oj xyz -secondaryAxisOrient yup -ch -zso;


    delete $path;
    delete $loc;
    currentTime -e 1;
	}   
global proc Bind()       {
	string $file=`file -r -type "mayaBinary" -gl -loadReferenceDepth "all" -shd "renderLayersByName" -namespace "MOL_0" -options "v=0" "/Volumes/PDSA1/CFF/CFF_2012/Working_Files/Programs/Maya/scenes/refs/BindingMolecule.mb"`;
	print $file;
	}
global proc ctrlIcon(string $proc){
	switch($proc){
		case "Box":
			curve -name "box" -d 1 -p -0.5 0.5 -0.5 -p 0.5 0.5 -0.5 -p 0.5 0.5 0.5 -p -0.5 0.5 0.5 -p -0.5 0.5 -0.5 -p -0.5 -0.5 -0.5 -p -0.5 -0.5 0.5 -p 0.5 -0.5 0.5 -p 0.5 -0.5 -0.5 -p -0.5 -0.5 -0.5 -p -0.5 -0.5 0.5 -p -0.5 0.5 0.5 -p 0.5 0.5 0.5 -p 0.5 -0.5 0.5 -p 0.5 -0.5 -0.5 -p 0.5 0.5 -0.5 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 ;
			makeIdentity -apply true -t 0 -r 0 -s 1 -n 0;
			xform -cp;
			break;
		case "Square":
			curve -name "square" -d 1 -p -1 0 -1 -p -1 0 1 -p 1 0 1 -p 1 0 -1 -p -1 0 -1 -k 0 -k 1 -k 2 -k 3 -k 4 ;
			xform -cp;
			makeIdentity -apply true -t 0 -r 1 -s 0 -n 0;
			break;
		case "Circle":
				circle -c 0 0 0 -nr 0 0 1 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;
				break;
		case "FourDir":
			curve -name "FourDir" -d 1 -p -1.009675 0 -0.977991 -p -1.009675 0 -3.017713 -p -1.009675 0 -3.017713 -p -2 0 -3 -p 0 0 -5 -p 2 0 -3 -p 1 0 -3 -p 1 0 -1 -p 3 0 -1 -p 3 0 -2 -p 5 0 0 -p 3 0 2 -p 3 0 1 -p 1 0 1 -p 1 0 3 -p 2 0 3 -p 0 0 5 -p -2 0 3 -p -1 0 3 -p -1 0 1 -p -3 0 1 -p -3 0 2 -p -5 0 0 -p -3 0 -2 -p -3 0 -1 -p -1 0 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 25 ;
			makeIdentity -apply true -t 0 -r 1 -s 0 -n 0;
			break;
		case "Arrow":
			curve -name "Arrow" -d 1 -p -1 0 0 -p -2 0 0 -p 0 0 -3 -p 2 0 0 -p 1 0 0 -p 1 0 3 -p -1 0 3 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 ;
			makeIdentity -apply true -t 0 -r 1 -s 0 -n 0;
			break;
		case "Tri":
			curve -name "Triangle" -d 1 -p 0 0.353553 0 -p -0.707107 -0.353553 0 -p 0 -0.353553 0.707107 -p 0 0.353553 0 -p 0.707107 -0.353553 0 -p 0 -0.353553 -0.707107 -p 0 0.353553 0 -p -0.707107 -0.353553 0 -p 0 -0.353553 -0.707107 -p 0.707107 -0.353553 0 -p 0 -0.353553 0.707107 -p -0.707107 -0.353553 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 ;
			break;
		case "TwoDir":
			curve -name "TwoDir" -d 1 -p -1 0 -2 -p -2 0 -2 -p 0 0 -4 -p 2 0 -2 -p 1 0 -2 -p 1 0 1 -p 2 0 1 -p 0 0 3 -p -2 0 1 -p -1 0 1 -p -1 0 -2 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 ;
			break;
		case "FourDir2":
			curve -name "FourDir2" -d 1 -p 1 -0.889103 0 -p 1 -2.114391 0.504006 -p 1 -3.440023 1.402289 -p 1.00446 -4.407442 2.450668 -p 2 -4.407442 2.450668 -p 0 -5.104627 4.325217 -p -2 -4.407442 2.450668 -p -1 -4.407442 2.450668 -p -1 -3.492158 1.442272 -p -1 -2.00951 0.448043 -p -1 -0.889103 0 -p -2.274182 -0.889103 0.425797 -p -3.508666 -0.889103 1.358465 -p -4.559936 -0.889103 2.618453 -p -4.559936 -1.889103 2.618453 -p -4.861653 0.110897 3.717883 -p -4.559936 2.110897 2.618453 -p -4.559936 1.110897 2.618453 -p -3.695534 1.110897 1.525866 -p -2.401371 1.110897 0.514104 -p -1 1.110897 0 -p -1 2.230979 0.447914 -p -1 3.608218 1.361183 -p -1 4.629236 2.450668 -p -2 4.629236 2.450668 -p 0 5.326421 4.325217 -p 2 4.629236 2.450668 -p 1 4.629236 2.450668 -p 1 3.669424 1.408123 -p 1 2.267852 0.462659 -p 1 1.110897 0 -p 2.169576 1.110897 0.373148 -p 3.526285 1.110897 1.374248 -p 4.559936 1.110897 2.618453 -p 4.559936 2.110897 2.618453 -p 4.861653 0.110897 3.717883 -p 4.559936 -1.889103 2.618453 -p 4.559936 -0.889103 2.618453 -p 3.501808 -0.889103 1.352321 -p 2.00506 -0.889103 0.320659 -p 1 -0.889103 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 25 -k 26 -k 27 -k 28 -k 29 -k 30 -k 31 -k 32 -k 33 -k 34 -k 35 -k 36 -k 37 -k 38 -k 39 -k 40 ;
			break;
		case "TwoDir2":
			curve -name "Arrow" -d 1 -p -1 0 0 -p -2 0 0 -p 0 0 -3 -p 2 0 0 -p 1 0 0 -p 1 0 3 -p -1 0 3 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 ;
			makeIdentity -apply true -t 0 -r 1 -s 0 -n 0;
			break;
		case "Star":
			curve -name "Star" -d 1 -p 0 0 -2.993802 -p -0.886951 0 -0.993802 -p -3 0 -0.993802 -p -1.271527 0 0.388976 -p -2 0 3.006198 -p -0.0221259 0 1.423899 -p 2 0 3.006198 -p 1.250591 0 0.383265 -p 3 0 -0.993802 -p 0.894704 0 -0.993802 -p 0 0 -2.993802 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 ;
			break;
		case "LBox":
			curve -name "LBox" -d 1 -p 0.885618 4.181748 -0.885618 -p -0.885618 4.181748 -0.885618 -p -0.885618 4.181748 0.885618 -p 0.885618 4.181748 0.885618 -p 0.885618 4.181748 -0.885618 -p 0.885618 -0.885618 -0.885618 -p -0.885618 -0.885618 -0.885618 -p -0.885618 4.181748 -0.885618 -p -0.885618 4.181748 0.885618 -p -0.885618 -0.885618 0.885618 -p -0.885618 -0.885618 -0.885618 -p -0.885618 0.885618 -0.885618 -p -0.885618 0.885618 3.40897 -p -0.885618 -0.885618 3.40897 -p -0.885618 -0.885618 -0.885618 -p 0.885618 -0.885618 -0.885618 -p 0.885618 0.885618 -0.885618 -p -0.885618 0.885618 -0.885618 -p -0.885618 0.885618 0.885618 -p 0.885618 0.885618 0.885618 -p 0.885618 0.885618 -0.885618 -p 0.885618 -0.885618 -0.885618 -p 0.885618 -0.885618 0.885618 -p 0.885618 0.885618 0.885618 -p 0.885618 0.885618 3.40897 -p 0.885618 -0.885618 3.40897 -p 0.885618 -0.885618 0.885618 -p -0.885618 -0.885618 0.885618 -p -0.885618 -0.885618 3.40897 -p -0.885618 0.885618 3.40897 -p -0.885618 0.885618 0.885618 -p -0.885618 -0.885618 0.885618 -p 0.885618 -0.885618 0.885618 -p 0.885618 4.181748 0.885618 -p -0.885618 4.181748 0.885618 -p -0.885618 -0.885618 0.885618 -p -0.885618 -0.885618 3.40897 -p 0.885618 -0.885618 3.40897 -p 0.885618 0.885618 3.40897 -p -0.885618 0.885618 3.40897 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 25 -k 26 -k 27 -k 28 -k 29 -k 30 -k 31 -k 32 -k 33 -k 34 -k 35 -k 36 -k 37 -k 38 -k 39 ;
			break;
		case "Cross":
			curve -name "Cross" -d 1 -p 1 0 -3 -p -1 0 -3 -p -0.578361 0 -0.578361 -p -3 0 -1 -p -3 0 1 -p -0.578361 0 0.578361 -p -1 0 3 -p 1 0 3 -p 0.578361 0 0.578361 -p 3 0 1 -p 3 0 -1 -p 0.578361 0 -0.578361 -p 1 0 -3 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 ;
			break;
		case "Star2":
			curve -name "Star" -d 1 -p 2 0 2 -p 0.921007 0 1.552564 -p 0 0 3 -p -0.798109 0 1.56101 -p -2 0 2 -p -1.799076 0 0.839664 -p -3 0 0 -p -1.822305 0 -0.727174 -p -2 0 -2 -p -0.917998 0 -1.66289 -p 0 0 -3 -p 0.81617 0 -1.656152 -p 2 0 -2 -p 1.760797 0 -0.819971 -p 3 0 0 -p 1.736767 0 0.725875 -p 1.99728 0 2.02061 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 ;
			break;
		case "Arrow2":
			curve -name "Arrow" -d 1 -p -1 0 1 -p -3 0 2 -p 0 0 5 -p 3 0 2 -p 1 0 1 -p 2 0 -5 -p 0 0 -6 -p -2 0 -5 -p -1 0 1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 ;
			break;
		case "Hand":
			curve -name "thumb" -d 3 -p -2.557329 1.441239 0 -p -3.537357 2.311885 0 -p -4.301053 2.641748 0 -p -4.92194 2.496979 0 -p -4.900667 1.674992 0 -p -4.020025 0.789558 0 -p -3.26916 -0.304352 0 -p -3.018696 -0.784251 0 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 5 -k 5 ;
			curve -name "index" -d 3 -p -2.571192 1.399283 0 -p -2.559592 2.646687 0 -p -2.612154 3.888577 0 -p -2.616826 5.304183 0 -p -2.388669 5.915978 0 -p -1.920662 5.859773 0 -p -1.670891 5.15892 0 -p -1.583895 3.790822 0 -p -1.384107 2.199669 0 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 6 -k 6 ;
			curve -name "middle" -d 3 -p -1.190753 2.255982 0 -p -1.133721 3.314887 0 -p -1.141711 4.655561 0 -p -1.171085 6.163807 0 -p -0.936712 6.741552 0 -p -0.344952 6.710646 0 -p -0.0622071 5.96203 0 -p 0.0237127 4.120351 0 -p 0.28265 2.310176 0 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 6 -k 6 ;
			curve -name "Ring" -d 3 -p 0.394654 2.297828 0 -p 0.452538 3.754318 0 -p 0.404339 5.390041 0 -p 0.547113 6.231247 0 -p 0.93868 6.361151 0 -p 1.44367 5.721457 0 -p 1.54951 4.07745 0 -p 1.737292 1.994812 0 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 5 -k 5 ;
			curve -name "Pinky" -d 3 -p 1.920715 1.920995 0 -p 1.967312 3.011064 0 -p 1.927267 4.562361 0 -p 2.142055 5.280269 0 -p 2.495341 5.284025 0 -p 2.810595 4.251992 0 -p 2.903976 2.556352 0 -p 3.001823 0.795666 0 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 5 -k 5 ;
			curve -name "Palm" -d 3 -p -3.019797 -0.824482 0 -p -2.014254 -1.686377 0 -p -0.811192 -2.225061 0 -p 0.768948 -2.36871 0 -p 2.349088 -1.794114 0 -p 3.013465 -0.537184 0 -p 3.001823 0.795666 0 -p 2.510693 1.58164 0 -p 1.920715 1.920995 0 -p 1.735857 2.010724 0 -p 0.394654 2.297828 0 -p 0.28265 2.310176 0 -p -1.190753 2.255982 0 -p -1.384107 2.199669 0 -p -2.014254 1.940763 0 -p -2.606806 1.420035 0 -p -2.786368 1.007044 0 -p -2.696587 -0.160105 0 -p -1.529438 -1.201561 0 -p -0.0211224 -1.704333 0 -p 1.307632 -1.542728 0 -p 1.936097 -0.842438 0 -p 2.115658 0.270842 0 -p 1.720623 1.096825 0 -p 0.786904 1.330254 0 -p -0.577763 1.455947 0 -p -1.367833 1.078868 0 -p -1.493526 0.252886 0 -p -1.170315 -0.447403 0 -p -0.577763 -0.932219 0 -p 0.409825 -0.896307 0 -p 0.840772 -0.375579 0 -p 0.840772 0.216974 0 -p 0.607342 0.55814 0 -p -0.200684 0.755658 0 -p -0.667543 0.378579 0 -p -0.54185 -0.142149 0 -p -0.0211224 -0.357623 0 -p 0.0686583 0.0194563 0 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 25 -k 26 -k 27 -k 28 -k 29 -k 30 -k 31 -k 32 -k 33 -k 34 -k 35 -k 36 -k 36 -k 36 ;
			break;
		case "Cross2":
			curve -name "Cross" -d 3 -p -1 0 -1.980995 -p -1.001043 0 -1.677469 -p -1.003128 0 -1.070416 -p -0.987487 0 -0.980789 -p -2.198299 0 -1.006427 -p -2.826509 0 -0.993504 -p -3.04627 0 -1.019557 -p -2.988412 0 0.188034 -p -3.000082 0 1.002181 -p -3.011261 0 0.998736 -p -1.96697 0 1.002876 -p -1.130002 0 0.989761 -p -0.965676 0 1.038082 -p -1.007294 0 2.11675 -p -1.005146 0 2.93084 -p -0.97212 0 3.01815 -p 0.199517 0 2.99656 -p 0.8631 0 2.995612 -p 1.034915 0 3.020994 -p 0.99724 0 1.872908 -p 0.976125 0 1.146322 -p 1.09826 0 0.960085 -p 1.988911 0 1.013338 -p 2.89251 0 0.986564 -p 3.031177 0 1.040408 -p 2.982782 0 -0.115925 -p 3.037694 0 -0.849451 -p 2.866443 0 -1.041555 -p 1.958961 0 -0.984331 -p 1.043816 0 -1.021122 -p 0.990379 0 -0.931182 -p 0.994668 0 -2.002289 -p 1.03095 0 -2.955363 -p 0.881531 0 -3.013146 -p -0.0505929 0 -2.992053 -p -0.834631 0 -3.018641 -p -1.041342 0 -2.933382 -p -1.013781 0 -2.298458 -p -1 0 -1.980995 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 25 -k 26 -k 27 -k 28 -k 29 -k 30 -k 31 -k 32 -k 33 -k 34 -k 35 -k 36 -k 36 -k 36 ;
			break;
		case "Prism":
			curve -name "Prism" -d 1 -p -0.288675 1 0.5 -p -0.288675 1 -0.5 -p 0.57735 1 0 -p -0.28123 1 0.495701 -p -0.288675 -1 0.5 -p 0.57735 -1 0 -p 0.57735 1 0 -p -0.288675 1 -0.5 -p -0.288675 -1 -0.5 -p -0.288675 -1 0.5 -p 0.57735 -1 0 -p -0.288675 -1 -0.5 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 ;
			break;
		}}	
////NAMESPACE
global proc rcRemoveNS(){
	
	string $sel[] = `ls -sl`;
	string $split[];
	for($each in $sel){
		string $splitChild[];
		string $children[]= `listRelatives -ad $sel`;
		for ($in in $children){
		tokenize $in ":" $splitChild;
		rename $in $splitChild[(size($splitChild)-1)];
		}
		//tokenize $each ":" $split;
		//rename $each $split[(size($split)-1)];
	}
	}

////MOVE
global proc rcSetPivot(string $opt){
    string $sel[] = `ls -sl`;
    string $selLast[] = `ls -sl -tail 1`;
    string $copyToObj = $selLast[0];
    float  $pivotSel[] = `xform -q -piv -ws $copyToObj`;
    float  $bounds[];
    switch ($opt){
        case "YMax":
        	for ($each in $sel)
        	{
        		$bounds = `xform -q -ws -bb $each`;
        		move -a (($bounds[3] + $bounds[0])/2) $bounds[4] (($bounds[5] + $bounds[2])/2) ($each + ".rotatePivot") ($each + ".scalePivot");
        	}
        	break;
        case "YMin":
        	for ($each in $sel)
        	{
        		$bounds= `xform -q -ws -bb $each`;
        		move -a (($bounds[3] + $bounds[0])/2) $bounds[1] (($bounds[5] + $bounds[2])/2) ($each + ".rotatePivot") ($each + ".scalePivot");
        	}
        	break;
        case "XMin":
        	for ($each in $sel)
        	{
        		$bounds = `xform -q -ws -bb $each`;
        		move -a $bounds[0] (($bounds[1] + $bounds[4])/2) (($bounds[5] + $bounds[2])/2) ($each + ".rotatePivot") ($each + ".scalePivot");
        	}
        	break;
        case "XMax":
        	for ($each in $sel)
        	{
        		$bounds= `xform -q -ws -bb $each`;
        		move -a $bounds[3] (($bounds[1] + $bounds[4])/2) (($bounds[5] + $bounds[2])/2) ($each + ".rotatePivot") ($each + ".scalePivot");
        	}
        	break;
        case "ZMin":
        	for ($each in $sel)
        	{
        		$bounds = `xform -q -ws -bb $each`;
        		move -a (($bounds[3] + $bounds[0])/2) (($bounds[1] + $bounds[4])/2) $bounds[2] ($each + ".rotatePivot") ($each + ".scalePivot");
        	}
        	break;
        case "ZMax":
        	for ($each in $sel)
        	{
        		$bounds = `xform -q -bb $each`;
        		move -a (($bounds[3] + $bounds[0])/2) (($bounds[1] + $bounds[4])/2) $bounds[5] ($each + ".rotatePivot") ($each + ".scalePivot");
        	}
        	break;
        case "ORIGIN":
           print "yea";
           xform -ws 0;
        
        case "CENTER":
        	for ($each in $sel) CenterPivot $each;
        	break;
        case "SELECTED":
        	select -deselect $selLast[0];
        	for ($each in $sel) move -a $pivotSel[0] $pivotSel[1] $pivotSel[2] ($each + ".rotatePivot") ($each + ".scalePivot");
        	
    }
	}
global proc rcMoveSel(string $opt){ 
    string $sel[] = `ls -sl`;
    string $selLast[] = `ls -sl -tail 1`;
    float $pivotSel[] = `xform -q -piv -ws $selLast[0]`;
    float $pivRotate[]=`xform -q -rp $selLast[0]`;
    float $bounds[];
    switch ($opt)
    {
        case "ORIGIN":
        	for ($each in $sel) move -a 0 0 0 -rpr $each;
        	break;
     
        case "SELECTED":
        	select -deselect $selLast[0];
        	for ($each in $sel) 
        		move -a $pivotSel[0] $pivotSel[1] $pivotSel[2] -rpr $each;
        		rotate -xyz  $pivRotate[0] $pivRotate[1] $pivRotate[2]  $each;
        	break;
 
    }
	}
global proc rcMirrorCombine(){ //Custom proc for Zbrush Work
	string $sel[] = `ls -sl`;
		for ($each in $sel){	
			makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;
			move -a 0 0 0 ($each + ".rotatePivot") ($each + ".scalePivot");
			string $other[] = `duplicate -rr`;
			select -r $other[0];
			setAttr ($each+ ".scaleX") -1;
			select -r $other[0] $each;
			CombinePolygons;
			polySetToFaceNormal -setUserNormal ;
			DeleteHistory;
		};	
	}
////OBJECTS
global proc rcCreateBDrop(){//Create Studio Backdrop
	int $scale=20;
	string $curve01= `curve -d 3 -p 0 15 9 -p 0 13 9 -p 0 8 9.61946 -p 0 0.640116 8.059457 -p 0 -0.165449  2.171225 -p 0 -0.0222301 -1.443407 -p 0 -0.0605563 -6.30102 -p 0 -0.0504705 -9.544369 -p 0 -0.0518153 -11.388446 -p 0  -0.0524876 -12.310485 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 7 -k 7 `;
	setAttr ($curve01 +".translateX") $scale;
	string $curve02[]= `duplicate -rr`;
	setAttr ($curve02[0] +".translateX") (-$scale);
	select -r $curve01 $curve02[0];
	string $loft[]=`loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 1 -rsn true $curve01 $curve02[0]`;
	string $connects[];
	}
////RETURN STRINGS
global proc string   iconLoc(){
	string $os = `about -os`;
	string $iconLoc;
	 if (`gmatch $os "*win*"`|| `gmatch $os "*nt*"` ) $iconLoc= `getenv "USERPROFILE"` + "/Google Drive/scripts/icons/";
	 if (`gmatch $os "mac"`) $iconLoc= "/Volumes/PDSA3/ARTISTS_FILES/scripts/icons/"; 
	return $iconLoc;
	}
global proc string   replaceFlags(string $FileNamePrefix){
	string $AbsPrefix;
	string $currentLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
	$AbsPrefix= substituteAllString ($FileNamePrefix ,"<RenderLayer>",$currentLayer);
	return $AbsPrefix;
	}
global proc string[] rcGetDirs( string $input ){//////////////////
	rcRLMAdd;
	string $dirs[] = {};
	string $path="";
	switch($input){
		case "-scenes":
			$path = (`workspace -q -rd` + "scenes/");
			break;
		case "-images":
			$path = (`workspace -q -rd` + "images/"+ (`getAttr renderLayerManager.ImageFileFolder`)+"/");
			break;
		case "-render":
			$path = (`workspace -q -rd` + "scenes/"+ (`getAttr renderLayerManager.renderFolderLocation`)+ "/render/"); 
			break;
			print ("input= "+$input+"\n");
	 $path=$input;
	 print ("Path= "+$path+"\n");
	}
	print ("Path= "+$path+"\n");
	string $files[] = `getFileList -folder ( $path +"/" )`;
	if( `substring $path (size($path)) (size($path))` != "/" ) $path += "/";
	for( $file in $files ) if( `filetest -d ( $path + $file )` ) {
		 $dirs[( `size $dirs` )] = $file;}
	return $dirs;
	}
global proc string[] rcListReferenceFileNames(){    //List Reference Files
	string $refsInScene[]=`ls -type "reference"`; // List References by Namespace
	string $references[]=`file -q -l -wcn  `;//List References by FileName
	return $references;
	}
global proc string[] rcListLightFlag(){                      //Custom String Array of Light Attributes
	string $rcListLightFlag[];
	$rcListRenderFlags[0]="intensity";
	$rcListRenderFlags[0]="coneAngle";
	return $rcListLightFlag;
	}
global proc string[] rcListShader(int$opt){               //String Array Specific Shaders in Scene
	string $rcListShader[];
	string $grossShaderList[]=`ls -mat`;
	for ($int=0; $int < size($grossShaderList);$int++) 
		//EXCLUDE LIST
		if(!`gmatch $grossShaderList[$int] "particleCloud1*"`)
		if(!`gmatch $grossShaderList[$int] "lambert1*"`)
		if(!`gmatch $grossShaderList[$int] "*displace*"`)
		//if(!`gmatch $grossShaderList[$int] "*_Disp*"`)
		$rcListShader[size($rcListShader)]=$grossShaderList[$int];
	return $rcListShader;
	}
global proc float  [] rcLookUpColor(string $shader){       //Float Array Shader Color
	string $Attr[]=`listAttr $shader`;
	float $inColor[];
	for ($each in $Attr){
		if (`gmatch $each "outColor"`) {
			$inColor = `getAttr ($shader + ".outColor")`;
			break;
		}
		if (`gmatch $each "color"`) {
			if (`nodeType $shader` == "rampShader")break;
			if (`nodeType $shader` == "fluidShape")break;
			$inColor = `getAttr ($shader + ".color")`;
			break;
		}
		if (`gmatch $each "diffuse_color"`) {
			$inColor = `getAttr ($shader + ".diffuse_color")`;
			break;
		}
	}	
	return $inColor;
	}
global proc string[] rcListRenderLayers(string $opt){      //RenderLayer
	string $grossrenderLayers[]= `ls -typ "renderLayer"`;
	string $renderlayers[];
	switch($opt){
		case "NoNS":
			for ($layer in $grossrenderLayers) if (!`gmatch $layer "*:*"`) $renderlayers[size($renderlayers)]=$layer;
			break;
		case "ALL":
			for ($layer in $grossrenderLayers)$renderlayers[size($renderlayers)]=$layer;
			break;
		case "ON":
			for ($layer in $grossrenderLayers) if ((!`gmatch $layer "*:*"`) && (`getAttr ($layer+".renderable")`)) $renderlayers[size($renderlayers)]=$layer;
			break;
	}
	return $renderlayers;
	}
global proc string[] rcListRenderCameras(){           //RenderCameras
	string $cameras[]=`ls -ca`;
	string $renderableCameras[];
	for ($each in $cameras) if (`getAttr ($each + ".renderable")`)$renderableCameras[size($renderableCameras)] = $each;
	return $renderableCameras;
	}
global proc string   rcReturnLastNS(string $input){  //String Last in Namespace
	string $split[];tokenize $input ":" $split;
	int $end = (size($split)-1);
	return $split[$end];
	}
global proc int       rcSmoothCommand(string $opt){  //	
	int $Smooth;
	int $RSmooth= `intFieldGrp -q -v1 RenderSmoothField`;
	int $DSmooth= `intFieldGrp -q -v1 DisplaySmoothField`;
	if ($opt == "-r") $Smooth = $RSmooth; 
	if ($opt == "-d") $Smooth = $DSmooth;
	return $Smooth;
	}
global proc float     fpsFloat() {
	string $frameRateUnit = `currentUnit -q -f -t`;
	switch ($frameRateUnit){
		case "film":
			return 24;
			break;
		case "ntsc":
			return 30;
			break;
		case "ntscf":
			return 60;
			break;
		case "game":
			return 15;
			break;
		case "show":
			return 48;
			break;
		case "pal":
			return 24;
			break;
		case "palf":
			return 50;
			break;
		case "hour":
			return (1/3600);
			break;
		case "min":
			return (1/60);
			break;
		case "sec":
			return 1;
			break;
		case "millisec":
			return 1000;
			break;

		default:
			return 0;
			break;
	}
	}

////CREATE SHADING/LAYERS
global proc rcCreateLayer(string $layer){  //Create Proc
	renderMR;
	//setCurrentTabInRenderGlobalsWindow "Features";//Workaround to get features to be setup
	if(!(`objExists $layer`)) {
		switch($layer){
			case "AODPTHINC":
				createRenderLayer -n "AODPTHINC";
				editRenderLayerGlobals -currentRenderLayer "AODPTHINC";
				rcAssignShader ADI;
				//RENDERGLOBALS
				editRenderLayerAdjustment "miDefaultOptions.lensShaders";
				setAttr "miDefaultOptions.lensShaders" 0;
				editRenderLayerAdjustment "miDefaultFramebuffer.datatype";
				setAttr "miDefaultFramebuffer.datatype" 16;//   5 is 32bit 16 is 16bit
				editRenderLayerAdjustment "defaultRenderGlobals.imageFormat";
				setAttr "defaultRenderGlobals.imageFormat" 51;
				setAttr -type "string" "defaultRenderGlobals.imfPluginKey" "exr";
				setAttr mentalrayGlobals.imageCompression 4;
				break;
		
			case "MASK_RGB":
				createRenderLayer -n "MASK_RGB";
				editRenderLayerGlobals -currentRenderLayer "MASK_RGB";
				rcAssignShader RGB;
				//RENDERGLOBALS
				editRenderLayerAdjustment "miDefaultOptions.lensShaders";
				setAttr "miDefaultOptions.lensShaders" 0; 
				editRenderLayerAdjustment "miDefaultOptions.rayTracing";
				setAttr "miDefaultOptions.rayTracing" 0;
				break;
				
			case "CONTOUR":
				createRenderLayer -n "CONTOUR";
				editRenderLayerGlobals -currentRenderLayer "CONTOUR";
				rcAssignShader CONTOUR;
				//RENDERGLOBALS
				setAttr "miDefaultFramebuffer.contourEnable" 1;//ON CONTOUR
				setAttr "miDefaultOptions.contourBackground" 1;
				setAttr "miDefaultFramebuffer.contourFilter" 2;
				setAttr "miDefaultFramebuffer.contourSamples" 32;
				setAttr "miDefaultFramebuffer.contourFilterSupport" 2;
				break;
		createRenderLayer -n $layer;
		}	
	}	
	}
global proc rcCreateShader(string $shader){          //Create Proc
  string $shaderName= $shader+ "_MAT"; 
  string $SG_Name = $shader + "SG";
  if(!(`objExists $shaderName`)) switch($shader){
   	  case "RED":
  	    shadingNode -n $shaderName -asShader surfaceShader;
  	    sets -renderable true -noSurfaceShader true -empty -name ($shader +"SG");
      	    connectAttr -f ($shaderName +".outColor") ($SG_Name +".surfaceShader");
  	    setAttr ($shaderName + ".outColor") -type double3 1 0 0 ;
  	    setAttr ($shaderName + ".outMatteOpacity") -type double3 1 1 1 ;
  	    break;
  	  case "GREEN":
  	    shadingNode -n $shaderName -asShader surfaceShader;
  	    sets -renderable true -noSurfaceShader true -empty -name ($shader +"SG");
      	    connectAttr -f ($shaderName +".outColor") ($SG_Name +".surfaceShader");
  	    setAttr ($shaderName + ".outColor") -type double3 0 1 0 ;
  	    setAttr ($shaderName + ".outMatteOpacity") -type double3 1 1 1 ;
  	    break;
  	   
  	  case "BLUE":
  	    shadingNode -n $shaderName -asShader surfaceShader;
  	    sets -renderable true -noSurfaceShader true -empty -name ($shader +"SG");
      	    connectAttr -f ($shaderName +".outColor") ($SG_Name +".surfaceShader");
  	    setAttr ($shaderName + ".outColor") -type double3 0 0 1 ;
  	    setAttr ($shaderName + ".outMatteOpacity") -type double3 1 1 1 ;
      	    break;
      	   case "CYAN":
  	    shadingNode -n $shaderName -asShader surfaceShader;
  	    sets -renderable true -noSurfaceShader true -empty -name ($shader +"SG");
      	    connectAttr -f ($shaderName +".outColor") ($SG_Name +".surfaceShader");
  	    setAttr ($shaderName + ".outColor") -type double3 0 1 1 ;
  	    setAttr ($shaderName + ".outMatteOpacity") -type double3 1 1 1 ;
  	    break;
  	    
  	  case "MAGENTA":
  	    shadingNode -n $shaderName -asShader surfaceShader;
  	    sets -renderable true -noSurfaceShader true -empty -name ($shader +"SG");
      	    connectAttr -f ($shaderName +".outColor") ($SG_Name +".surfaceShader");
  	    setAttr ($shaderName + ".outColor") -type double3 1 0 1;
  	    setAttr ($shaderName + ".outMatteOpacity") -type double3 1 1 1 ;
  	    break;
  	    
  	  case "YELLOW":
  	    shadingNode -n $shaderName -asShader surfaceShader;
  	    sets -renderable true -noSurfaceShader true -empty -name ($shader +"SG");
      	    connectAttr -f ($shaderName +".outColor") ($SG_Name +".surfaceShader");
  	    setAttr ($shaderName + ".outColor") -type double3 1 1 0;
  	    setAttr ($shaderName + ".outMatteOpacity") -type double3 1 1 1 ;
  	    break;
  	  case "BLACK":
  	    shadingNode -n $shaderName -asShader surfaceShader;
  	    sets -renderable true -noSurfaceShader true -empty -name ($shader +"SG");
      	    connectAttr -f ($shaderName +".outColor") ($SG_Name +".surfaceShader");
  	    setAttr ($shaderName + ".outColor") -type double3 0 0 0;
  	    setAttr ($shaderName + ".outMatteOpacity") -type double3 1 1 1 ;
  	    break;
  	  case "CON_S":
      	    shadingNode -n $shaderName -asShader lambert;
      	    sets -renderable true -noSurfaceShader true -empty -name ($shader +"SG");
      	    connectAttr -f ($shaderName +".outColor") ($SG_Name +".surfaceShader");
      	    setAttr ($SG_Name + ".miContourEnable") 1;
      	    setAttr ($SG_Name + ".miContourWidth") .5;
      	    setAttr ($shaderName +".color") -type double3 0 0 0 ;
      	    setAttr ($shaderName +".diffuse") 0;
      	    break;
      case "CON_M":
      	    shadingNode -n $shaderName -asShader lambert;
      	    sets -renderable true -noSurfaceShader true -empty -name ($shader +"SG");
      	    connectAttr -f ($shaderName +".outColor") ($SG_Name +".surfaceShader");
      	    setAttr ($SG_Name + ".miContourEnable") 1;
      	    setAttr ($SG_Name + ".miContourWidth") 1.00;
      	    setAttr ($shaderName +".color") -type double3 0 0 0 ;
      	    setAttr ($shaderName +".diffuse") 0;
      	    break;
      case "CON_L":
      	    shadingNode -n $shaderName -asShader lambert;
      	    sets -renderable true -noSurfaceShader true -empty -name ($shader +"SG");
      	    connectAttr -f ($shaderName +".outColor") ($SG_Name +".surfaceShader");
      	    setAttr ($SG_Name + ".miContourEnable") 1;
      	    setAttr ($SG_Name + ".miContourWidth") 2.00;
      	    setAttr ($shaderName +".color") -type double3 0 0 0 ;
      	    setAttr ($shaderName +".diffuse") 0;
      	    break;
      case "ALPHA":
      	    shadingNode -n $shaderName -asShader useBackground;
      	    sets -renderable true -noSurfaceShader true -empty -name ($shader +"SG");
      	    connectAttr -f ($shaderName +".outColor") ($SG_Name +".surfaceShader");
      	    rcAssignRenderAtt "miFinalGatherCast" 0 1;
      	    setAttr ($shaderName +".specularColor") 0 0 0 ;
      	    setAttr ($shaderName +".reflectivity") 0 ;
      	    setAttr ($shaderName +".reflectionLimit") 0 ;
      	    setAttr ($shaderName +".shadowMask" ) 0;
      	    break;
      case "RAMP_C":
      	    shadingNode -n "RAMP_C_MAT" -asShader blinn;
      	    sets -renderable true -noSurfaceShader true -empty -name ($shader +"SG");
      	    connectAttr -f ($shaderName +".outColor") ($SG_Name +".surfaceShader");
      	    string $sampler = `createNode -n "Sampler_RAMP_C" samplerInfo`;
      	    string $ramp = `shadingNode -asTexture ramp`;
      	    connectAttr -f ($sampler +".facingRatio") ($ramp+".vCoord");
      	    connectAttr -force ($ramp+".outColor") ("RAMP_C_MAT.transparency");
      	    // create mult/div. input2Z = -1.
      	    break;
      	    
      case "RAMP_A":
      	    shadingNode -n "RAMP_A_MAT" -asShader blinn;
      	    sets -renderable true -noSurfaceShader true -empty -name ($shader +"SG");
      	    connectAttr -f ($shaderName +".outColor") ($SG_Name +".surfaceShader");
      	    string $sampler = `createNode -n "Sampler_RAMP_A" samplerInfo`;
      	    string $ramp = `shadingNode -asTexture ramp`;
      	    //Make BW Ramp
      	    removeMultiInstance -break true ($ramp+".colorEntryList[1]");
      	    setAttr ($ramp+".colorEntryList[0].color") -type double3 1 1 1 ;
      	    setAttr ($ramp+".colorEntryList[0].position") 1 ;
      	    setAttr ($ramp+".colorEntryList[2].color") -type double3 0 0 0 ;
      	    connectAttr -f ($sampler +".facingRatio") ($ramp+".vCoord");
      	    connectAttr -force ($ramp+".outColor") ("RAMP_A_MAT.transparency"); 
      	    break;
      case "AO":
      	   	 $surfNode=`shadingNode -n $shaderName -asShader surfaceShader`;
      	   	 $occNode=`mrCreateCustomNode -asTexture "" mib_amb_occlusion`;
      	   	 connectAttr -force ($occNode + ".outValue") ($surfNode+".outColor");
      	   	 break;
      	   	 
      case "DPTH":
      	   	warningCameraCompliant;
      	   	string $RenderableCameras[]= rcListRenderCameras();
      	   	select $RenderableCameras[0]; string $renderCam[] = `pickWalk -d "up"`;
      	   	shadingNode -asShader -n $shaderName surfaceShader;
      	   	sets -renderable true -noSurfaceShader true -empty -name ($shader +"SG");
      	   	connectAttr -f ($shaderName +".outColor") ($SG_Name +".surfaceShader");
      	   	string $sampler = `createNode -n ("DpthSampler_"+$renderCam[0]) samplerInfo`;
      	    // create mult/div. input2Z = -1.
      	    string $DepthMult = `createNode -n ("DpthMult_"+$renderCam[0]) multiplyDivide`;
      	    setAttr ($DepthMult+".input2Z") -1;
      	    // create setRange. minZ = 0, maxZ = 1.
      	    string $SetRange = `createNode -n ("DpthRange_" + $renderCam[0]) setRange`;
      	    setAttr($SetRange + ".minZ" ) 0; setAttr( $SetRange + ".maxZ" ) 1;
      	    // connect pointCameraZ to multDiv.input1Z. // connect multDiv.outputZ setRange.valueZ
      	    connectAttr ($sampler+".pointCameraZ") ($DepthMult+".input1Z"); connectAttr ($DepthMult+".outputZ") ($SetRange+".valueZ");
      	   	break;   	
      case "INC":
      		  string $sampler = `createNode -n ("INC_sampler") samplerInfo`;
      		 string $INCname= `shadingNode -asShader -n $shaderName surfaceShader`;
      		 $rampFR = `createNode -n "ramp_FacingRatio" ramp`;
      	     setAttr($rampFR+".colorEntryList[1].color") -type double3 0 0 0;
      	     setAttr($rampFR+".colorEntryList[0].color") -type double3 1 1 1;
      	     setAttr($rampFR+".colorEntryList[1].position") 1;
      	     connectAttr($sampler+".facingRatio") ($rampFR+".vCoord");
      	     connectAttr($rampFR+".outColor") ("INC_MAT.outColor");
      	     break;
      	     
      case "ADI":
       		 warningCameraCompliant;
       		 string $RenderableCameras[]= rcListRenderCameras();
       		 select $RenderableCameras[0]; string $renderCam[] = `pickWalk -d "up"`;
      	     // create surface shader.
      	     string $ADIname = `shadingNode -asShader -n $shaderName surfaceShader`;
      	     sets -renderable true -noSurfaceShader true -empty -name ($shader +"SG");
      	     connectAttr -f ($shaderName +".outColor") ($SG_Name +".surfaceShader");
      	     // create samplerInfo.
      	     string $sampler = `createNode -n ("DpthSampler_"+$renderCam[0]) samplerInfo`;
      	     // create mult/div. input2Z = -1.
      	     string $DepthMult = `createNode -n ("DpthMult_"+$renderCam[0]) multiplyDivide`;
      	     setAttr ($DepthMult+".input2Z") -1;
      	     // create setRange. minZ = 0, maxZ = 1.
      	     string $SetRange = `createNode -n ("DpthRange_" + $renderCam[0]) setRange`;
      	     setAttr($SetRange + ".minZ" ) 0; setAttr( $SetRange + ".maxZ" ) 1;
      	     // connect pointCameraZ to multDiv.input1Z. // connect multDiv.outputZ setRange.valueZ
      	     connectAttr ($sampler+".pointCameraZ") ($DepthMult+".input1Z"); connectAttr ($DepthMult+".outputZ") ($SetRange+".valueZ");
      	     // create NURBS sphere, radius 1. delete history. name farClip. lock translate/rotate. override to "reference." parent to camera.
      	     string $farClip[] = `sphere -r 1 -n ("farClipSphere_"+ $renderCam[0])`;
      	     pointConstraint $renderCam[0] $farClip[0];
      	     string $sphereShape[] = `listRelatives -s $farClip[0]`;
      	     setAttr ($sphereShape[0]+".overrideEnabled") 1; setAttr ($sphereShape[0]+".overrideDisplayType") 1; //setAttr ($sphereShape[0]+".visibility") 0;
      	     // duplicate first sphere, name nearClip.
      	     string $nearClip[] = `duplicate -n ("nearClipSphere_"+$renderCam[0]) $farClip[0]`;
      	     pointConstraint $renderCam[0] $nearClip[0];
      	     setAttr -lock true ($farClip[0]+".tx");setAttr -lock true ($farClip[0]+".ty");setAttr -lock true ($farClip[0]+".tz");
      	     setAttr -lock true ($farClip[0]+".rx");setAttr -lock true ($farClip[0]+".ry");setAttr -lock true ($farClip[0]+".rz");
      	     setAttr -lock true ($nearClip[0]+".tx");setAttr -lock true ($nearClip[0]+".ty");setAttr -lock true ($nearClip[0]+".tz");
      	     setAttr -lock true ($nearClip[0]+".rx");setAttr -lock true ($nearClip[0]+".ry");setAttr -lock true ($nearClip[0]+".rz");
      	     if(`attributeExists "farDepth" $shaderName`)  print("Shader already has attachments...");
      	     else{
      	      	      addAttr -ln "farDepth"  -at double  -min 0 -dv 1000 $shaderName;
      	      	      addAttr -ln "nearDepth" -at double -min 0 -dv 1 $shaderName;
      	      	      addAttr -ln "occlusionDistance" -at double -min 0 -dv 10 $shaderName;
      	      	      addAttr -ln "occlusionSamples" -at double -min 8 -dv 64 $shaderName;
      	      	      setAttr -e -keyable true ($shaderName+".farDepth");
      	      	      setAttr -e -keyable true ($shaderName+".nearDepth");
      	      	      setAttr -e -keyable true ($shaderName+".occlusionDistance");
      	      	      setAttr -e -keyable true ($shaderName+".occlusionSamples");
      	      	      addAttr -ln "VisibiltyofSpheres"  -at bool  $shaderName;
      	     }
             connectAttr ($shaderName+".farDepth") ($farClip[0]+".scaleX"); connectAttr ($shaderName+".farDepth") ($farClip[0]+".scaleY"); connectAttr ($shaderName+".farDepth") ($farClip[0]+".scaleZ");
             connectAttr ($shaderName+".nearDepth") ($nearClip[0]+".scaleX"); connectAttr ($shaderName+".nearDepth") ($nearClip[0]+".scaleY"); connectAttr ($shaderName+".nearDepth") ($nearClip[0]+".scaleZ");
     	     connectAttr ($farClip[0]+".scaleZ") ($SetRange+".oldMaxZ");
     	     connectAttr ($nearClip[0]+".scaleZ") ($SetRange+".oldMinZ");
             // DEPTH 
      	     connectAttr ($SetRange+".outValueZ") ($ADIname+".outColorR");
      	     // AO
      	     $aoTex = `mrCreateCustomNode -asTexture "" mib_amb_occlusion`;
      	     connectAttr ($shaderName+".occlusionDistance") ($aoTex+".max_distance");
      	     connectAttr ($shaderName+".occlusionSamples") ($aoTex+".samples");
      	     connectAttr($aoTex+".outValueG") ($ADIname+".outColorG");
      	     //INC
      	     $rampFR = `createNode -n "ramp_FacingRatio" ramp`;
      	     setAttr($rampFR+".colorEntryList[1].color") -type double3 0 0 0;
      	     setAttr($rampFR+".colorEntryList[0].color") -type double3 0 0 1;
      	     setAttr($rampFR+".colorEntryList[1].position") 1;
      	     connectAttr($sampler+".facingRatio") ($rampFR+".vCoord");
      	     connectAttr($rampFR+".outColorB") ($ADIname+".outColorB");
             // for error correction, make some message attributes on the camera that connect to all created nodes. we'll search for these and delete
             // them if the script is run more than once.
             if(`attributeExists "farClipSphere" $shaderName`)  print("camera already has message attrs...");
             else {
      	      	      addAttr -at "message" -ln "occlusionTex" $shaderName;
      	      	      addAttr -at "message" -ln "rampTex" $shaderName;
      	     }
      	     connectAttr ($aoTex+".message") ($shaderName+".occlusionTex");
      	     connectAttr ($rampFR+".message") ($shaderName+".rampTex");
      	     select -r $shaderName;
      	     break;
            case "MIA":
      	   
      	     break;
  	}
	}
global proc rcCreateDisplacementSwitch(string $shader){       //CREATE SWITCH FOR DISPLACEMENT
	if(!(`objExists ($shader + "_Disp")`)) {
		shadingNode  -n ($shader + "_Disp") -asShader displacementShader;
		if(!(`objExists ($shader + "_Disp_Switch")`)) shadingNode  -n ($shader + "_Disp_Switch") -asUtility singleShadingSwitch;
		connectAttr -f ($shader + "_Disp_Switch" + ".output") ($shader + "_Disp" + ".displacement");
		connectAttr -f ($shader + "_Disp" + ".displacement") ($shader +"SG.displacementShader");
	}
	}
////ASSIGN 
global proc rcAssignLayer(string $layer){
	string $selObjShort[] = `ls -sl`;   
	string $selObj[] = `ls -sl -dag`;
	string $renderlayers[]= `lsType ("renderLayer")`;
	//slopppppy right here
	int $on=0; for ($each in $renderlayers) if ($each==$layer) $on=1;
	if (!$on) rcCreateLayer $layer;
	//Include Objects In Layer
	editRenderLayerMembers -noRecurse $layer $selObj;
	rcAssignShader $layer;
	for ($each in $selObj){
            select $each;            
            string $eachSn[] = `pickWalk -d down`;
            if (!($each == $eachSn[0])) editRenderLayerMembers -remove $layer $eachSn[0]; 
        }
	editRenderLayerGlobals -currentRenderLayer $layer;
	}
global proc rcAssignShader(string $shader){
	$shaderName= $shader+ "_MAT";
	string $selObjShort[] = `ls -sl`;   
	string $selObj[] = `ls -sl -dag`;
	if(!(`objExists $shaderName`)) rcCreateShader $shader;
	//if (size($selObjShort) == 0 ) warning "No Object Selected";  
	for ($each in $selObj){
		string $nodeType = `nodeType $each`;
		if (($nodeType == "mesh") || ($nodeType == "nurbsSurface")){
                    select $each;
                    string $eachSn[] = `pickWalk -d up`; 
                    string $conAll[] = `listConnections -d 1 $each`;
                    for ($con in $conAll)
                    {
                    	    string $conType = `nodeType $con`;  
                    	    if ($conType == "shadingEngine")
                    	    {
                    	    	    string $dispCon[] = `listConnections -d 1 -p 1 ($con + ".displacementShader")`; 
                    	    	    if (size($dispCon) >= 1)
                    	    	    {
                    	    	    	    string $dispinput[] =`listConnections -s 1 -p 1 $dispCon`;
                    	    	    	    if(`gmatch $dispinput[0] "*SG*"`) $dispinput[0]= $dispCon[0];
                    	    	    	    rcAssignDisplacementSwitch $shader $each $dispinput[0];
                    	    	    } 
                    	    	    select $eachSn[0];
                    	    	    hyperShade -assign $shaderName;
                    	    }                
                    }
                }  
        }
	}
global proc rccAssignDisplacementSwitch(string $shader, string $obj, string $dispinput){
	rcCreateDisplacementSwitch $shader;
	string $switchArray[]=`listConnections ($shader +"_Disp_Switch.input")`;
	int $size= `size $switchArray`;
	connectAttr -f ($obj +".instObjGroups[0]")  ($shader + "_Disp_Switch.input[" + $size +"].inShape");
	connectAttr -f ($dispinput) ($shader + "_Disp_Switch.input[" + $size +"].inSingle");
	}

////SET
global proc rcSetCameraClip(float $near, float $far) {
	string $panelSet[] = {"modelPanel1", "modelPanel2", "modelPanel3", "modelPanel4"};
	for($thisPanel in $panelSet){
	string $camera = `modelEditor -q -camera $thisPanel`; 
	eval select `getCameraNode view $camera` `getCameraNode up $camera` $camera;
	setAttr ($camera + ".nearClipPlane") $near;
	setAttr ($camera + ".farClipPlane") $far;
	};
    };
global proc rcSetImagePrefix(string $opt){//Image Prefix Flags
	rcSetGlobals -d;
	string $rcRenderFolder = `getAttr renderLayerManager.shotName`;
	string $prompt = `promptDialog -title "Create File Name Prefix" -m "SHOT:" -tx $rcRenderFolder  -button "OK" -button "Empty"`;
	string $CtrlName =`promptDialog -query -text`;
	if ( `attributeQuery -node renderLayerManager -exists "ImageFileFolder"`)setAttr -type "string" renderLayerManager.ImageFileFolder $CtrlName;
	//if ( `attributeQuery -node renderLayerManager -exists "renderFolderLocation"`) setAttr -type "string" renderLayerManager.renderFolderLocation $CtrlName;
	switch ($opt){
		case "L__L":
		 setAttr -type "string" defaultRenderGlobals.imageFilePrefix ($CtrlName+"/<RenderLayer>/<RenderLayer>");
		 break;
		case "L__L_P":
		 setAttr -type "string" defaultRenderGlobals.imageFilePrefix ($CtrlName+"/<RenderLayer>/<RenderLayer>_<RenderPass>");
		 break;
		case "L__L.P":
		 setAttr -type "string" defaultRenderGlobals.imageFilePrefix ($CtrlName+"/<RenderLayer>/<RenderLayer>.<RenderPass>");
		 break;
		case "L__P__L_P":
		 setAttr -type "string" defaultRenderGlobals.imageFilePrefix ($CtrlName+"/<RenderLayer>/<RenderPass>/<RenderLayer>_<RenderPass>");
		 break;
		case "L__P__L.P":
		 setAttr -type "string" defaultRenderGlobals.imageFilePrefix ($CtrlName+"/<RenderLayer>/<RenderPass>/<RenderLayer>.<RenderPass>");
		 break;
	}
	}

global proc rcSetRenderLayers(int $opt){
	for ($each in (rcListRenderLayers("ALL"))) setAttr ($each+".renderable") $opt;
	}
global proc rcSetSmooth(string $opt){
	if (!`objExists smoothSet`) sets -name "smoothSet";
	string $selection[] = `ls -sl`;
	for ($each in $selection){
		sets -edit -fe  smoothSet $each;
		setAttr ( $each + ".useSmoothPreviewForRender") 0;
		switch($opt){
		 case "-r":
		 setAttr ( $each + ".renderSmoothLevel") `rcSmoothCommand -r`;
		 break;
		 case "-d":
		 setAttr ( $each + ".smoothLevel") `rcSmoothCommand -d`;
		 break;	 
		}
	}
	select smoothSet;
	displaySmoothness -divisionsU 3 -divisionsV 3 -pointsWire 16 -pointsShaded 4 -polygonObject 3;
    subdivDisplaySmoothness -smoothness 3;
	}	

global proc rcSetGrid(string $opt){ 
	string $split[]; tokenize $opt "." $split;
	switch($opt){
		case "A":
			grid -s 100 -sp 5;
			break;
		case "B":
			grid -s 100 -sp 10;
			break;
		case "C":
			grid -s 100 -sp 100;
			break;
		case "D":
			grid -s 100 -sp 1000;
			break;	}
	}
global proc rcSetView(string $opt){//PY IS BETTER
	$allPanels=`getPanel -vis`;
	$currentPanel= `getPanel -withFocus`;
	$emptySelConn = `selectionConnection`; 
	switch($opt){
		case "POLY":
			modelEditor -e -allObjects 0 $currentPanel;
			modelEditor -e -polymeshes 1 $currentPanel;
			grid -toggle 0;
			break;
		case "CTRL":
			modelEditor -e -allObjects 0 $currentPanel;
			modelEditor -e -polymeshes 1 $currentPanel;
			modelEditor -e -handles 1 $currentPanel;
			modelEditor -e -locators 1 $currentPanel;
			grid -toggle 0;
			break;
		case "SHOWALL":
			modelEditor -e -allObjects 1 $currentPanel;
			grid -toggle 1;
			break;
		case "GREEN":
			if(`displayPref -q -displayGradient`)displayPref -displayGradient false;
			displayRGBColor "background" 0.000 1.000 0.000 ;  
			grid -toggle 0;
			break;
		case "GREY":
			if(`displayPref -q -displayGradient`)displayPref -displayGradient false;
			displayRGBColor "background" .561 .561 .561;
			grid -toggle 1;
			break;
		case "GRAD":
			displayPref -displayGradient true;
			grid -toggle 1;
			break;
		case "HUDON":
			
			break;
		case "ALLOFF":
			for( $panel in $allPanels ){
				isolateSelect -state (!0) $panel;
				if( `getPanel -to $panel` == "modelPanel" ) modelEditor -e -mlc $emptySelConn $panel;
			}
		case "ALLON":
			for( $panel in $allPanels ){
				isolateSelect -state (!1) $panel;
				if( `getPanel -to $panel` == "modelPanel" ) modelEditor -e -mlc $emptySelConn $panel;
			}
			break;
		////HYBRID
		case "BLAST":
			rcSetView GREEN;
			rcSetView POLY;
			break;	
	}
	}
global proc rcSetRefRenderLayers(){
	///Remove All RenderLayersFromRefernce
	///Create Layers Command
	for ($file in rcListReferenceFileNames()){
		string $command;
		for ($layer in (rcListRenderLayers("NoNS"))){
		$command+= "if(!(`objExists " + $layer +"`))";
		$command+= "createRenderLayer -name " + $layer +";";
		}
		string $executeCommand= "system mayabatch -c \"" + $command + "\"" + "-f " + $file+ "\"";
		print $executeCommand;
		eval $executeCommand;	
	}	
	}

global proc rcSetGlobals(string $opt){
	renderMR;unifiedRenderGlobalsWindow; warningCameraCompliant;  //COMMANDS
	//DEFAULT NAME.#.ext
	setAttr defaultRenderGlobals.extensionPadding 4; setAttr defaultRenderGlobals.outFormatControl 0;
	setAttr defaultRenderGlobals.animation 1; setAttr defaultRenderGlobals.putFrameBeforeExt 1;
	//FORCE PNG 16-BIT IF NOT EXR 32
	if (!(`getAttr "defaultRenderGlobals.imageFormat"`==51)){
		setAttr mentalrayGlobals.imageCompression 1; 
		setAttr "defaultRenderGlobals.imageFormat" 32;
		setAttr "defaultRenderGlobals.outFormatControl" 0;
		setAttr "miDefaultFramebuffer.datatype" 16;//Half 16-bit
		}
	//*****OPTIONS
	switch ($opt){
		//Entry Point for Image Prefix
		case "-layers":
		 rcSetImagePrefix L__L;
		 break;
		case "-passes":
		 rcSetImagePrefix L__P__L.P;
		 break;
		//AA
		case "HIGH":
		 setAttr "miDefaultOptions.minSamples" 0;
		 setAttr "miDefaultOptions.maxSamples" 2;
		 setAttr "miDefaultOptions.filter" 3;
		 setAttr miDefaultOptions.contrastR 0.02;setAttr miDefaultOptions.contrastG 0.02;setAttr miDefaultOptions.contrastB 0.02;setAttr miDefaultOptions.contrastA 0.02;
		 break;
		case "MED":
		 setAttr "miDefaultOptions.minSamples" 0;
		 setAttr "miDefaultOptions.maxSamples" 2;
		 setAttr "miDefaultOptions.filter" 3;
		 setAttr miDefaultOptions.contrastR 0.05;setAttr miDefaultOptions.contrastG 0.05;setAttr miDefaultOptions.contrastB 0.05;setAttr miDefaultOptions.contrastA 0.05;
		 break;
		case "LOW":
		 setAttr "miDefaultOptions.minSamples" -2;
		 setAttr "miDefaultOptions.maxSamples" 0;
		 setAttr miDefaultOptions.contrastR 0.10;setAttr miDefaultOptions.contrastG 0.10;setAttr miDefaultOptions.contrastB 0.10;setAttr miDefaultOptions.contrastA 0.10;
		 break;
		//IMAGE FORMAT
		case "PNG":
		 setAttr mentalrayGlobals.imageCompression 1;
		 setAttr "defaultRenderGlobals.imageFormat" 32;
		 setAttr "defaultRenderGlobals.outFormatControl" 0;
		 setAttr "miDefaultFramebuffer.datatype" 16;//Half 16-bit
		 setAttr mentalrayGlobals.imageCompression 1;
		 control -edit -enable false startExtensionCtrl;
		 updateMentalRayImageFormatControl;
		 updateMentalRayImageFormatControl;
		 updateMayaSoftwareTargetFilePreview;
		 
		 break;
		case "EXR":
		 setAttr defaultRenderGlobals.imageFormat 51; 
		 setAttr -type "string" "defaultRenderGlobals.imfPluginKey" "exr";
		 setAttr defaultRenderGlobals.imfkey -type "string" "exr";
		 setAttr mentalrayGlobals.imageCompression 4;
		 setAttr "miDefaultFramebuffer.datatype" 5;//Full 32-bit	
		 break;
		//FG
		case "FG.SOFT":
		 setAttr "miDefaultOptions.finalGather" 1;
		 setAttr "miDefaultOptions.finalGatherRays" 50;
		 setAttr "miDefaultOptions.finalGatherPresampleDensity" 0.1;
		 setAttr "miDefaultOptions.finalGatherPoints" 30;
		 setAttr "miDefaultOptions.finalGatherFilter" 2;
		 setAttr "miDefaultOptions.finalGatherMode" 3;
		 break;
		case "FG.MED":
		 setAttr "miDefaultOptions.finalGather" 1;
		 setAttr "miDefaultOptions.finalGatherRays" 250;
		 setAttr "miDefaultOptions.finalGatherPresampleDensity" 0.1;
		 setAttr "miDefaultOptions.finalGatherPoints" 20;
		 setAttr "miDefaultOptions.finalGatherFilter" 2;
		 setAttr "miDefaultOptions.finalGatherMode" 3;
		 break;
		case "FG.HIGH":
		 setAttr "miDefaultOptions.finalGather" 1;
		 setAttr "miDefaultOptions.finalGatherRays" 500;
		 setAttr "miDefaultOptions.finalGatherPresampleDensity" 0.25;
		 setAttr "miDefaultOptions.finalGatherPoints" 10;
		 setAttr "miDefaultOptions.finalGatherFilter" 2;
		 setAttr "miDefaultOptions.finalGatherMode" 3;
		 break;
	}
	}
global proc rcBrowse(int $opt,string $textField){
	$workspace= (`workspace -q -rd`+ "/scenes/");
	$return= `fileDialog2 -ds 2 -dir $workspace -fm 3 -okc "Set" -cc "Cancel"`;
	string $path= $return[0];
	string $path_tmp[]; tokenize $path "/" $path_tmp;
	string $ShotFolder = $path_tmp[`size($path_tmp)`-1];
	if ($opt==1) textFieldButtonGrp -e -text $ShotFolder $textField;
	if ($opt==2) textFieldButtonGrp -e -text $return[0] $textField;	
	}
///////FRAME LAYOUTS FOR rcToolbox
proc rcTBoxFrameImagePrefix(int $on){//rcToolBox Frame: ImagePrefix
	rcRLMAdd;
	//MENU VARIABLES (have to be Copied)
	 int $floating = 0;//0=docked 1=Floating
	 int $tabHeight= 190; 
	 int $textHeight=10; 
	 int $sHeight= 190;
	 string  $defaultDockArea= "left";  // "top", "left", "bottom", "right";
	 int $margin =2; 
	 int $borders=2;
	 int $buttons_small=15; int $buttons_med=20; int $buttons_large=30;
	 int $checkBoxHeight=15;
	 int $separator_small=5;int $seperator_large=15;
	 int $rowWidth=280;
	 int $paneHeight=650;
	 string $workingUnits = `currentUnit -q`; string $currentFPS = `currentUnit -q -time`;
	frameLayout -mh $margin -cll 1 -bgc .2 .2 .2 -fn "smallBoldLabelFont" -cl (!$on) -l "ASSIGN GLOBALS";
	 
	 rowColumnLayout -w $rowWidth -numberOfColumns 4;
	 text   -w 50-font "tinyBoldLabelFont" -h $textHeight -l "ANTI \nALIAS:" -al "right";
	 button -h $buttons_large -w ($rowWidth/4) -l " LOW -2/0 \n.10"  -c "rcSetGlobals LOW";
	 button -h $buttons_large -w ($rowWidth/4) -l " MED 0/2  \n.05" -c "rcSetGlobals MED";
	 button -h $buttons_large -w ($rowWidth/4) -l " HI  0/2 \n.02" -c "rcSetGlobals HIGH";
	
	 text  -w 50 -font "tinyBoldLabelFont" -h $textHeight -l "FINAL \nGATHER:" -al "right";
	 button -h $buttons_large -w ($rowWidth/4) -l " LOW 50/.1 \n.10"  -c "rcSetGlobals FG.SOFT";
	 button -h $buttons_large -w ($rowWidth/4) -l " MED 250/.1  \n.05" -c "rcSetGlobals FG.MED";
	 button -h $buttons_large -w ($rowWidth/4) -l " HI  500/.25 \n.02" -c "rcSetGlobals FG.HIGH";

	 text  -w 50 -font "tinyBoldLabelFont" -h $textHeight -l "IMAGE \nFORMAT:" -al "right";
	 button  -w ($rowWidth/4) -l "PNG \n 16BIT" -h $buttons_large -c "rcSetGlobals PNG";
	 button  -w ($rowWidth/4) -en 0 -l "TIF \n 16BIT" -h $buttons_large -c "rcSetGlobals TIF";
	 button  -w ($rowWidth/4) -l "EXR \n 32BIT" -h $buttons_large -c "rcSetGlobals EXR";
	 
	 text  -w 50 -font "tinyBoldLabelFont" -h $textHeight -l "IMAGE \nPREFIX:" -al "right";
	 button -h $buttons_med -bgc .4 .2 .4 -w ($rowWidth/4)-l "Layers"  -c "rcSetGlobals -layers";
	 button -h $buttons_med -bgc .4 .2 .4 -w ($rowWidth/4)-l "Passes" -c "rcSetGlobals -passes";
	 setParent..;
	 //text 	-font "tinyBoldLabelFont" -h $textHeight -l `getAttr "defaultRenderGlobals.imageFilePrefix"`; 
	 frameLayout -mh $margin -cll 1  -fn "smallBoldLabelFont"  -l "settings";
	 scrollLayout -cr 1 -h 175 -w $rowWidth;
	 text   -font "tinyBoldLabelFont" -h $textHeight -l "  File Name Prefix:" -al "left";
	 separator -h $separator_small -style "none";
	 rowColumnLayout -cat 1 "both" 5 -numberOfColumns 2 ;
	 text   -align "center" -font "tinyBoldLabelFont"-h $buttons_small -l "SHOT NAME";
	 text   -align "right" -font "tinyBoldLabelFont"-h $buttons_small -l "= <SH>";
	 text   -align "center" -font "tinyBoldLabelFont" -h $buttons_small -l "<RenderLayers>";
	 text   -align "right" -font "tinyBoldLabelFont" -h $buttons_small -l "= <RL>";
	 text   -align "center" -font "tinyBoldLabelFont"-h $buttons_small -l "<RenderPasses>";
	 text   -align "right" -font "tinyBoldLabelFont"-h $buttons_small -l "= <RP>";
	 setParent..;
	 separator -h $separator_small -style "in";
	 button -bgc .2 .2 .2 -h $buttons_med -l "<SH>/<RL>/<RL>"  -c "rcSetImagePrefix L__L";
	 button -bgc .2 .2 .2 -h $buttons_med -l "<SH>/<RL>/<RL>_<RP>" -c "rcSetImagePrefix L__L_P";
	 button -bgc .2 .2 .2 -h $buttons_med -l "<SH>/<RL>/<RL>.<RP>" -c "rcSetImagePrefix L__L.P";
	 button -bgc .2 .2 .2 -h $buttons_med -l "<SH>/<RL>/<RP>/<RL>_<RP>"  -c "rcSetImagePrefix L__P__L_P";
	 button -bgc .2 .2 .2 -h $buttons_med -l "<SH>/<RL>/<RP>/<RL>.<RP>"  -c "rcSetImagePrefix L__P__L.P";
	 
	 setParent..;
	 setParent..;
	 setParent..;
	 //text   -font "tinyBoldLabelFont" -h $textHeight -l "  Assign Smooth Mesh:" -al "left";
	
	 //text -font "boldLabelFont" -l "ASSIGN RENDER STATS:";//MATERIALS
	 //separator -h $seperator_large;
	}

proc AFXList(){
	if (`objExists "AE_OBJ_Set"`){
		select "AE_OBJ_Set";
		string $bakelist[]=`ls -sl`;
		for( $each in $bakelist){
			text -l $each;
		}
	}
	//select "AE_OBJ_Set";}
	}
///UI
global proc rcRenderMGR(){
	int $menuwidth=250; int $menuheight=300; int $textHeight=20;
	if (`window -ex rcRenderMGRWin`) deleteUI -window rcRenderMGRWin;
	window -t "RenderMGR v1.0" -h ($menuheight*2)  rcRenderMGRWin;
	rowLayout  -h ($menuheight*2) -nc 2 rcMainRow;// 
	
	columnLayout -w $menuwidth -h (($menuheight*2)+($textHeight*8))  rcColumnOutliner;//
	paneLayout -w $menuwidth -h (($menuheight*2)+($textHeight*8)) -cn "horizontal2" AE_PaneLayout;//
	string $rcOutliner= `outlinerPanel`;
	filterUIClearFilter $rcOutliner;
	string $rcpanel = `outlinerPanel -q -oe $rcOutliner`; 
        outlinerEditor -e 
        	-mainListConnection "worldList"
        	-selectionConnection "modelList"
        	-showShapes false
        	-showAttributes false
        	-showConnected false
        	-showAnimCurvesOnly false
        	-autoExpand true
        	-showDagOnly true
        	-ignoreDagHierarchy false
        	-expandConnections false
        	-showCompounds true
        	-showNumericAttrsOnly false
        	-highlightActive true
        	-autoSelectNewObjects false
        	-doNotSelectNewObjects false
        	-transmitFilters false
        	-showSetMembers true
        	-setFilter defaultSetFilter
        	$rcpanel;
        setParent rcMainRow;
        
        rowColumnLayout -numberOfColumns 1;    
        separator -style "none" -h 5;    
        text -font "boldLabelFont" -l "RENDER LAYERS MANAGER";    
        separator -style "in" -h 3;    
        rowColumnLayout -numberOfColumns 3;
        
        text -font "boldLabelFont" -h $textHeight -l "RENDER LAYERS";
        text -font "boldLabelFont" -h $textHeight -l "OBJECTS"; 
        text -font "boldLabelFont" -h $textHeight -l "OVERRIDES";   
        
        textScrollList -w $menuwidth -h $menuheight -nr 4 -ams 1 -sc "rcRLMListConnect()" -dcc "gotoRLayer()" layList; 
        textScrollList -w $menuwidth -h $menuheight -nr 4 -ams 1 -dcc "selPass objList" objList; 
        textScrollList -w $menuwidth -h $menuheight -nr 4 -ams 1 conList; 
        rcRLMListLayers();
        
        button -h $textHeight -l "Refresh" -c "updateRLayer()" btn1;
        button -h $textHeight -l "Add Object" -ann "Add object to the select render layer." -c "addObjLayer()" btn2; 
        button -h $textHeight -l "Remove Override" -ann "Remove override to the select render layer." -c "removeOverLayer()" btn3;
        
        button -h $textHeight -l "Delete Layer" -ann "Delete Render Layer." -c "deleteRLayer()" btn4;
        button -h $textHeight -l "Remove Object" -ann "remove object to the select render layer." -c "removeObjLayer()" btn5; 
        button -h $textHeight -l "Select Objects" -ann "Select objects selected in the Objects List." -c "selectObjList objList" btn6;
        
        button -h $textHeight -l "Go to MasterLayer" -c "gotoMLayer()" btn7;
        button -h $textHeight -l "Rename Layer" -ann "Rename selected render layer." -c "renameLayer()" btn8;
        textField -h $textHeight renameLayers;
        setParent ..;
        rowColumnLayout -w 60 -numberOfColumns 5;
        text -font "boldLabelFont" -l "Scene Passes";text -font "boldLabelFont" -l "Associated Passes";text -font "boldLabelFont" -l "Associated Contr. Maps"; text -font "boldLabelFont" -l "Passes used by Contr. Map"; text -font "boldLabelFont" -l "Objects in Contr. Map";    
        textScrollList -w $menuwidth -h $menuheight -nr 4 -ams 1 -dcc "selPass scenePassList" scenePassList; textScrollList -w $menuwidth -h $menuheight -nr 4 -ams 1 -dcc "selPass passList" passList; textScrollList -w $menuwidth -h $menuheight-nr 4 -sc "rcRLMListContrMapObj()" contMapList; textScrollList -nr 4 -ams 1 -dcc "selPass assoContMapList" assoContMapList; textScrollList -nr 4 -ams 1 -dcc "selPass objContMapList" objContMapList;
        rcRLMListPasses();
        button -h $textHeight -l "Create My Default Passes" -c "createMyRPasses()" btn9; button -h $textHeight  -l "Associate Pass" -c "associatePass()" btn10; button -l "Add Object"  -c "addObjContrPass()" btn11; button -l "Associate Contr. Pass" -c "associatePassContMap()" btn12; button -l "Select Objects" -ann "Select objects selected in the Objects List." -c "selectObjListCont" btn13;
        button -h $textHeight -l "Delete Pass" -c "deletePass()" btn14; button -h $textHeight -l "De-associate Pass" -c "removePass()" btn15; button -l "Remove Object" -c "removeObjContrPass()" btn16; button -l "De-associate Contr. Pass" -c "disassociatePass()" btn17; button -l "Create Passes Window" -c "renderPassesCreateRenderPassNode 0" btn18;     
        button -h $textHeight -l "Create Contr. Map" -c "createContrMap()" btn19; button -h $textHeight -l "Delete Contr. Map" -c "deleteContrMap()" btn20; button -l "Rename Contr. Map" -c "renameContrMap()" btn21;textField renameContrMap;
        button -h $textHeight -l "Copy selected Render Layer" -bgc .5 .8 .5 -c "copyRLayer()" btn22;
        button -h $textHeight -l "Export Selected Render Layers" -bgc .5 .8 .5 -c "rcExportRenderLayerMel()" btn23;
        button -h $textHeight -l "Import Render Layers" -bgc .5 .8 .5 -c "importRenderLayer()" btn24;
        enableBtn();
     showWindow;
	
	}
////
global proc progWin(){
	int $progress=0;
	int$percent=0;
	progressWindow -t "Baking..." -min 0 -max 200 -pr $progress;
	}

global proc rcRefRemove(){
	string $sel[]=`ls -sl`;
	for ($each in $sel){
	//string $edit[] = `referenceQuery -es $each`;
	referenceEdit -r $each;	
	print $each;
	}}
global proc refreshShaderList(){
	int $buttons_small=15;int $buttons_med=20;int $buttons_large=28;
	int $rowWidth=280;
	if (!`window -ex rcToolBoxWin|TABS|SHADE|CURRENTMATERIALS|MATERIALIST`) deleteUI MayaWindow|TABS|SHADE|CURRENTMATERIALS|MATERIALIST;
	else deleteUI rcToolBoxWin|TABS|SHADE|CURRENTMATERIALS|MATERIALIST;
	setParent rcToolBoxWin|TABS|SHADE|CURRENTMATERIALS;
	scrollLayout -cr 1  -h (size (rcListShader(1))*($buttons_med) +10) -w $rowWidth MATERIALIST;
	for ($each in rcListShader(1)) {
		float $BGColor[]= rcLookUpColor($each);
		button -w 150 -h $buttons_med  -bgc  $BGColor[0] $BGColor[1] $BGColor[2] -l (rcReturnLastNS($each)) -c ("hyperShade -assign " + $each) ;
	}	
	}

////MISC
global proc toMiddle(string $x,string $y,string $z) {
    
    string $selObject[] = `ls -sl`;
    float $bBox[] = `exactWorldBoundingBox $selObject[0]`;
    xform -ws -p true -cp $selObject[0]; 
    float $centerPos[] = `xform -q -ws -sp $selObject[0]`;

    int $arrayX;
    int $arrayY;
    int $arrayZ;

    if ($y == "min")
    {
        $arrayY = 1;
    } else
    {
        $arrayY = 4;
    }

    if ($x == "min")
    {
        $arrayX = 0;
    } else
    {
        $arrayX = 3;    
    }

    if ($z == "min")
    {
        $arrayZ = 2;
    }else 
    {
        $arrayZ = 5;
    }

    xform -ws -piv $bBox[$arrayX] $bBox[$arrayY] $bBox[$arrayZ] $selObject[0];
	}
global proc Ctrl_JointsUI(){//Joints ON Curve
	if (`window -exists curveJoint`) deleteUI "curveJoint";
	window -t "nnJointsOnCurve" -w 200 -h 200 -mnb 1 -mxb 0 -s 1 curveJoint;
	columnLayout -adj 1 -columnAttach "both" 1 -rowSpacing 10 -columnWidth 250;
	intFieldGrp -l"Number of Joints" numberInt;
	checkBoxGrp -l"Rebuild the Curve" rebuildCheck;
	text -l "Select the Curve and press the Button" -fn "smallBoldLabelFont" ;
	button -l"<< Add Joint Chain on Curve >>" -h 30 -c ("Ctrl_Joints()") goButton;
	text -l"Scripted by - Nilesh Jadhav" -bgc 1 1 1;
	showWindow curveJoint;
	}
	
/////convert2MIA
proc string[] FilterNodeType(string $type, string $inputList[]) { 
       string $outputNodeList[]; 
       for ($input in $inputList) { 
               string $inputType = `nodeType $input`; 
               string $inputClass[] =`getClassification $inputType`; 
               // do this to a type node 
               if ($inputType == $type) { 
                       $outputNodeList[size($outputNodeList)] = $input; 
              	 } 
               // do this to non-shader object 
               else if ($inputType == "transform" || $inputType == "mesh" || $inputType == "nurbsSurface"){ 
                       string $shapeList[] = `listRelatives -ad -pa -type "surfaceShape" $input`;
                       $shapeList = stringArrayRemoveDuplicates($shapeList); 
                       for ($shape in $shapeList) 
                       { 
                               string $sg[] = `listConnections -type "shadingEngine" $shape`;
                                if (($sg[0] != "initialShadingGroup") && (size($sg)))
                                { 
                                       string $shadingNetwork[] = `listHistory -pdo 1 $sg[0]`;
                                        if (size($shadingNetwork)) 
                                       { 
                                               for ($outputNode in $shadingNetwork)
                                                { 
                                                       if (`nodeType $outputNode` == $type)
                                                        { 
                                                               $outputNodeList[size($outputNodeList)] = $outputNode;
                                                        } 
                                               } 
                                       } 
                               } 
                       } 
              	 } 
               // ...or do this to a shader 
               else  { 
                       string $shadingNetwork[] = `listHistory -pdo 1 $input`; 
                       if (size($shadingNetwork))  { 
                               for ($outputNode in $shadingNetwork)  { 
                                       if (`nodeType $outputNode` == $type) { 
                                               $outputNodeList[size($outputNodeList)] = $outputNode;
                                        } 
                               } 
                       } 
              	 } 
       	} 
       $outputNodeList = stringArrayRemoveDuplicates($outputNodeList); 
       return $outputNodeList; 
	} 
proc string createAndPrepareMia(string $shader) { 
       string $mia = `shadingNode -asShader -n ($shader+"_mia") mia_material_x_passes`;
       setAttr ".brdf_0_degree_refl" 1; 
       setAttr ".skip_inside_refl" 0; 
       setAttr ".refr_ior" 1.0 ; 
       //setAttr ".brdf_conserve_energy" off ; 
       //warning ("createAndPrepareMia: "+$mia+": 'brdf conserve energy' is turned off for visual equality with the Maya shader.  You should turn this back on for better physical accuracy.");
        return $mia; 
	} 
proc copyAttribute(string $src, string $dest) { 
       string $srcSplit[]; 
       tokenize $src "." $srcSplit; 
       string $srcNode = $srcSplit[0];  string $srcAttr = $srcSplit[1]; 
       string $srcScalar[] = `listAttr -s $src`; 
       string $destSplit[]; 
       tokenize $dest "." $destSplit; 
       string $destNode = $destSplit[0]; 
       string $destAttr = $destSplit[1]; 
       string $destScalar[] = `listAttr -s $dest`; 
       if (`attributeQuery -n $srcNode -uac $srcAttr` && `connectionInfo -id $src`){ 
                       string $inputNode = `connectionInfo -sfd $src`; 
                       connectAttr -f $inputNode $dest; 
       } 
       else { 
               for ($i = 0; $i < size($srcScalar); $i++) { 
                       if (`connectionInfo -id ($srcNode+"."+$srcScalar[$i])`) 
                       { 
                               string $inputNode = `connectionInfo -sfd ($srcNode+"."+$srcScalar[$i])`;
                                connectAttr -f $inputNode ($destNode+"."+$destScalar[$i]);
                        } 
                       else 
                       { 
                               float $srcValue = `getAttr ($srcNode+"."+$srcScalar[$i])`;
                                setAttr ($destNode+"."+$destScalar[$i]) $srcValue;
                        } 
               } 
       } 
	} 
global proc copyCommonAttributesToMiaMaterial(string $shader, string $mia) { 
       // color 
       copyAttribute(($shader+".color"), ($mia+".diffuse")); 
       // transparency- only set it up if we have transparency 
       float $trans[] = `getAttr ($shader+".transparency")`; 
       if ((`connectionInfo -id ($shader+".transparency")`) || ($trans[0] || $trans[1] || $trans[2] !=0))
       { 
               print $trans; 
               setAttr ($mia+".transparency") 1; 
               copyAttribute(($shader+".transparency"), ($mia+".refr_color")); 
       } 
       // ambient color 
       setAttr ($mia+".ao_on") true; 
       setAttr ($mia+".ao_samples") 0; 
       setAttr ($mia+".ao_distance") 0; 
       setAttr ($mia+".ao_do_details") 0; 
       setAttr ($mia+".ao_dark") -type double3 1 1 1; 
       copyAttribute(($shader+".ambientColor"), ($mia+".ao_ambient")); 
       // incandescence 
       copyAttribute(($shader+".incandescence"), ($mia+".additional_color")); 
       // bump mapping 
       if (`connectionInfo -id ($shader+".normalCamera")`)  { 
               string $srcBump = `connectionInfo -sfd ($shader+".normalCamera")`;
               connectAttr -f $srcBump ($mia+".overall_bump"); 
       } 

       // diffuse attr 
       copyAttribute(($shader+".diffuse"), ($mia+".diffuse_weight")); 

       // translucence 
       if (`getAttr ($shader+".translucence")` != 0) 
       { 
               setAttr ($mia+".refr_translucency") on; 
               copyAttribute(($shader+".color"), ($mia+".refr_trans_color")); 
               copyAttribute(($shader+".translucence"), ($mia+".refr_trans_weight"));
                // multiply it by the transparency... 
               if (`getAttr ($mia+".transparency")` != 0) 
               { 
                       // set translucency weight 
                       string $rev = `shadingNode -asUtility -n ($mia+"_refr_trans_weight_rev") reverse`;
                        string $lum = `shadingNode -asUtility -n ($mia+"_refr_trans_weight_lum") luminance`;
 
                       copyAttribute(($mia+".refr_color"), ($rev+".input")); 
                       connectAttr -f ($rev+".output") ($lum+".value"); 
                       connectAttr -f ($lum+".outValue") ($mia+".refr_trans_weight");
                       // set translucency color 
                       string $mult = `shadingNode -asUtility -n ($mia+"_refr_color_mult") multiplyDivide`;
                       copyAttribute(($shader+".color"), ($mult+".input1")); 
                       copyAttribute(($shader+".translucence"), ($mult+".input2X"));
                       copyAttribute(($shader+".translucence"), ($mult+".input2Y"));
                       copyAttribute(($shader+".translucence"), ($mult+".input2Z"));
                       connectAttr -f ($mult+".output") ($mia+".refr_trans_color");
 
                       // set transparency color 
                       string $rgbIn = `shadingNode -asUtility -n ($mia+"_refr_color_rgbIn") rgbToHsv`;
                       string $setRange = `shadingNode -asUtility -n ($mia+"_refr_color_setRange") setRange`;
                               setAttr ".minZ" 1; 
                               setAttr ".maxX" 1; 
                               setAttr ".maxY" 1; 
                               setAttr ".maxZ" 1; 
                               setAttr ".oldMaxX" 1; 
                               setAttr ".oldMaxY" 1; 
                               setAttr ".oldMaxZ" 1; 
                       string $rgbOut = `shadingNode -asUtility -n ($mia+"_refr_color_rgbOut") hsvToRgb`;
 
                       copyAttribute(($shader+".transparency"), ($rgbIn+".inRgb"));
                        connectAttr -f ($rgbIn+".outHsv") ($setRange+".value") ;
                        connectAttr -f ($setRange+".outValue") ($rgbOut+".inHsv") ;
                        connectAttr -f ($rgbOut+".outRgb") ($mia+".refr_color") ;
                } 
               else 
               { 
                       copyAttribute(($shader+".translucence"), ($mia+".transparency"));
                        setAttr ($mia+".refr_trans_weight") 1; 
               } 
       } 

       // raytracing 
       if (`getAttr ($shader+".refractions")` == 1) 
       { 
               copyAttribute(($shader+".refractiveIndex"), ($mia+".refr_ior")); 
               copyAttribute(($shader+".refractionLimit"), ($mia+".refr_depth"));
               if (`getAttr ($shader+".lightAbsorbance")` != 0) 
               { 
                       setAttr ($mia+".refr_falloff_on") true; 
                       copyAttribute(($shader+".lightAbsorbance"), ($mia+".refr_falloff_dist"));
                } 
       } 

       // mental ray 
       // irradiance 
       if (`connectionInfo -id ($shader+".miIrradianceColor")`) 
       { 
               string $input = `connectionInfo -sfd ($shader+".miIrradianceColor")`;
                string $lumaNode = `shadingNode -asUtility luminance`; 
               connectAttr -f $input ($lumaNode+".value") ; 
               connectAttr -f ($lumaNode+".outValue") ($mia+".indirect_multiplier");
        } 
       else 
       { 
               float $irrad[] = `getAttr ($shader+".miIrradianceColor")`; 
               float $indMult = ($irrad[0]+$irrad[1]+$irrad[2])/3; 
               setAttr ($mia+".indirect_multiplier") $indMult; 
       } 

       // refraction blur 
       if (`connectionInfo -id ($shader+".miRefractionBlur")`) 
       { 
               string $input = `connectionInfo -sfd ($shader+".miRefractionBlur")`;
                string $mult = `shadingNode -asUtility -n ($mia+"_refr_gloss_mult") multiplyDivide`;
                        setAttr ".input2X" 0.1 ; 
               string $rev = `shadingNode -asUtility -n ($mia+"_refr_gloss_rev") reverse`;
                connectAttr -f $input ($mult+".input1X"); 
               connectAttr -f ($mult+".outputX") ($rev+".inputX") ; 
               connectAttr -f ($rev+".outputX") ($mia+".refr_gloss") ; 
       } 
       else 
       { 
               float $refrBlur = `getAttr ($shader+".miRefractionBlur")`; 
               if ($refrBlur != 0) setAttr ($mia+".refr_gloss") (1-($refrBlur*.1)) ;
       } 
	} 
proc copyLambertAttributesToMiaMaterial(string $shader, string $mia) { 
       setAttr ($mia+".reflectivity") 0; 
	} 
proc copyPhongAttributesToMiaMaterial(string $shader, string $mia) { 
       if (`connectionInfo -id ($shader+".cosinePower")`) { 
               string $input = `connectionInfo -sfd ($shader+".cosinePower")`; 
               string $clamp = `shadingNode -asUtility -n ($mia+"_refl_gloss_clamp") clamp`;
                        setAttr ".maxR" 100 ; 
               string $mult = `shadingNode -asUtility -n ($mia+"_refl_gloss_mult") multiplyDivide`;
                        setAttr ".input2X" 0.01 ; 
               connectAttr -f $input ($clamp+".inputR") ; 
               connectAttr -f ($clamp+".outputR") ($mult+".input1X") ; 
               connectAttr -f ($mult+".outputX") ($mia+".refl_gloss") ; 
       } 
       else 
       { 
               float $cosine = `getAttr ($shader+".cosinePower")`; 
               setAttr ($mia+".refl_gloss") (clamp(0, 100, $cosine)*.01); 
       } 
       copyAttribute(($shader+".specularColor"), ($mia+".refl_color")) ; 
       copyAttribute(($shader+".reflectivity"), ($mia+".reflectivity")) ; 
       copyAttribute(($shader+".reflectionLimit"), ($mia+".refl_depth")) ; 
	} 
proc copyPhongEAttributesToMiaMaterial(string $shader, string $mia) { 
       warning "copyPhongEAttributesToMiaMaterial: certain phongE material settings are weird and unsupported... set the reflection glossiness in the mia material to approximate phongE specular attributes.";
        copyAttribute(($shader+".specularColor"), ($mia+".refl_color")) ; 
       copyAttribute(($shader+".reflectivity"), ($mia+".reflectivity")) ; 
       copyAttribute(($shader+".reflectionLimit"), ($mia+".refl_depth")) ; 

	} 
proc copyBlinnAttributesToMiaMaterial(string $shader, string $mia) { 
       // figure out that inverse eccentricity thing... it's roughly worked out...
        if (`connectionInfo -id ($shader+".eccentricity")`) 
       { 
               string $input = `connectionInfo -sfd ($shader+".eccentricity")`; 
               string $gamma = `shadingNode -asUtility -n ($mia+"_refl_gloss_gamma") gammaCorrect`;
               setAttr ".gammaX" 2.718 ; 
               string $rev = `shadingNode -asUtility -n ($mia+"_refl_gloss_rev") reverse`;
 
               connectAttr -f $input ($gamma+".valueX") ; 
               connectAttr -f ($gamma+".outValueX") ($rev+".inputX") ; 
               connectAttr -f ($rev+".outputX") ($mia+".refl_gloss") ; 
       } 
       else 
       { 
               float $ecc = `getAttr ($shader+".eccentricity")`; 
               float $thinger = 1-((exp($ecc)-.5) * .5); 
               setAttr ($mia+".refl_gloss") (1-((exp($ecc)-.5) * .5)) ; 
       } 

       // let's put the specular roll-off into the forward-facing reflectivity of the mia...
        copyAttribute(($shader+".specularRollOff"), ($mia+".brdf_0_degree_refl")) ;
 
       // do the standard specular stuff 
       copyAttribute(($shader+".specularColor"), ($mia+".refl_color")) ; 
       copyAttribute(($shader+".reflectivity"), ($mia+".reflectivity")) ; 
       copyAttribute(($shader+".reflectionLimit"), ($mia+".refl_depth")) ; 
	} 
proc copyAnisoAttributesToMiaMaterial(string $shader, string $mia) { 
       setAttr ($mia+".anisotropy_channel") -2 ; 
       // get angle, see if it's mapped first 
       if (`connectionInfo -id ($shader+".angle")`) 
       { 
               string $mult = `shadingNode -asUtility -n ($mia+"_anisotropy_rotation_mult") multiplyDivide`;
                        setAttr ".operation" 2 ; 
                       setAttr ".input1Y" 720 ; 
               copyAttribute(($shader+".angle"), ($mult+".input1X")); 
               connectAttr -f ($mult+".outputX") ($mia+".anisotropy_rotation") ;
        } 
       else 
       { 
               float $rotation = `getAttr ($shader+".angle")` / 720 ; 
               setAttr ($mia+".anisotropy_rotation") $rotation ; 
       } 
       // divide the x and y aniso values to approximate the mia anisotropy 
       if (`connectionInfo -id ($shader+".spreadX")` || `connectionInfo -id ($shader+".spreadY")`)
        { 
               string $div = `shadingNode -asUtility -n ($mia+"_anisotropy_div") multiplyDivide`;
                        setAttr ".operation" 2 ; 
               copyAttribute(($shader+".spreadY"), ($div+".input1X")); 
               copyAttribute(($shader+".spreadX"), ($div+".input1Y")); 
               connectAttr -f ($div+".outputX") ($mia+".anisotropy"); 
       } 
       else 
       { 
               float $anisoValue = `getAttr ($shader+".spreadY")` / `getAttr ($shader+".spreadX")`;
                setAttr ($mia+".anisotropy") $anisoValue ; 
       } 
       // finally roughness 
       if (`connectionInfo -id ($shader+".roughness")`) 
       { 
               string $inv = `shadingNode -asUtility -n ($mia+"_refl_gloss_inv") reverse`;
                copyAttribute ($shader+".roughness") ($inv+".inputX") ; 
               connectAttr -f ($inv+".outputX") ($mia+".refl_gloss") ; 
       } 
       else 
       { 
               float $gloss = 1 - `getAttr ($shader+".roughness")` ; 
               setAttr ($mia+".refl_gloss") $gloss ; 
       } 

       // figure out what to do with the anisotropic reflection attribute 
       if (`getAttr ($shader+".anisotropicReflectivity")`) 
               warning ("copyAnisoAttributesToMiaMaterial: "+$shader+": anisotropic reflectivity settings ignored.");
 
       copyAttribute(($shader+".specularColor"), ($mia+".refl_color")) ; 
       copyAttribute(($shader+".reflectivity"), ($mia+".reflectivity")) ; 
       copyAttribute(($shader+".reflectionLimit"), ($mia+".refl_depth")) ; 
	} 
global proc string MayaToMia(string $shader) { 
       string $mia = createAndPrepareMia($shader); 
       copyCommonAttributesToMiaMaterial($shader, $mia); 
       if (`nodeType $shader` == "lambert") copyLambertAttributesToMiaMaterial($shader, $mia);
        if (`nodeType $shader` == "phong") copyPhongAttributesToMiaMaterial($shader, $mia);
        if (`nodeType $shader` == "phongE") copyPhongEAttributesToMiaMaterial($shader, $mia);
        if (`nodeType $shader` == "blinn") copyBlinnAttributesToMiaMaterial($shader, $mia);
        if (`nodeType $shader` == "anisotropic") copyAnisoAttributesToMiaMaterial($shader, $mia);
 
       return $mia; 
	} 
global proc convert2MIA() { 
       string $selection[] = `ls -sl`; 
       
       string $shaderList[] ; 
       
       string $lambertList[] = FilterNodeType("lambert", $selection) ; 
       string $phongList[] = FilterNodeType("phong", $selection) ; 
       string $phongEList[] = FilterNodeType("phongE", $selection); 
       string $blinnList[] = FilterNodeType("blinn", $selection); 
       string $anisoList[] = FilterNodeType("anisotropic", $selection); 
       
       $shaderList = stringArrayCatenate($shaderList, $lambertList); 
       $shaderList = stringArrayCatenate($shaderList, $phongList); 
       $shaderList = stringArrayCatenate($shaderList, $phongEList); 
       $shaderList = stringArrayCatenate($shaderList, $blinnList); 
       $shaderList = stringArrayCatenate($shaderList, $anisoList); 
       
       print $shaderList ; 
       for ($shader in $shaderList) 
       { 
               string $mia = MayaToMia($shader) ; 
               string $sgList[] = `listConnections -type "shadingEngine" $shader`;
                for ($sg in $sgList) 
               { 
                       string $miaSG[] = `duplicate -ic -n ($mia + "SG") $sg` ; 
                       string $shader = `connectionInfo -sfd ($miaSG[0]+".surfaceShader")`;
                       disconnectAttr $shader ($miaSG[0]+".surfaceShader") ; 
                       connectAttr -f ($mia+".message") ($miaSG[0]+".miMaterialShader") ;
                       connectAttr -f ($mia+".message") ($miaSG[0]+".miPhotonShader") ;
                       connectAttr -f ($mia+".message") ($miaSG[0]+".miShadowShader") ;
                       string $assignedObjectList[] = `sets -q $sg`; 
                       sets -e -fe $miaSG[0] $assignedObjectList ; 
               } 

       } 
	}	

/////GAMMATOOLS
global proc gammaUIMain(){
	if (`window -q -ex gammaUIMainWindow`) deleteUI gammaUIMainWindow;
	string $sel[] = `ls -sl`;
	global string $selName; $selName = $sel[0];
	global string $selectedType; $selectedType = `objectType $selName`;
	global string $curAttr;
	global string $prefix;
	//                                    Test if supported object is selected.  If not, then exit with error message.
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if (($selectedType != "anisotropic") && ($selectedType != "blinn") && ($selectedType != "hairTubeShader") && ($selectedType != "lambert") &&      //
    ($selectedType != "oceanShader") && ($selectedType != "phong") && ($selectedType != "phongE") && ($selectedType != "shadingMap") &&         //
    ($selectedType != "surfaceShader") && ($selectedType != "useBackground") && ($selectedType != "envFog") &&                                                 //
    ($selectedType != "dgs_material") && ($selectedType != "dielectric_material") && ($selectedType != "mi_car_paint_phen") &&                              //
    ($selectedType != "mi_car_paint_phen_x") && ($selectedType != "mi_car_paint_phen_x_passes") && ($selectedType != "mi_metallic_paint") &&  //
    ($selectedType != "mi_metallic_paint_x") && ($selectedType != "mi_metallic_paint_x_passes") && ($selectedType != "mia_material") &&            //
    ($selectedType != "mia_material_x") && ($selectedType != "mia_material_x_passes"))                                                            //
    {  error "Select a supported shader first!"; deleteUI gammaUIMainWindow;}                                                                          //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	window -title "Gamma Adjust Color Swatches" -tlb 1 -sizeable false -rtf true gammaUIMainWindow;
	columnLayout -adjustableColumn true; 
	rowLayout -numberOfColumns 2
		-columnWidth2 100 85
		-columnAttach 1 "left" 6
		-columnAttach 2 "left" -7
		materialNameRow;
    text -label "Current Material: " materialTypeText;
    text -label $selName -font "boldLabelFont" materialTypeNameText;
    setParent..;
    separator -height 10 -style "in";
    //separator -height 10 -style "none";
    rowLayout -numberOfColumns 2
    	-columnWidth2 150 100
    	-columnAttach 1 "left" 2
    	-columnAttach 2 "left" 0
    	getNewSelectionRow;
    button -label "Refresh Selection" -c getNewSelection refreshMaterialButton;
    separator -height 10 -style "in";
    //text -label "" dummyText2;
    setParent..;
    frameLayout -label "Create Gamma Nodes"
    -labelIndent 142
    -cc getNewSelection CreateGammaButton;
    
    columnLayout -adjustableColumn true;
        rowLayout -numberOfColumns 1
        -columnAttach 1 "left" 0
        selectAllRow;

              button -label "Select All" 
              -c selectAllCheckBoxes
              selectAllButton;
              
        setParent..;

        separator -style "in";

        int $buildUIComplete = `gammaMatUI`; //  Build the necessary rows for the selected materials swatches

        separator -height 20 -style "none";

        rowLayout -numberOfColumns 5
        	-columnWidth5 76 80 100 80 50
        	-columnAttach 1 "left" 0
        	-columnAttach 2 "both" 0
        	-columnAttach 3 "both" 0
        	-columnAttach 4 "both" 0
        	-columnAttach 5 "right" 0
        	applyCancelRow;

        text -label "" dummyText1;
        button -label "Apply" -c applyPressed applyButton;
        button -label "Apply and Close" -c applyClosePressed applyCloseButton;
        button -label "Cancel" -c cancelPressed cancelButton;
       // text -label "" dummyText2;
    
        setParent..;

        showWindow gammaUIMainWindow;
	}
global proc int gammaMatUI(){
    global string $selName;
    global string $selectedType;
    global string $curAttr;
    global string $prefix;
    //                        Define sizes and defaults for menus
    //////////////////////////////////////////////////////////////////////////////////////////
    int $rowColumnWidth1 = 130; int $rowColumnWidth2 = 100; int $rowColumnWidth3 = 100;     //
    string $rowColumnAttachPos1 = "left"; int $rowColumnAttachOffset1 = 0;                  //
    string $rowColumnAttachPos2 = "both"; int $rowColumnAttachOffset2 = -90;                //
    string $rowColumnAttachPos3 = "left"; int $rowColumnAttachOffset3 = 30;                 //
    int $gammaColumnWidth = 50; float $gammaDefaultValue = .4545;                           //
    int $colorSwatchColumnWidth1 = 50; int $colorSwatchColumnWidth3 = 0;                    //
    //////////////////////////////////////////////////////////////////////////////////////////
    int $numberOfRowsForType = 0;
    string $attributes[] = {};
    switch ($selectedType) {//  Define amount of rows in menu and assign variables based on the selected shader type.
        case "anisotropic":
            $numberOfRowsForType = 6;
            $prefix = "anisotropic";
            $attributes[0] = "color"; $attributes[1] = "transparency"; $attributes[2] = "ambientColor"; $attributes[3] = "incandescence";
            $attributes[4] = "specularColor"; $attributes[5] = "reflectedColor";            
	    break;

        case "blinn":
            $numberOfRowsForType = 6;
            $prefix = "blinn";
            $attributes[0] = "color"; $attributes[1] = "transparency"; $attributes[2] = "ambientColor"; $attributes[3] = "incandescence";
            $attributes[4] = "specularColor"; $attributes[5] = "reflectedColor";
	    break;    

        case "hairTubeShader":
            $numberOfRowsForType = 6;
            $prefix = "hairTubeShader";
            $attributes[0] = "color"; $attributes[1] = "transparency"; $attributes[2] = "ambientColor"; $attributes[3] = "incandescence";
            $attributes[4] = "specularColor"; $attributes[5] = "reflectedColor";
	    break;               

        case "lambert":
            $numberOfRowsForType = 4;
            $prefix = "lambert";
            $attributes[0] = "color"; $attributes[1] = "transparency"; $attributes[2] = "ambientColor"; $attributes[3] = "incandescence";
	    break;      

        case "oceanShader":
            $numberOfRowsForType = 7;
            $prefix = "oceanShader";
            $attributes[0] = "waterColor"; $attributes[1] = "foamColor"; $attributes[2] = "transparency"; $attributes[3] = "incandescence";
            $attributes[4] = "ambientColor"; $attributes[5] = "specularColor"; $attributes[6] = "reflectedColor";
	    break;                  
        
        case "phong":
            $numberOfRowsForType = 6;
            $prefix = "phong";
            $attributes[0] = "color"; $attributes[1] = "transparency"; $attributes[2] = "ambientColor"; $attributes[3] = "incandescence";
            $attributes[4] = "specularColor"; $attributes[5] = "reflectedColor";
	    break; 

        case "phongE":
            $numberOfRowsForType = 7;
            $prefix = "phongE";
            $attributes[0] = "color"; $attributes[1] = "transparency"; $attributes[2] = "ambientColor"; $attributes[3] = "incandescence";
            $attributes[4] = "whiteness"; $attributes[5] = "specularColor"; $attributes[6] = "reflectedColor";
        break;      

        case "shadingMap":
            $numberOfRowsForType = 1;
            $prefix = "shadingMap";
            $attributes[0] = "shadingMapColor";
        break;

        case "surfaceShader":
            $numberOfRowsForType = 4;
            $prefix = "surfaceShader";
            $attributes[0] = "outColor"; $attributes[1] = "outTransparency"; $attributes[2] = "outGlowColor"; $attributes[3] = "outMatteOpacity";
        break;
        
        case "useBackground":
            $numberOfRowsForType = 1;
            $prefix = "useBackground";
            $attributes[0] = "specularColor";
        break;

        case "envFog":
            $numberOfRowsForType = 8;
            $prefix = "envFog";
            $attributes[0] = "color"; $attributes[1] = "fogColor"; $attributes[2] = "fogOpacity"; $attributes[3] = "airColor";
            $attributes[4] = "airOpacity"; $attributes[5] = "waterColor"; $attributes[6] = "waterOpacity"; $attributes[7] = "sunColor";
        break;              
        case "dgs_material":
            $numberOfRowsForType = 3;
            $prefix = "dgs_material";
            $attributes[0] = "diffuse"; $attributes[1] = "glossy"; $attributes[2] = "specular";
        break;
        case "dielectric_material":
            $numberOfRowsForType = 2;
            $prefix = "dielectric_material";
            $attributes[0] = "col"; $attributes[1] = "col_out";
        break;
        case "mi_car_paint_phen_x":
        case "mi_car_paint_phen_x_passes":
        case "mi_car_paint_phen":
            $numberOfRowsForType = 9;
            $prefix = "mi_car_paint_phen";
            $attributes[0] = "ambient"; $attributes[1] = "base_color"; $attributes[2] = "edge_color"; $attributes[3] = "lit_color";
            $attributes[4] = "spec"; $attributes[5] = "spec_sec"; $attributes[6] = "flake_color"; $attributes[7] = "reflection_color";
            $attributes[8] = "dirt_color";
        break;
        case "mi_metallic_paint_x":
        case "mi_metallic_paint_x_passes":
        case "mi_metallic_paint":
            $numberOfRowsForType = 7;
            $prefix = "mi_metallic_paint";
            $attributes[0] = "ambient"; $attributes[1] = "base_color"; $attributes[2] = "edge_color"; $attributes[3] = "lit_color";
            $attributes[4] = "spec"; $attributes[5] = "spec_sec"; $attributes[6] = "flake_color";
        break;

        case "mia_material_x":
        case "mia_material_x_passes":
        case "mia_material":
            $numberOfRowsForType = 9;
            $prefix = "mia_material";
            $attributes[0] = "diffuse"; $attributes[1] = "refl_color"; $attributes[2] = "refl_falloff_color"; $attributes[3] = "refr_color";
            $attributes[4] = "refr_falloff_color"; $attributes[5] = "refr_trans_color"; $attributes[6] = "ao_dark"; $attributes[7] = "ao_ambient";
            $attributes[8] = "additional_color";
        break;
        
        default:
            error ("something went wrong in Build UI" + "\n");
    }
        for ($i = 1; $i <= $numberOfRowsForType; $i++)
        {
            $curAttr = $attributes[$i - 1];
            string $checkBoxOnCmd;
            string $checkBoxOffCmd;            
            switch ($curAttr) { //  Define the attribute that the check box will control based on current attribute type.       
                case "color":
                    $checkBoxOnCmd = "gammaCHK 1 color";
                    $checkBoxOffCmd = "gammaCHK 0 color";
                    break;
                case "transparency":
                    $checkBoxOnCmd = "gammaCHK 1 transparency";
                    $checkBoxOffCmd = "gammaCHK 0 transparency";
                    break;
                case "ambientColor":
                    $checkBoxOnCmd = "gammaCHK 1 ambientColor";
                    $checkBoxOffCmd = "gammaCHK 0 ambientColor";
                    break;

                case "incandescence":
                    $checkBoxOnCmd = "gammaCHK 1 incandescence";
                    $checkBoxOffCmd = "gammaCHK 0 incandescence";
                    break;
                
                case "specularColor":
                    $checkBoxOnCmd = "gammaCHK 1 specularColor";
                    $checkBoxOffCmd = "gammaCHK 0 specularColor";
                    break;

                case "reflectedColor":
                    $checkBoxOnCmd = "gammaCHK 1 reflectedColor";
                    $checkBoxOffCmd = "gammaCHK 0 reflectedColor";
                    break;     

                case "waterColor":
                    $checkBoxOnCmd = "gammaCHK 1 waterColor";
                    $checkBoxOffCmd = "gammaCHK 0 waterColor";
                    break;                         

                case "foamColor":
                    $checkBoxOnCmd = "gammaCHK 1 foamColor";
                    $checkBoxOffCmd = "gammaCHK 0 foamColor";
                    break;   

                case "whiteness":
                    $checkBoxOnCmd = "gammaCHK 1 whiteness";
                    $checkBoxOffCmd = "gammaCHK 0 whiteness";
                    break;

                case "shadingMapColor":
                    $checkBoxOnCmd = "gammaCHK 1 shadingMapColor";
                    $checkBoxOffCmd = "gammaCHK 0 shadingMapColor";
                    break;
                
                case "outColor":
                    $checkBoxOnCmd = "gammaCHK 1 outColor";
                    $checkBoxOffCmd = "gammaCHK 0 outColor";
                    break;

                case "outTransparency":
                    $checkBoxOnCmd = "gammaCHK 1 outTransparency";
                    $checkBoxOffCmd = "gammaCHK 0 outTransparency";
                    break;                    

                case "outGlowColor":
                    $checkBoxOnCmd = "gammaCHK 1 outGlowColor";
                    $checkBoxOffCmd = "gammaCHK 0 outGlowColor";
                    break;   

                case "outMatteOpacity":
                    $checkBoxOnCmd = "gammaCHK 1 outMatteOpacity";
                    $checkBoxOffCmd = "gammaCHK 0 outMatteOpacity";
                    break;

                case "fogColor":
                    $checkBoxOnCmd = "gammaCHK 1 fogColor";
                    $checkBoxOffCmd = "gammaCHK 0 fogColor";
                    break;  

                case "fogOpacity":
                    $checkBoxOnCmd = "gammaCHK 1 fogOpacity";
                    $checkBoxOffCmd = "gammaCHK 0 fogOpacity";
                    break;  

                case "airColor":
                    $checkBoxOnCmd = "gammaCHK 1 airColor";
                    $checkBoxOffCmd = "gammaCHK 0 airColor";
                    break;  

                case "airOpacity":
                    $checkBoxOnCmd = "gammaCHK 1 airOpacity";
                    $checkBoxOffCmd = "gammaCHK 0 airOpacity";
                    break;   

                case "waterOpacity":
                    $checkBoxOnCmd = "gammaCHK 1 waterOpacity";
                    $checkBoxOffCmd = "gammaCHK 0 waterOpacity";
                    break;  

                case "sunColor":
                    $checkBoxOnCmd = "gammaCHK 1 sunColor";
                    $checkBoxOffCmd = "gammaCHK 0 sunColor";
                    break;

                case "diffuse":
                    $checkBoxOnCmd = "gammaCHK 1 diffuse";
                    $checkBoxOffCmd = "gammaCHK 0 diffuse";
                    break;   

                case "glossy":
                    $checkBoxOnCmd = "gammaCHK 1 glossy";
                    $checkBoxOffCmd = "gammaCHK 0 glossy";
                    break;  

                case "specular":
                    $checkBoxOnCmd = "gammaCHK 1 specular";
                    $checkBoxOffCmd = "gammaCHK 0 specular";
                    break;

                case "col":
                    $checkBoxOnCmd = "gammaCHK 1 col";
                    $checkBoxOffCmd = "gammaCHK 0 col";
                    break;  

                case "col_out":
                    $checkBoxOnCmd = "gammaCHK 1 col_out";
                    $checkBoxOffCmd = "gammaCHK 0 col_out";
                    break;

                case "ambient":
                    $checkBoxOnCmd = "gammaCHK 1 ambient";
                    $checkBoxOffCmd = "gammaCHK 0 ambient";
                    break;

                case "base_color":
                    $checkBoxOnCmd = "gammaCHK 1 base_color";
                    $checkBoxOffCmd = "gammaCHK 0 base_color";
                    break;  

                case "edge_color":
                    $checkBoxOnCmd = "gammaCHK 1 edge_color";
                    $checkBoxOffCmd = "gammaCHK 0 edge_color";
                    break;

                case "lit_color":
                    $checkBoxOnCmd = "gammaCHK 1 lit_color";
                    $checkBoxOffCmd = "gammaCHK 0 lit_color";
                    break;

                case "spec":
                    $checkBoxOnCmd = "gammaCHK 1 spec";
                    $checkBoxOffCmd = "gammaCHK 0 spec";
                    break;  

                case "spec_sec":
                    $checkBoxOnCmd = "gammaCHK 1 spec_sec";
                    $checkBoxOffCmd = "gammaCHK 0 spec_sec";
                    break;

                case "flake_color":
                    $checkBoxOnCmd = "gammaCHK 1 flake_color";
                    $checkBoxOffCmd = "gammaCHK 0 flake_color";
                    break;

                case "reflection_color":
                    $checkBoxOnCmd = "gammaCHK 1 reflection_color";
                    $checkBoxOffCmd = "gammaCHK 0 reflection_color";
                    break;  

                case "dirt_color":
                    $checkBoxOnCmd = "gammaCHK 1 dirt_color";
                    $checkBoxOffCmd = "gammaCHK 0 dirt_color";
                    break;

                case "refl_color":
                    $checkBoxOnCmd = "gammaCHK 1 refl_color";
                    $checkBoxOffCmd = "gammaCHK 0 refl_color";
                    break;

                case "refl_falloff_color":
                    $checkBoxOnCmd = "gammaCHK 1 refl_falloff_color";
                    $checkBoxOffCmd = "gammaCHK 0 refl_falloff_color";
                    break;  

                case "refr_color":
                    $checkBoxOnCmd = "gammaCHK 1 refr_color";
                    $checkBoxOffCmd = "gammaCHK 0 refr_color";
                    break;

                case "refr_falloff_color":
                    $checkBoxOnCmd = "gammaCHK 1 refr_falloff_color";
                    $checkBoxOffCmd = "gammaCHK 0 refr_falloff_color";
                    break;

                case "refr_trans_color":
                    $checkBoxOnCmd = "gammaCHK 1 refr_trans_color";
                    $checkBoxOffCmd = "gammaCHK 0 refr_trans_color";
                    break;  

                case "ao_dark":
                    $checkBoxOnCmd = "gammaCHK 1 ao_dark";
                    $checkBoxOffCmd = "gammaCHK 0 ao_dark";
                    break;

                case "ao_ambient":
                    $checkBoxOnCmd = "gammaCHK 1 ao_ambient";
                    $checkBoxOffCmd = "gammaCHK 0 ao_ambient";
                    break;

                case "additional_color":
                    $checkBoxOnCmd = "gammaCHK 1 additional_color";
                    $checkBoxOffCmd = "gammaCHK 0 additional_color";
                    break;                                                           
                                     
                default:
                    error ("something went wrong in Build UI build set check box calls" + "\n");
            }

            //  Build the rows
            
            rowLayout -numberOfColumns 3
            -columnWidth3 $rowColumnWidth1 $rowColumnWidth2 $rowColumnWidth3
            -columnAttach 1 $rowColumnAttachPos1 $rowColumnAttachOffset1
            -columnAttach 2 $rowColumnAttachPos2 $rowColumnAttachOffset2
            -columnAttach 3 $rowColumnAttachPos3 $rowColumnAttachOffset3
            ($prefix + "_" + $curAttr + "_Row");
        
                checkBoxGrp 
                  -numberOfCheckBoxes 1 -label1 $curAttr
                  -onc $checkBoxOnCmd
                  -ofc $checkBoxOffCmd
                  ($prefix + "_" + $curAttr + "_CheckBox");
            
                floatFieldGrp -numberOfFields 1 
                 -label "gamma>>" 
                 -columnWidth 2 $gammaColumnWidth
                 -pre 4
                 -value1 $gammaDefaultValue
                 -enable 0 
                  ($prefix + "_" + $curAttr + "_GammaField");
            
                attrColorSliderGrp -label "Set Color" -enable 0
                 -columnWidth 1 $colorSwatchColumnWidth1
                 -columnWidth 3 $colorSwatchColumnWidth3
                     -showButton false 
                 -attribute ($selName + "." + $curAttr)
                  ($prefix + "_" + $curAttr + "_Swatch");
              
             setParent..;

        separator -style "in";
        }
        
    return 1;
	}
global proc gammaCHK(int $bool, string $curAttr){
    global string $prefix;
    string $fullName = ($prefix + "_" + $curAttr);
    switch ($fullName) {
        case "anisotropic_color":
            floatFieldGrp -e -enable $bool anisotropic_color_GammaField;
            attrColorSliderGrp -e -enable $bool anisotropic_color_Swatch;
            break;
            
        case "anisotropic_transparency":
            floatFieldGrp -e -enable $bool anisotropic_transparency_GammaField;
            attrColorSliderGrp -e -enable $bool anisotropic_transparency_Swatch;
            break;
            
        case "anisotropic_ambientColor":
            floatFieldGrp -e -enable $bool anisotropic_ambientColor_GammaField;
            attrColorSliderGrp -e -enable $bool anisotropic_ambientColor_Swatch;
            break;

        case "anisotropic_incandescence":
            floatFieldGrp -e -enable $bool anisotropic_incandescence_GammaField;
            attrColorSliderGrp -e -enable $bool anisotropic_incandescence_Swatch;
            break;

        case "anisotropic_specularColor":
            floatFieldGrp -e -enable $bool anisotropic_specularColor_GammaField;
            attrColorSliderGrp -e -enable $bool anisotropic_specularColor_Swatch;
            break;

        case "anisotropic_reflectedColor":
            floatFieldGrp -e -enable $bool anisotropic_reflectedColor_GammaField;
            attrColorSliderGrp -e -enable $bool anisotropic_reflectedColor_Swatch;
            break;

        case "blinn_color":
            floatFieldGrp -e -enable $bool blinn_color_GammaField;
            attrColorSliderGrp -e -enable $bool blinn_color_Swatch;
            break;
            
        case "blinn_transparency":
            floatFieldGrp -e -enable $bool blinn_transparency_GammaField;
            attrColorSliderGrp -e -enable $bool blinn_transparency_Swatch;
            break;
            
        case "blinn_ambientColor":
            floatFieldGrp -e -enable $bool blinn_ambientColor_GammaField;
            attrColorSliderGrp -e -enable $bool blinn_ambientColor_Swatch;
            break;

        case "blinn_incandescence":
            floatFieldGrp -e -enable $bool blinn_incandescence_GammaField;
            attrColorSliderGrp -e -enable $bool blinn_incandescence_Swatch;
            break;           

        case "blinn_specularColor":
            floatFieldGrp -e -enable $bool blinn_specularColor_GammaField;
            attrColorSliderGrp -e -enable $bool blinn_specularColor_Swatch;
            break;

        case "blinn_reflectedColor":
            floatFieldGrp -e -enable $bool blinn_reflectedColor_GammaField;
            attrColorSliderGrp -e -enable $bool blinn_reflectedColor_Swatch;
            break;

        case "hairTubeShader_color":
            floatFieldGrp -e -enable $bool hairTubeShader_color_GammaField;
            attrColorSliderGrp -e -enable $bool hairTubeShader_color_Swatch;
            break;
            
        case "hairTubeShader_transparency":
            floatFieldGrp -e -enable $bool hairTubeShader_transparency_GammaField;
            attrColorSliderGrp -e -enable $bool hairTubeShader_transparency_Swatch;
            break;
            
        case "hairTubeShader_ambientColor":
            floatFieldGrp -e -enable $bool hairTubeShader_ambientColor_GammaField;
            attrColorSliderGrp -e -enable $bool hairTubeShader_ambientColor_Swatch;
            break;

        case "hairTubeShader_incandescence":
            floatFieldGrp -e -enable $bool hairTubeShader_incandescence_GammaField;
            attrColorSliderGrp -e -enable $bool hairTubeShader_incandescence_Swatch;
            break;           

        case "hairTubeShader_specularColor":
            floatFieldGrp -e -enable $bool hairTubeShader_specularColor_GammaField;
            attrColorSliderGrp -e -enable $bool hairTubeShader_specularColor_Swatch;
            break;

        case "hairTubeShader_reflectedColor":
            floatFieldGrp -e -enable $bool hairTubeShader_reflectedColor_GammaField;
            attrColorSliderGrp -e -enable $bool hairTubeShader_reflectedColor_Swatch;
            break;            

        case "lambert_color":
            floatFieldGrp -e -enable $bool lambert_color_GammaField;
            attrColorSliderGrp -e -enable $bool lambert_color_Swatch;
            break;
            
        case "lambert_transparency":
            floatFieldGrp -e -enable $bool lambert_transparency_GammaField;
            attrColorSliderGrp -e -enable $bool lambert_transparency_Swatch;
            break;
            
        case "lambert_ambientColor":
            floatFieldGrp -e -enable $bool lambert_ambientColor_GammaField;
            attrColorSliderGrp -e -enable $bool lambert_ambientColor_Swatch;
            break;

        case "lambert_incandescence":
            floatFieldGrp -e -enable $bool lambert_incandescence_GammaField;
            attrColorSliderGrp -e -enable $bool lambert_incandescence_Swatch;
            break;  

        case "oceanShader_waterColor":
            floatFieldGrp -e -enable $bool oceanShader_waterColor_GammaField;
            attrColorSliderGrp -e -enable $bool oceanShader_waterColor_Swatch;
            break;

        case "oceanShader_foamColor":
            floatFieldGrp -e -enable $bool oceanShader_foamColor_GammaField;
            attrColorSliderGrp -e -enable $bool oceanShader_foamColor_Swatch;
            break;            
            
        case "oceanShader_transparency":
            floatFieldGrp -e -enable $bool oceanShader_transparency_GammaField;
            attrColorSliderGrp -e -enable $bool oceanShader_transparency_Swatch;
            break;

        case "oceanShader_incandescence":
            floatFieldGrp -e -enable $bool oceanShader_incandescence_GammaField;
            attrColorSliderGrp -e -enable $bool oceanShader_incandescence_Swatch;
            break;            
            
        case "oceanShader_ambientColor":
            floatFieldGrp -e -enable $bool oceanShader_ambientColor_GammaField;
            attrColorSliderGrp -e -enable $bool oceanShader_ambientColor_Swatch;
            break;

        case "oceanShader_specularColor":
            floatFieldGrp -e -enable $bool oceanShader_specularColor_GammaField;
            attrColorSliderGrp -e -enable $bool oceanShader_specularColor_Swatch;
            break;

        case "oceanShader_reflectedColor":
            floatFieldGrp -e -enable $bool oceanShader_reflectedColor_GammaField;
            attrColorSliderGrp -e -enable $bool oceanShader_reflectedColor_Swatch;
            break;            

        case "phong_color":
            floatFieldGrp -e -enable $bool phong_color_GammaField;
            attrColorSliderGrp -e -enable $bool phong_color_Swatch;
            break;
            
        case "phong_transparency":
            floatFieldGrp -e -enable $bool phong_transparency_GammaField;
            attrColorSliderGrp -e -enable $bool phong_transparency_Swatch;
            break;
            
        case "phong_ambientColor":
            floatFieldGrp -e -enable $bool phong_ambientColor_GammaField;
            attrColorSliderGrp -e -enable $bool phong_ambientColor_Swatch;
            break;

        case "phong_incandescence":
            floatFieldGrp -e -enable $bool phong_incandescence_GammaField;
            attrColorSliderGrp -e -enable $bool phong_incandescence_Swatch;
            break;

        case "phong_specularColor":
            floatFieldGrp -e -enable $bool phong_specularColor_GammaField;
            attrColorSliderGrp -e -enable $bool phong_specularColor_Swatch;
            break;

        case "phong_reflectedColor":
            floatFieldGrp -e -enable $bool phong_reflectedColor_GammaField;
            attrColorSliderGrp -e -enable $bool phong_reflectedColor_Swatch;
            break;

        case "phongE_color":
            floatFieldGrp -e -enable $bool phongE_color_GammaField;
            attrColorSliderGrp -e -enable $bool phongE_color_Swatch;
            break;
            
        case "phongE_transparency":
            floatFieldGrp -e -enable $bool phongE_transparency_GammaField;
            attrColorSliderGrp -e -enable $bool phongE_transparency_Swatch;
            break;
            
        case "phongE_ambientColor":
            floatFieldGrp -e -enable $bool phongE_ambientColor_GammaField;
            attrColorSliderGrp -e -enable $bool phongE_ambientColor_Swatch;
            break;

        case "phongE_incandescence":
            floatFieldGrp -e -enable $bool phongE_incandescence_GammaField;
            attrColorSliderGrp -e -enable $bool phongE_incandescence_Swatch;
            break;

        case "phongE_whiteness":
            floatFieldGrp -e -enable $bool phongE_whiteness_GammaField;
            attrColorSliderGrp -e -enable $bool phongE_whiteness_Swatch;
            break;            

        case "phongE_specularColor":
            floatFieldGrp -e -enable $bool phongE_specularColor_GammaField;
            attrColorSliderGrp -e -enable $bool phongE_specularColor_Swatch;
            break;

        case "phongE_reflectedColor":
            floatFieldGrp -e -enable $bool phongE_reflectedColor_GammaField;
            attrColorSliderGrp -e -enable $bool phongE_reflectedColor_Swatch;
            break;     

        case "shadingMap_shadingMapColor":
            floatFieldGrp -e -enable $bool shadingMap_shadingMapColor_GammaField;
            attrColorSliderGrp -e -enable $bool shadingMap_shadingMapColor_Swatch;
            break;                     

        case "surfaceShader_outColor":
            floatFieldGrp -e -enable $bool surfaceShader_outColor_GammaField;
            attrColorSliderGrp -e -enable $bool surfaceShader_outColor_Swatch;
            break;
            
        case "surfaceShader_outTransparency":
            floatFieldGrp -e -enable $bool surfaceShader_outTransparency_GammaField;
            attrColorSliderGrp -e -enable $bool surfaceShader_outTransparency_Swatch;
            break;
            
        case "surfaceShader_outGlowColor":
            floatFieldGrp -e -enable $bool surfaceShader_outGlowColor_GammaField;
            attrColorSliderGrp -e -enable $bool surfaceShader_outGlowColor_Swatch;
            break;

        case "surfaceShader_outMatteOpacity":
            floatFieldGrp -e -enable $bool surfaceShader_outMatteOpacity_GammaField;
            attrColorSliderGrp -e -enable $bool surfaceShader_outMatteOpacity_Swatch;
            break;
            
        case "useBackground_specularColor":
            floatFieldGrp -e -enable $bool useBackground_specularColor_GammaField;
            attrColorSliderGrp -e -enable $bool useBackground_specularColor_Swatch;
            break;

        case "envFog_color":
            floatFieldGrp -e -enable $bool envFog_color_GammaField;
            attrColorSliderGrp -e -enable $bool envFog_color_Swatch;
            break;

        case "envFog_fogColor":
            floatFieldGrp -e -enable $bool envFog_fogColor_GammaField;
            attrColorSliderGrp -e -enable $bool envFog_fogColor_Swatch;
            break;

        case "envFog_fogOpacity":
            floatFieldGrp -e -enable $bool envFog_fogOpacity_GammaField;
            attrColorSliderGrp -e -enable $bool envFog_fogOpacity_Swatch;
            break;

        case "envFog_airColor":
            floatFieldGrp -e -enable $bool envFog_airColor_GammaField;
            attrColorSliderGrp -e -enable $bool envFog_airColor_Swatch;
            break;            

        case "envFog_airOpacity":
            floatFieldGrp -e -enable $bool envFog_airOpacity_GammaField;
            attrColorSliderGrp -e -enable $bool envFog_airOpacity_Swatch;
            break;

        case "envFog_waterColor":
            floatFieldGrp -e -enable $bool envFog_waterColor_GammaField;
            attrColorSliderGrp -e -enable $bool envFog_waterColor_Swatch;
            break;

        case "envFog_waterOpacity":
            floatFieldGrp -e -enable $bool envFog_waterOpacity_GammaField;
            attrColorSliderGrp -e -enable $bool envFog_waterOpacity_Swatch;
            break;

        case "envFog_sunColor":
            floatFieldGrp -e -enable $bool envFog_sunColor_GammaField;
            attrColorSliderGrp -e -enable $bool envFog_sunColor_Swatch;
            break;

        case "dgs_material_diffuse":
            floatFieldGrp -e -enable $bool dgs_material_diffuse_GammaField;
            attrColorSliderGrp -e -enable $bool dgs_material_diffuse_Swatch;
            break;
            
        case "dgs_material_glossy":
            floatFieldGrp -e -enable $bool dgs_material_glossy_GammaField;
            attrColorSliderGrp -e -enable $bool dgs_material_glossy_Swatch;
            break;
            
        case "dgs_material_specular":
            floatFieldGrp -e -enable $bool dgs_material_specular_GammaField;
            attrColorSliderGrp -e -enable $bool dgs_material_specular_Swatch;
            break;

        case "dielectric_material_col":
            floatFieldGrp -e -enable $bool dielectric_material_col_GammaField;
            attrColorSliderGrp -e -enable $bool dielectric_material_col_Swatch;
            break;
            
        case "dielectric_material_col_out":
            floatFieldGrp -e -enable $bool dielectric_material_col_out_GammaField;
            attrColorSliderGrp -e -enable $bool dielectric_material_col_out_Swatch;
            break;

        case "mi_car_paint_phen_ambient":
            floatFieldGrp -e -enable $bool mi_car_paint_phen_ambient_GammaField;
            attrColorSliderGrp -e -enable $bool mi_car_paint_phen_ambient_Swatch;
            break;

        case "mi_car_paint_phen_base_color":
            floatFieldGrp -e -enable $bool mi_car_paint_phen_base_color_GammaField;
            attrColorSliderGrp -e -enable $bool mi_car_paint_phen_base_color_Swatch;
            break;

        case "mi_car_paint_phen_edge_color":
            floatFieldGrp -e -enable $bool mi_car_paint_phen_edge_color_GammaField;
            attrColorSliderGrp -e -enable $bool mi_car_paint_phen_edge_color_Swatch;
            break;

        case "mi_car_paint_phen_lit_color":
            floatFieldGrp -e -enable $bool mi_car_paint_phen_lit_color_GammaField;
            attrColorSliderGrp -e -enable $bool mi_car_paint_phen_lit_color_Swatch;
            break;

        case "mi_car_paint_phen_spec":
            floatFieldGrp -e -enable $bool mi_car_paint_phen_spec_GammaField;
            attrColorSliderGrp -e -enable $bool mi_car_paint_phen_spec_Swatch;
            break;

        case "mi_car_paint_phen_spec_sec":
            floatFieldGrp -e -enable $bool mi_car_paint_phen_spec_sec_GammaField;
            attrColorSliderGrp -e -enable $bool mi_car_paint_phen_spec_sec_Swatch;
            break;

        case "mi_car_paint_phen_flake_color":
            floatFieldGrp -e -enable $bool mi_car_paint_phen_flake_color_GammaField;
            attrColorSliderGrp -e -enable $bool mi_car_paint_phen_flake_color_Swatch;
            break;

        case "mi_car_paint_phen_reflection_color":
            floatFieldGrp -e -enable $bool mi_car_paint_phen_reflection_color_GammaField;
            attrColorSliderGrp -e -enable $bool mi_car_paint_phen_reflection_color_Swatch;
            break;

        case "mi_car_paint_phen_dirt_color":
            floatFieldGrp -e -enable $bool mi_car_paint_phen_dirt_color_GammaField;
            attrColorSliderGrp -e -enable $bool mi_car_paint_phen_dirt_color_Swatch;
            break;

        case "mi_metallic_paint_ambient":
            floatFieldGrp -e -enable $bool mi_metallic_paint_ambient_GammaField;
            attrColorSliderGrp -e -enable $bool mi_metallic_paint_ambient_Swatch;
            break;

        case "mi_metallic_paint_base_color":
            floatFieldGrp -e -enable $bool mi_metallic_paint_base_color_GammaField;
            attrColorSliderGrp -e -enable $bool mi_metallic_paint_base_color_Swatch;
            break;

        case "mi_metallic_paint_edge_color":
            floatFieldGrp -e -enable $bool mi_metallic_paint_edge_color_GammaField;
            attrColorSliderGrp -e -enable $bool mi_metallic_paint_edge_color_Swatch;
            break;

        case "mi_metallic_paint_lit_color":
            floatFieldGrp -e -enable $bool mi_metallic_paint_lit_color_GammaField;
            attrColorSliderGrp -e -enable $bool mi_metallic_paint_lit_color_Swatch;
            break;

        case "mi_metallic_paint_spec":
            floatFieldGrp -e -enable $bool mi_metallic_paint_spec_GammaField;
            attrColorSliderGrp -e -enable $bool mi_metallic_paint_spec_Swatch;
            break;

        case "mi_metallic_paint_spec_sec":
            floatFieldGrp -e -enable $bool mi_metallic_paint_spec_sec_GammaField;
            attrColorSliderGrp -e -enable $bool mi_metallic_paint_spec_sec_Swatch;
            break;

        case "mi_metallic_paint_flake_color":
            floatFieldGrp -e -enable $bool mi_metallic_paint_flake_color_GammaField;
            attrColorSliderGrp -e -enable $bool mi_metallic_paint_flake_color_Swatch;
            break;
            
        case "mia_material_diffuse":
            floatFieldGrp -e -enable $bool mia_material_diffuse_GammaField;
            attrColorSliderGrp -e -enable $bool mia_material_diffuse_Swatch;
            break;

        case "mia_material_refl_color":
            floatFieldGrp -e -enable $bool mia_material_refl_color_GammaField;
            attrColorSliderGrp -e -enable $bool mia_material_refl_color_Swatch;
            break;

        case "mia_material_refl_falloff_color":
            floatFieldGrp -e -enable $bool mia_material_refl_falloff_color_GammaField;
            attrColorSliderGrp -e -enable $bool mia_material_refl_falloff_color_Swatch;
            break;

        case "mia_material_refr_color":
            floatFieldGrp -e -enable $bool mia_material_refr_color_GammaField;
            attrColorSliderGrp -e -enable $bool mia_material_refr_color_Swatch;
            break;

        case "mia_material_refr_falloff_color":
            floatFieldGrp -e -enable $bool mia_material_refr_falloff_color_GammaField;
            attrColorSliderGrp -e -enable $bool mia_material_refr_falloff_color_Swatch;
            break;

        case "mia_material_refr_trans_color":
            floatFieldGrp -e -enable $bool mia_material_refr_trans_color_GammaField;
            attrColorSliderGrp -e -enable $bool mia_material_refr_trans_color_Swatch;
            break;

        case "mia_material_ao_dark":
            floatFieldGrp -e -enable $bool mia_material_ao_dark_GammaField;
            attrColorSliderGrp -e -enable $bool mia_material_ao_dark_Swatch;
            break;

        case "mia_material_ao_ambient":
            floatFieldGrp -e -enable $bool mia_material_ao_ambient_GammaField;
            attrColorSliderGrp -e -enable $bool mia_material_ao_ambient_Swatch;
            break;

        case "mia_material_additional_color":
            floatFieldGrp -e -enable $bool mia_material_additional_color_GammaField;
            attrColorSliderGrp -e -enable $bool mia_material_additional_color_Swatch;
            break;

            default:
                error ("something went wrong in gammaCHK" + "\n");
    	}
	}
global proc selectAllCheckBoxes(){
    string $sel[] = `ls -sl`;
    string $selName = $sel[0];
    string $selectedType = `objectType $selName`;
    switch ($selectedType)
    {
        case "anisotropic":
            checkBoxGrp -e -v1 1 anisotropic_color_CheckBox;
            floatFieldGrp -e -enable 1 anisotropic_color_GammaField;
            attrColorSliderGrp -e -enable 1 anisotropic_color_Swatch;
            
            checkBoxGrp -e -v1 1 anisotropic_transparency_CheckBox;
            floatFieldGrp -e -enable 1 anisotropic_transparency_GammaField;
            attrColorSliderGrp -e -enable 1 anisotropic_transparency_Swatch;

            checkBoxGrp -e -v1 1 anisotropic_ambientColor_CheckBox;
            floatFieldGrp -e -enable 1 anisotropic_ambientColor_GammaField;
            attrColorSliderGrp -e -enable 1 anisotropic_ambientColor_Swatch;

            checkBoxGrp -e -v1 1 anisotropic_incandescence_CheckBox;
            floatFieldGrp -e -enable 1 anisotropic_incandescence_GammaField;
            attrColorSliderGrp -e -enable 1 anisotropic_incandescence_Swatch;

            checkBoxGrp -e -v1 1 anisotropic_specularColor_CheckBox;
            floatFieldGrp -e -enable 1 anisotropic_specularColor_GammaField;
            attrColorSliderGrp -e -enable 1 anisotropic_specularColor_Swatch;

            checkBoxGrp -e -v1 1 anisotropic_reflectedColor_CheckBox;
            floatFieldGrp -e -enable 1 anisotropic_reflectedColor_GammaField;
            attrColorSliderGrp -e -enable 1 anisotropic_reflectedColor_Swatch;
            break;

        case "blinn":
            checkBoxGrp -e -v1 1 blinn_color_CheckBox;
            floatFieldGrp -e -enable 1 blinn_color_GammaField;
            attrColorSliderGrp -e -enable 1 blinn_color_Swatch;
            
            checkBoxGrp -e -v1 1 blinn_transparency_CheckBox;
            floatFieldGrp -e -enable 1 blinn_transparency_GammaField;
            attrColorSliderGrp -e -enable 1 blinn_transparency_Swatch;

            checkBoxGrp -e -v1 1 blinn_ambientColor_CheckBox;
            floatFieldGrp -e -enable 1 blinn_ambientColor_GammaField;
            attrColorSliderGrp -e -enable 1 blinn_ambientColor_Swatch;

            checkBoxGrp -e -v1 1 blinn_incandescence_CheckBox;
            floatFieldGrp -e -enable 1 blinn_incandescence_GammaField;
            attrColorSliderGrp -e -enable 1 blinn_incandescence_Swatch;           

            checkBoxGrp -e -v1 1 blinn_specularColor_CheckBox;
            floatFieldGrp -e -enable 1 blinn_specularColor_GammaField;
            attrColorSliderGrp -e -enable 1 blinn_specularColor_Swatch;

            checkBoxGrp -e -v1 1 blinn_reflectedColor_CheckBox;
            floatFieldGrp -e -enable 1 blinn_reflectedColor_GammaField;
            attrColorSliderGrp -e -enable 1 blinn_reflectedColor_Swatch;
            break;            

        case "hairTubeShader":
            checkBoxGrp -e -v1 1 hairTubeShader_color_CheckBox;
            floatFieldGrp -e -enable 1 hairTubeShader_color_GammaField;
            attrColorSliderGrp -e -enable 1 hairTubeShader_color_Swatch;
            
            checkBoxGrp -e -v1 1 hairTubeShader_transparency_CheckBox;
            floatFieldGrp -e -enable 1 hairTubeShader_transparency_GammaField;
            attrColorSliderGrp -e -enable 1 hairTubeShader_transparency_Swatch;

            checkBoxGrp -e -v1 1 hairTubeShader_ambientColor_CheckBox;
            floatFieldGrp -e -enable 1 hairTubeShader_ambientColor_GammaField;
            attrColorSliderGrp -e -enable 1 hairTubeShader_ambientColor_Swatch;

            checkBoxGrp -e -v1 1 hairTubeShader_incandescence_CheckBox;
            floatFieldGrp -e -enable 1 hairTubeShader_incandescence_GammaField;
            attrColorSliderGrp -e -enable 1 hairTubeShader_incandescence_Swatch;           

            checkBoxGrp -e -v1 1 hairTubeShader_specularColor_CheckBox;
            floatFieldGrp -e -enable 1 hairTubeShader_specularColor_GammaField;
            attrColorSliderGrp -e -enable 1 hairTubeShader_specularColor_Swatch;

            checkBoxGrp -e -v1 1 hairTubeShader_reflectedColor_CheckBox;
            floatFieldGrp -e -enable 1 hairTubeShader_reflectedColor_GammaField;
            attrColorSliderGrp -e -enable 1 hairTubeShader_reflectedColor_Swatch;
            break;              

        case "lambert":
            checkBoxGrp -e -v1 1 lambert_color_CheckBox;
            floatFieldGrp -e -enable 1 lambert_color_GammaField;
            attrColorSliderGrp -e -enable 1 lambert_color_Swatch;
            
            checkBoxGrp -e -v1 1 lambert_transparency_CheckBox;
            floatFieldGrp -e -enable 1 lambert_transparency_GammaField;
            attrColorSliderGrp -e -enable 1 lambert_transparency_Swatch;

            checkBoxGrp -e -v1 1 lambert_ambientColor_CheckBox;
            floatFieldGrp -e -enable 1 lambert_ambientColor_GammaField;
            attrColorSliderGrp -e -enable 1 lambert_ambientColor_Swatch;

            checkBoxGrp -e -v1 1 lambert_incandescence_CheckBox;
            floatFieldGrp -e -enable 1 lambert_incandescence_GammaField;
            attrColorSliderGrp -e -enable 1 lambert_incandescence_Swatch;
            break;

        case "oceanShader":
            checkBoxGrp -e -v1 1 oceanShader_waterColor_CheckBox;
            floatFieldGrp -e -enable 1 oceanShader_waterColor_GammaField;
            attrColorSliderGrp -e -enable 1 oceanShader_waterColor_Swatch;
            
            checkBoxGrp -e -v1 1 oceanShader_foamColor_CheckBox;
            floatFieldGrp -e -enable 1 oceanShader_foamColor_GammaField;
            attrColorSliderGrp -e -enable 1 oceanShader_foamColor_Swatch;            
            
            checkBoxGrp -e -v1 1 oceanShader_transparency_CheckBox;
            floatFieldGrp -e -enable 1 oceanShader_transparency_GammaField;
            attrColorSliderGrp -e -enable 1 oceanShader_transparency_Swatch;
            
            checkBoxGrp -e -v1 1 oceanShader_incandescence_CheckBox;
            floatFieldGrp -e -enable 1 oceanShader_incandescence_GammaField;
            attrColorSliderGrp -e -enable 1 oceanShader_incandescence_Swatch;            

            checkBoxGrp -e -v1 1 oceanShader_ambientColor_CheckBox;
            floatFieldGrp -e -enable 1 oceanShader_ambientColor_GammaField;
            attrColorSliderGrp -e -enable 1 oceanShader_ambientColor_Swatch;

            checkBoxGrp -e -v1 1 oceanShader_specularColor_CheckBox;
            floatFieldGrp -e -enable 1 oceanShader_specularColor_GammaField;
            attrColorSliderGrp -e -enable 1 oceanShader_specularColor_Swatch;

            checkBoxGrp -e -v1 1 oceanShader_reflectedColor_CheckBox;
            floatFieldGrp -e -enable 1 oceanShader_reflectedColor_GammaField;
            attrColorSliderGrp -e -enable 1 oceanShader_reflectedColor_Swatch;
            break;            

        case "phong":
            checkBoxGrp -e -v1 1 phong_color_CheckBox;
            floatFieldGrp -e -enable 1 phong_color_GammaField;
            attrColorSliderGrp -e -enable 1 phong_color_Swatch;
            
            checkBoxGrp -e -v1 1 phong_transparency_CheckBox;
            floatFieldGrp -e -enable 1 phong_transparency_GammaField;
            attrColorSliderGrp -e -enable 1 phong_transparency_Swatch;

            checkBoxGrp -e -v1 1 phong_ambientColor_CheckBox;
            floatFieldGrp -e -enable 1 phong_ambientColor_GammaField;
            attrColorSliderGrp -e -enable 1 phong_ambientColor_Swatch;

            checkBoxGrp -e -v1 1 phong_incandescence_CheckBox;
            floatFieldGrp -e -enable 1 phong_incandescence_GammaField;
            attrColorSliderGrp -e -enable 1 phong_incandescence_Swatch;

            checkBoxGrp -e -v1 1 phong_specularColor_CheckBox;
            floatFieldGrp -e -enable 1 phong_specularColor_GammaField;
            attrColorSliderGrp -e -enable 1 phong_specularColor_Swatch;

            checkBoxGrp -e -v1 1 phong_reflectedColor_CheckBox;
            floatFieldGrp -e -enable 1 phong_reflectedColor_GammaField;
            attrColorSliderGrp -e -enable 1 phong_reflectedColor_Swatch;
            break;

        case "phongE":
            checkBoxGrp -e -v1 1 phongE_color_CheckBox;
            floatFieldGrp -e -enable 1 phongE_color_GammaField;
            attrColorSliderGrp -e -enable 1 phongE_color_Swatch;
            
            checkBoxGrp -e -v1 1 phongE_transparency_CheckBox;
            floatFieldGrp -e -enable 1 phongE_transparency_GammaField;
            attrColorSliderGrp -e -enable 1 phongE_transparency_Swatch;

            checkBoxGrp -e -v1 1 phongE_ambientColor_CheckBox;
            floatFieldGrp -e -enable 1 phongE_ambientColor_GammaField;
            attrColorSliderGrp -e -enable 1 phongE_ambientColor_Swatch;

            checkBoxGrp -e -v1 1 phongE_incandescence_CheckBox;
            floatFieldGrp -e -enable 1 phongE_incandescence_GammaField;
            attrColorSliderGrp -e -enable 1 phongE_incandescence_Swatch;

            checkBoxGrp -e -v1 1 phongE_whiteness_CheckBox;
            floatFieldGrp -e -enable 1 phongE_whiteness_GammaField;
            attrColorSliderGrp -e -enable 1 phongE_whiteness_Swatch;            

            checkBoxGrp -e -v1 1 phongE_specularColor_CheckBox;
            floatFieldGrp -e -enable 1 phongE_specularColor_GammaField;
            attrColorSliderGrp -e -enable 1 phongE_specularColor_Swatch;

            checkBoxGrp -e -v1 1 phongE_reflectedColor_CheckBox;
            floatFieldGrp -e -enable 1 phongE_reflectedColor_GammaField;
            attrColorSliderGrp -e -enable 1 phongE_reflectedColor_Swatch;
            break;

        case "shadingMap":
            checkBoxGrp -e -v1 1 shadingMap_shadingMapColor_CheckBox;
            floatFieldGrp -e -enable 1 shadingMap_shadingMapColor_GammaField;
            attrColorSliderGrp -e -enable 1 shadingMap_shadingMapColor_Swatch;
            break;

        case "surfaceShader":
            checkBoxGrp -e -v1 1 surfaceShader_outColor_CheckBox;
            floatFieldGrp -e -enable 1 surfaceShader_outColor_GammaField;
            attrColorSliderGrp -e -enable 1 surfaceShader_outColor_Swatch;
            
            checkBoxGrp -e -v1 1 surfaceShader_outTransparency_CheckBox;
            floatFieldGrp -e -enable 1 surfaceShader_outTransparency_GammaField;
            attrColorSliderGrp -e -enable 1 surfaceShader_outTransparency_Swatch;

            checkBoxGrp -e -v1 1 surfaceShader_outGlowColor_CheckBox;
            floatFieldGrp -e -enable 1 surfaceShader_outGlowColor_GammaField;
            attrColorSliderGrp -e -enable 1 surfaceShader_outGlowColor_Swatch;

            checkBoxGrp -e -v1 1 surfaceShader_outMatteOpacity_CheckBox;
            floatFieldGrp -e -enable 1 surfaceShader_outMatteOpacity_GammaField;
            attrColorSliderGrp -e -enable 1 surfaceShader_outMatteOpacity_Swatch;
            break;   
            
        case "useBackground":
            checkBoxGrp -e -v1 1 useBackground_specularColor_CheckBox;
            floatFieldGrp -e -enable 1 useBackground_specularColor_GammaField;
            attrColorSliderGrp -e -enable 1 useBackground_specularColor_Swatch;
            break;                                    

        case "envFog":
            checkBoxGrp -e -v1 1 envFog_color_CheckBox;
            floatFieldGrp -e -enable 1 envFog_color_GammaField;
            attrColorSliderGrp -e -enable 1 envFog_color_Swatch;
            
            checkBoxGrp -e -v1 1 envFog_fogColor_CheckBox;
            floatFieldGrp -e -enable 1 envFog_fogColor_GammaField;
            attrColorSliderGrp -e -enable 1 envFog_fogColor_Swatch;

            checkBoxGrp -e -v1 1 envFog_fogOpacity_CheckBox;
            floatFieldGrp -e -enable 1 envFog_fogOpacity_GammaField;
            attrColorSliderGrp -e -enable 1 envFog_fogOpacity_Swatch;

            checkBoxGrp -e -v1 1 envFog_airColor_CheckBox;
            floatFieldGrp -e -enable 1 envFog_airColor_GammaField;
            attrColorSliderGrp -e -enable 1 envFog_airColor_Swatch;

            checkBoxGrp -e -v1 1 envFog_airOpacity_CheckBox;
            floatFieldGrp -e -enable 1 envFog_airOpacity_GammaField;
            attrColorSliderGrp -e -enable 1 envFog_airOpacity_Swatch;
            
            checkBoxGrp -e -v1 1 envFog_waterColor_CheckBox;
            floatFieldGrp -e -enable 1 envFog_waterColor_GammaField;
            attrColorSliderGrp -e -enable 1 envFog_waterColor_Swatch;

            checkBoxGrp -e -v1 1 envFog_waterOpacity_CheckBox;
            floatFieldGrp -e -enable 1 envFog_waterOpacity_GammaField;
            attrColorSliderGrp -e -enable 1 envFog_waterOpacity_Swatch;

            checkBoxGrp -e -v1 1 envFog_sunColor_CheckBox;
            floatFieldGrp -e -enable 1 envFog_sunColor_GammaField;
            attrColorSliderGrp -e -enable 1 envFog_sunColor_Swatch;
            break;

        case "dgs_material":
            checkBoxGrp -e -v1 1 dgs_material_diffuse_CheckBox;
            floatFieldGrp -e -enable 1 dgs_material_diffuse_GammaField;
            attrColorSliderGrp -e -enable 1 dgs_material_diffuse_Swatch;
            
            checkBoxGrp -e -v1 1 dgs_material_glossy_CheckBox;
            floatFieldGrp -e -enable 1 dgs_material_glossy_GammaField;
            attrColorSliderGrp -e -enable 1 dgs_material_glossy_Swatch;

            checkBoxGrp -e -v1 1 dgs_material_specular_CheckBox;
            floatFieldGrp -e -enable 1 dgs_material_specular_GammaField;
            attrColorSliderGrp -e -enable 1 dgs_material_specular_Swatch;
            break;

        case "dielectric_material":
            checkBoxGrp -e -v1 1 dielectric_material_col_CheckBox;
            floatFieldGrp -e -enable 1 dielectric_material_col_GammaField;
            attrColorSliderGrp -e -enable 1 dielectric_material_col_Swatch;
            
            checkBoxGrp -e -v1 1 dielectric_material_col_out_CheckBox;
            floatFieldGrp -e -enable 1 dielectric_material_col_out_GammaField;
            attrColorSliderGrp -e -enable 1 dielectric_material_col_out_Swatch;
            break;

        case "mi_car_paint_phen_x":
        case "mi_car_paint_phen_x_passes":
        case "mi_car_paint_phen":
            checkBoxGrp -e -v1 1 mi_car_paint_phen_ambient_CheckBox;
            floatFieldGrp -e -enable 1 mi_car_paint_phen_ambient_GammaField;
            attrColorSliderGrp -e -enable 1 mi_car_paint_phen_ambient_Swatch;
            
            checkBoxGrp -e -v1 1 mi_car_paint_phen_base_color_CheckBox;
            floatFieldGrp -e -enable 1 mi_car_paint_phen_base_color_GammaField;
            attrColorSliderGrp -e -enable 1 mi_car_paint_phen_base_color_Swatch;

            checkBoxGrp -e -v1 1 mi_car_paint_phen_edge_color_CheckBox;
            floatFieldGrp -e -enable 1 mi_car_paint_phen_edge_color_GammaField;
            attrColorSliderGrp -e -enable 1 mi_car_paint_phen_edge_color_Swatch;


            checkBoxGrp -e -v1 1 mi_car_paint_phen_lit_color_CheckBox;
            floatFieldGrp -e -enable 1 mi_car_paint_phen_lit_color_GammaField;
            attrColorSliderGrp -e -enable 1 mi_car_paint_phen_lit_color_Swatch;
            
            checkBoxGrp -e -v1 1 mi_car_paint_phen_spec_CheckBox;
            floatFieldGrp -e -enable 1 mi_car_paint_phen_spec_GammaField;
            attrColorSliderGrp -e -enable 1 mi_car_paint_phen_spec_Swatch;

            checkBoxGrp -e -v1 1 mi_car_paint_phen_spec_sec_CheckBox;
            floatFieldGrp -e -enable 1 mi_car_paint_phen_spec_sec_GammaField;
            attrColorSliderGrp -e -enable 1 mi_car_paint_phen_spec_sec_Swatch;

            checkBoxGrp -e -v1 1 mi_car_paint_phen_flake_color_CheckBox;
            floatFieldGrp -e -enable 1 mi_car_paint_phen_flake_color_GammaField;
            attrColorSliderGrp -e -enable 1 mi_car_paint_phen_flake_color_Swatch;
            
            checkBoxGrp -e -v1 1 mi_car_paint_phen_reflection_color_CheckBox;
            floatFieldGrp -e -enable 1 mi_car_paint_phen_reflection_color_GammaField;
            attrColorSliderGrp -e -enable 1 mi_car_paint_phen_reflection_color_Swatch;

            checkBoxGrp -e -v1 1 mi_car_paint_phen_dirt_color_CheckBox;
            floatFieldGrp -e -enable 1 mi_car_paint_phen_dirt_color_GammaField;
            attrColorSliderGrp -e -enable 1 mi_car_paint_phen_dirt_color_Swatch;
            break;
            
        case "mi_metallic_paint_x":
        case "mi_metallic_paint_x_passes":
        case "mi_metallic_paint":
            checkBoxGrp -e -v1 1 mi_metallic_paint_ambient_CheckBox;
            floatFieldGrp -e -enable 1 mi_metallic_paint_ambient_GammaField;
            attrColorSliderGrp -e -enable 1 mi_metallic_paint_ambient_Swatch;
            
            checkBoxGrp -e -v1 1 mi_metallic_paint_base_color_CheckBox;
            floatFieldGrp -e -enable 1 mi_metallic_paint_base_color_GammaField;
            attrColorSliderGrp -e -enable 1 mi_metallic_paint_base_color_Swatch;

            checkBoxGrp -e -v1 1 mi_metallic_paint_edge_color_CheckBox;
            floatFieldGrp -e -enable 1 mi_metallic_paint_edge_color_GammaField;
            attrColorSliderGrp -e -enable 1 mi_metallic_paint_edge_color_Swatch;

            checkBoxGrp -e -v1 1 mi_metallic_paint_lit_color_CheckBox;
            floatFieldGrp -e -enable 1 mi_metallic_paint_lit_color_GammaField;
            attrColorSliderGrp -e -enable 1 mi_metallic_paint_lit_color_Swatch;
            
            checkBoxGrp -e -v1 1 mi_metallic_paint_spec_CheckBox;
            floatFieldGrp -e -enable 1 mi_metallic_paint_spec_GammaField;
            attrColorSliderGrp -e -enable 1 mi_metallic_paint_spec_Swatch;

            checkBoxGrp -e -v1 1 mi_metallic_paint_spec_sec_CheckBox;
            floatFieldGrp -e -enable 1 mi_metallic_paint_spec_sec_GammaField;
            attrColorSliderGrp -e -enable 1 mi_metallic_paint_spec_sec_Swatch;

            checkBoxGrp -e -v1 1 mi_metallic_paint_flake_color_CheckBox;
            floatFieldGrp -e -enable 1 mi_metallic_paint_flake_color_GammaField;
            attrColorSliderGrp -e -enable 1 mi_metallic_paint_flake_color_Swatch;
            break;

        case "mia_material_x":
        case "mia_material_x_passes":
        case "mia_material":
            checkBoxGrp -e -v1 1 mia_material_diffuse_CheckBox;
            floatFieldGrp -e -enable 1 mia_material_diffuse_GammaField;
            attrColorSliderGrp -e -enable 1 mia_material_diffuse_Swatch;
            
            checkBoxGrp -e -v1 1 mia_material_refl_color_CheckBox;
            floatFieldGrp -e -enable 1 mia_material_refl_color_GammaField;
            attrColorSliderGrp -e -enable 1 mia_material_refl_color_Swatch;

            checkBoxGrp -e -v1 1 mia_material_refl_falloff_color_CheckBox;
            floatFieldGrp -e -enable 1 mia_material_refl_falloff_color_GammaField;
            attrColorSliderGrp -e -enable 1 mia_material_refl_falloff_color_Swatch;

            checkBoxGrp -e -v1 1 mia_material_refr_color_CheckBox;
            floatFieldGrp -e -enable 1 mia_material_refr_color_GammaField;
            attrColorSliderGrp -e -enable 1 mia_material_refr_color_Swatch;
            
            checkBoxGrp -e -v1 1 mia_material_refr_falloff_color_CheckBox;
            floatFieldGrp -e -enable 1 mia_material_refr_falloff_color_GammaField;
            attrColorSliderGrp -e -enable 1 mia_material_refr_falloff_color_Swatch;

            checkBoxGrp -e -v1 1 mia_material_refr_trans_color_CheckBox;
            floatFieldGrp -e -enable 1 mia_material_refr_trans_color_GammaField;
            attrColorSliderGrp -e -enable 1 mia_material_refr_trans_color_Swatch;

            checkBoxGrp -e -v1 1 mia_material_ao_dark_CheckBox;
            floatFieldGrp -e -enable 1 mia_material_ao_dark_GammaField;
            attrColorSliderGrp -e -enable 1 mia_material_ao_dark_Swatch;

            checkBoxGrp -e -v1 1 mia_material_ao_ambient_CheckBox;
            floatFieldGrp -e -enable 1 mia_material_ao_ambient_GammaField;
            attrColorSliderGrp -e -enable 1 mia_material_ao_ambient_Swatch;

            checkBoxGrp -e -v1 1 mia_material_additional_color_CheckBox;
            floatFieldGrp -e -enable 1 mia_material_additional_color_GammaField;
            attrColorSliderGrp -e -enable 1 mia_material_additional_color_Swatch;
            break;

        default:
            print ("Selected Type is: " + $selectedType + "\n");
            print ("Something went wrong in selectAllCheckBoxes" + "\n");
    }
	}
global proc getNewSelection(){
    deleteUI gammaUIMainWindow;
    gammaUIMain;
	}
global proc applyPressed(){
    global string $selectedType;
    global string $selName;
    int $send;
    switch ($selectedType){
        case "anisotropic":
            int $anisotropic_color_CheckBox_State = `checkBoxGrp -q -v1 anisotropic_color_CheckBox`;
            float $anisotropic_color_gammaValue = `floatFieldGrp -q -value1 anisotropic_color_GammaField`;
            if ($anisotropic_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".color") $anisotropic_color_gammaValue`;
            }
            ////////////////////////////////////////////
            int $anisotropic_transparency_CheckBox_State = `checkBoxGrp -q -v1 anisotropic_transparency_CheckBox`;
            float $anisotropic_transparency_gammaValue = `floatFieldGrp -q -value1 anisotropic_transparency_GammaField`;
            if ($anisotropic_transparency_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".transparency") $anisotropic_transparency_gammaValue`;
            }
            ////////////////////////////////////////////
            int $anisotropic_ambientColor_CheckBox_State = `checkBoxGrp -q -v1 anisotropic_ambientColor_CheckBox`;
            float $anisotropic_ambientColor_gammaValue = `floatFieldGrp -q -value1 anisotropic_ambientColor_GammaField`;
            if ($anisotropic_ambientColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".ambientColor") $anisotropic_ambientColor_gammaValue`;
            }    
            ////////////////////////////////////////////
            int $anisotropic_incandescence_CheckBox_State = `checkBoxGrp -q -v1 anisotropic_incandescence_CheckBox`;
            float $anisotropic_incandescence_gammaValue = `floatFieldGrp -q -value1 anisotropic_incandescence_GammaField`;
            if ($anisotropic_incandescence_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".incandescence") $anisotropic_incandescence_gammaValue`;
            }      
            ////////////////////////////////////////////
            int $anisotropic_specularColor_CheckBox_State = `checkBoxGrp -q -v1 anisotropic_specularColor_CheckBox`;
            float $anisotropic_specularColor_gammaValue = `floatFieldGrp -q -value1 anisotropic_specularColor_GammaField`;
            if ($anisotropic_specularColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".specularColor") $anisotropic_specularColor_gammaValue`;
            }      
            ////////////////////////////////////////////
            int $anisotropic_reflectedColor_CheckBox_State = `checkBoxGrp -q -v1 anisotropic_reflectedColor_CheckBox`;
            float $anisotropic_reflectedColor_gammaValue = `floatFieldGrp -q -value1 anisotropic_reflectedColor_GammaField`;
            if ($anisotropic_reflectedColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".reflectedColor") $anisotropic_reflectedColor_gammaValue`;
            }                                  
            break;

        case "blinn":
            int $blinn_color_CheckBox_State = `checkBoxGrp -q -v1 blinn_color_CheckBox`;
            float $blinn_color_gammaValue = `floatFieldGrp -q -value1 blinn_color_GammaField`;
            if ($blinn_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".color") $blinn_color_gammaValue`;
            }
            ////////////////////////////////////////////
            int $blinn_transparency_CheckBox_State = `checkBoxGrp -q -v1 blinn_transparency_CheckBox`;
            float $blinn_transparency_gammaValue = `floatFieldGrp -q -value1 blinn_transparency_GammaField`;
            if ($blinn_transparency_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".transparency") $blinn_transparency_gammaValue`;
            }
            ////////////////////////////////////////////
            int $blinn_ambientColor_CheckBox_State = `checkBoxGrp -q -v1 blinn_ambientColor_CheckBox`;
            float $blinn_ambientColor_gammaValue = `floatFieldGrp -q -value1 blinn_ambientColor_GammaField`;
            if ($blinn_ambientColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".ambientColor") $blinn_ambientColor_gammaValue`;
            }    
            ////////////////////////////////////////////
            int $blinn_incandescence_CheckBox_State = `checkBoxGrp -q -v1 blinn_incandescence_CheckBox`;
            float $blinn_incandescence_gammaValue = `floatFieldGrp -q -value1 blinn_incandescence_GammaField`;
            if ($blinn_incandescence_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".incandescence") $blinn_incandescence_gammaValue`;
            }      
            ////////////////////////////////////////////
            int $blinn_specularColor_CheckBox_State = `checkBoxGrp -q -v1 blinn_specularColor_CheckBox`;
            float $blinn_specularColor_gammaValue = `floatFieldGrp -q -value1 blinn_specularColor_GammaField`;
            if ($blinn_specularColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".specularColor") $blinn_specularColor_gammaValue`;
            }      
            ////////////////////////////////////////////
            int $blinn_reflectedColor_CheckBox_State = `checkBoxGrp -q -v1 blinn_reflectedColor_CheckBox`;
            float $blinn_reflectedColor_gammaValue = `floatFieldGrp -q -value1 blinn_reflectedColor_GammaField`;
            if ($blinn_reflectedColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".reflectedColor") $blinn_reflectedColor_gammaValue`;
            }                                  
            break;            

        case "hairTubeShader":
            int $hairTubeShader_color_CheckBox_State = `checkBoxGrp -q -v1 hairTubeShader_color_CheckBox`;
            float $hairTubeShader_color_gammaValue = `floatFieldGrp -q -value1 hairTubeShader_color_GammaField`;
            if ($hairTubeShader_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".color") $hairTubeShader_color_gammaValue`;
            }
            ////////////////////////////////////////////
            int $hairTubeShader_transparency_CheckBox_State = `checkBoxGrp -q -v1 hairTubeShader_transparency_CheckBox`;
            float $hairTubeShader_transparency_gammaValue = `floatFieldGrp -q -value1 hairTubeShader_transparency_GammaField`;
            if ($hairTubeShader_transparency_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".transparency") $hairTubeShader_transparency_gammaValue`;
            }
            ////////////////////////////////////////////
            int $hairTubeShader_ambientColor_CheckBox_State = `checkBoxGrp -q -v1 hairTubeShader_ambientColor_CheckBox`;
            float $hairTubeShader_ambientColor_gammaValue = `floatFieldGrp -q -value1 hairTubeShader_ambientColor_GammaField`;
            if ($hairTubeShader_ambientColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".ambientColor") $hairTubeShader_ambientColor_gammaValue`;
            }    
            ////////////////////////////////////////////
            int $hairTubeShader_incandescence_CheckBox_State = `checkBoxGrp -q -v1 hairTubeShader_incandescence_CheckBox`;
            float $hairTubeShader_incandescence_gammaValue = `floatFieldGrp -q -value1 hairTubeShader_incandescence_GammaField`;
            if ($hairTubeShader_incandescence_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".incandescence") $hairTubeShader_incandescence_gammaValue`;
            }      
            ////////////////////////////////////////////
            int $hairTubeShader_specularColor_CheckBox_State = `checkBoxGrp -q -v1 hairTubeShader_specularColor_CheckBox`;
            float $hairTubeShader_specularColor_gammaValue = `floatFieldGrp -q -value1 hairTubeShader_specularColor_GammaField`;
            if ($hairTubeShader_specularColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".specularColor") $hairTubeShader_specularColor_gammaValue`;
            }      
            ////////////////////////////////////////////
            int $hairTubeShader_reflectedColor_CheckBox_State = `checkBoxGrp -q -v1 hairTubeShader_reflectedColor_CheckBox`;
            float $hairTubeShader_reflectedColor_gammaValue = `floatFieldGrp -q -value1 hairTubeShader_reflectedColor_GammaField`;
            if ($hairTubeShader_reflectedColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".reflectedColor") $hairTubeShader_reflectedColor_gammaValue`;
            }                                  
            break;              

        case "lambert":
            int $lambert_color_CheckBox_State = `checkBoxGrp -q -v1 lambert_color_CheckBox`;
            float $lambert_color_gammaValue = `floatFieldGrp -q -value1 lambert_color_GammaField`;
            if ($lambert_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".color") $lambert_color_gammaValue`;
            }
            ////////////////////////////////////////////
            int $lambert_transparency_CheckBox_State = `checkBoxGrp -q -v1 lambert_transparency_CheckBox`;
            float $lambert_transparency_gammaValue = `floatFieldGrp -q -value1 lambert_transparency_GammaField`;
            if ($lambert_transparency_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".transparency") $lambert_transparency_gammaValue`;
            }
            ////////////////////////////////////////////
            int $lambert_ambientColor_CheckBox_State = `checkBoxGrp -q -v1 lambert_ambientColor_CheckBox`;
            float $lambert_ambientColor_gammaValue = `floatFieldGrp -q -value1 lambert_ambientColor_GammaField`;
            if ($lambert_ambientColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".ambientColor") $lambert_ambientColor_gammaValue`;
            }    
            ////////////////////////////////////////////
            int $lambert_incandescence_CheckBox_State = `checkBoxGrp -q -v1 lambert_incandescence_CheckBox`;
            float $lambert_incandescence_gammaValue = `floatFieldGrp -q -value1 lambert_incandescence_GammaField`;
            if ($lambert_incandescence_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".incandescence") $lambert_incandescence_gammaValue`;
            }     
            break;

        case "oceanShader":
            int $oceanShader_waterColor_CheckBox_State = `checkBoxGrp -q -v1 oceanShader_waterColor_CheckBox`;
            float $oceanShader_waterColor_gammaValue = `floatFieldGrp -q -value1 oceanShader_waterColor_GammaField`;
            if ($oceanShader_waterColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".waterColor") $oceanShader_waterColor_gammaValue`;
            }
            ////////////////////////////////////////////
            int $oceanShader_foamColor_CheckBox_State = `checkBoxGrp -q -v1 oceanShader_foamColor_CheckBox`;
            float $oceanShader_foamColor_gammaValue = `floatFieldGrp -q -value1 oceanShader_foamColor_GammaField`;
            if ($oceanShader_foamColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".foamColor") $oceanShader_foamColor_gammaValue`;
            }
            ////////////////////////////////////////////            
            int $oceanShader_transparency_CheckBox_State = `checkBoxGrp -q -v1 oceanShader_transparency_CheckBox`;
            float $oceanShader_transparency_gammaValue = `floatFieldGrp -q -value1 oceanShader_transparency_GammaField`;
            if ($oceanShader_transparency_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".transparency") $oceanShader_transparency_gammaValue`;
            }
            ////////////////////////////////////////////
            int $oceanShader_incandescence_CheckBox_State = `checkBoxGrp -q -v1 oceanShader_incandescence_CheckBox`;
            float $oceanShader_incandescence_gammaValue = `floatFieldGrp -q -value1 oceanShader_incandescence_GammaField`;
            if ($oceanShader_incandescence_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".incandescence") $oceanShader_incandescence_gammaValue`;
            } 
            ////////////////////////////////////////////
            int $oceanShader_ambientColor_CheckBox_State = `checkBoxGrp -q -v1 oceanShader_ambientColor_CheckBox`;
            float $oceanShader_ambientColor_gammaValue = `floatFieldGrp -q -value1 oceanShader_ambientColor_GammaField`;
            if ($oceanShader_ambientColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".ambientColor") $oceanShader_ambientColor_gammaValue`;
            }    
     
            ////////////////////////////////////////////
            int $oceanShader_specularColor_CheckBox_State = `checkBoxGrp -q -v1 oceanShader_specularColor_CheckBox`;
            float $oceanShader_specularColor_gammaValue = `floatFieldGrp -q -value1 oceanShader_specularColor_GammaField`;
            if ($oceanShader_specularColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".specularColor") $oceanShader_specularColor_gammaValue`;
            }      
            ////////////////////////////////////////////
            int $oceanShader_reflectedColor_CheckBox_State = `checkBoxGrp -q -v1 oceanShader_reflectedColor_CheckBox`;
            float $oceanShader_reflectedColor_gammaValue = `floatFieldGrp -q -value1 oceanShader_reflectedColor_GammaField`;
            if ($oceanShader_reflectedColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".reflectedColor") $oceanShader_reflectedColor_gammaValue`;
            }                                  
            break;

        case "phong":
            int $phong_color_CheckBox_State = `checkBoxGrp -q -v1 phong_color_CheckBox`;
            float $phong_color_gammaValue = `floatFieldGrp -q -value1 phong_color_GammaField`;
            if ($phong_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".color") $phong_color_gammaValue`;
            }
            ////////////////////////////////////////////
            int $phong_transparency_CheckBox_State = `checkBoxGrp -q -v1 phong_transparency_CheckBox`;
            float $phong_transparency_gammaValue = `floatFieldGrp -q -value1 phong_transparency_GammaField`;
            if ($phong_transparency_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".transparency") $phong_transparency_gammaValue`;
            }
            ////////////////////////////////////////////
            int $phong_ambientColor_CheckBox_State = `checkBoxGrp -q -v1 phong_ambientColor_CheckBox`;
            float $phong_ambientColor_gammaValue = `floatFieldGrp -q -value1 phong_ambientColor_GammaField`;
            if ($phong_ambientColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".ambientColor") $phong_ambientColor_gammaValue`;
            }    
            ////////////////////////////////////////////
            int $phong_incandescence_CheckBox_State = `checkBoxGrp -q -v1 phong_incandescence_CheckBox`;
            float $phong_incandescence_gammaValue = `floatFieldGrp -q -value1 phong_incandescence_GammaField`;
            if ($phong_incandescence_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".incandescence") $phong_incandescence_gammaValue`;
            }      
            ////////////////////////////////////////////
            int $phong_specularColor_CheckBox_State = `checkBoxGrp -q -v1 phong_specularColor_CheckBox`;
            float $phong_specularColor_gammaValue = `floatFieldGrp -q -value1 phong_specularColor_GammaField`;
            if ($phong_specularColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".specularColor") $phong_specularColor_gammaValue`;
            }      
            ////////////////////////////////////////////
            int $phong_reflectedColor_CheckBox_State = `checkBoxGrp -q -v1 phong_reflectedColor_CheckBox`;
            float $phong_reflectedColor_gammaValue = `floatFieldGrp -q -value1 phong_reflectedColor_GammaField`;
            if ($phong_reflectedColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".reflectedColor") $phong_reflectedColor_gammaValue`;
            }                                  
            break;   

        case "phongE":
            int $phongE_color_CheckBox_State = `checkBoxGrp -q -v1 phongE_color_CheckBox`;
            float $phongE_color_gammaValue = `floatFieldGrp -q -value1 phongE_color_GammaField`;
            if ($phongE_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".color") $phongE_color_gammaValue`;
            }
            ////////////////////////////////////////////
            int $phongE_transparency_CheckBox_State = `checkBoxGrp -q -v1 phongE_transparency_CheckBox`;
            float $phongE_transparency_gammaValue = `floatFieldGrp -q -value1 phongE_transparency_GammaField`;
            if ($phongE_transparency_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".transparency") $phongE_transparency_gammaValue`;
            }
            ////////////////////////////////////////////
            int $phongE_ambientColor_CheckBox_State = `checkBoxGrp -q -v1 phongE_ambientColor_CheckBox`;
            float $phongE_ambientColor_gammaValue = `floatFieldGrp -q -value1 phongE_ambientColor_GammaField`;
            if ($phongE_ambientColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".ambientColor") $phongE_ambientColor_gammaValue`;
            }    
            ////////////////////////////////////////////
            int $phongE_incandescence_CheckBox_State = `checkBoxGrp -q -v1 phongE_incandescence_CheckBox`;
            float $phongE_incandescence_gammaValue = `floatFieldGrp -q -value1 phongE_incandescence_GammaField`;
            if ($phongE_incandescence_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".incandescence") $phongE_incandescence_gammaValue`;
            }      
            ////////////////////////////////////////////
            int $phongE_whiteness_CheckBox_State = `checkBoxGrp -q -v1 phongE_whiteness_CheckBox`;
            float $phongE_whiteness_gammaValue = `floatFieldGrp -q -value1 phongE_whiteness_GammaField`;
            if ($phongE_whiteness_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".whiteness") $phongE_whiteness_gammaValue`;
            }                
            ////////////////////////////////////////////
            int $phongE_specularColor_CheckBox_State = `checkBoxGrp -q -v1 phongE_specularColor_CheckBox`;
            float $phongE_specularColor_gammaValue = `floatFieldGrp -q -value1 phongE_specularColor_GammaField`;
            if ($phongE_specularColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".specularColor") $phongE_specularColor_gammaValue`;
            }      
            ////////////////////////////////////////////
            int $phongE_reflectedColor_CheckBox_State = `checkBoxGrp -q -v1 phongE_reflectedColor_CheckBox`;
            float $phongE_reflectedColor_gammaValue = `floatFieldGrp -q -value1 phongE_reflectedColor_GammaField`;
            if ($phongE_reflectedColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".reflectedColor") $phongE_reflectedColor_gammaValue`;
            }                                  
            break;

        case "shadingMap":
            int $shadingMap_shadingMapColor_CheckBox_State = `checkBoxGrp -q -v1 shadingMap_shadingMapColor_CheckBox`;
            float $shadingMap_shadingMapColor_gammaValue = `floatFieldGrp -q -value1 shadingMap_shadingMapColor_GammaField`;
            if ($shadingMap_shadingMapColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".shadingMapColor") $shadingMap_shadingMapColor_gammaValue`;
            }
            break;           

        case "surfaceShader":
            int $surfaceShader_outColor_CheckBox_State = `checkBoxGrp -q -v1 surfaceShader_outColor_CheckBox`;
            float $surfaceShader_outColor_gammaValue = `floatFieldGrp -q -value1 surfaceShader_outColor_GammaField`;
            if ($surfaceShader_outColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".outColor") $surfaceShader_outColor_gammaValue`;
            }
            ////////////////////////////////////////////
            int $surfaceShader_outTransparency_CheckBox_State = `checkBoxGrp -q -v1 surfaceShader_outTransparency_CheckBox`;
            float $surfaceShader_outTransparency_gammaValue = `floatFieldGrp -q -value1 surfaceShader_outTransparency_GammaField`;
            if ($surfaceShader_outTransparency_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".outTransparency") $surfaceShader_outTransparency_gammaValue`;
            }
            ////////////////////////////////////////////
            int $surfaceShader_outGlowColor_CheckBox_State = `checkBoxGrp -q -v1 surfaceShader_outGlowColor_CheckBox`;
            float $surfaceShader_outGlowColor_gammaValue = `floatFieldGrp -q -value1 surfaceShader_outGlowColor_GammaField`;
            if ($surfaceShader_outGlowColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".outGlowColor") $surfaceShader_outGlowColor_gammaValue`;
            }    
            ////////////////////////////////////////////
            int $surfaceShader_outMatteOpacity_CheckBox_State = `checkBoxGrp -q -v1 surfaceShader_outMatteOpacity_CheckBox`;
            float $surfaceShader_outMatteOpacity_gammaValue = `floatFieldGrp -q -value1 surfaceShader_outMatteOpacity_GammaField`;
            if ($surfaceShader_outMatteOpacity_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".outMatteOpacity") $surfaceShader_outMatteOpacity_gammaValue`;
            }                                      
            break;    

        case "useBackground":
            int $useBackground_specularColor_CheckBox_State = `checkBoxGrp -q -v1 useBackground_specularColor_CheckBox`;
            float $useBackground_specularColor_gammaValue = `floatFieldGrp -q -value1 useBackground_specularColor_GammaField`;
            if ($useBackground_specularColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".specularColor") $useBackground_specularColor_gammaValue`;
            }
            break;                                        

        case "envFog":
            int $envFog_color_CheckBox_State = `checkBoxGrp -q -v1 envFog_color_CheckBox`;
            float $envFog_color_gammaValue = `floatFieldGrp -q -value1 envFog_color_GammaField`;
            if ($envFog_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".color") $envFog_color_gammaValue`;
            }
            ////////////////////////////////////////////
            int $envFog_fogColor_CheckBox_State = `checkBoxGrp -q -v1 envFog_fogColor_CheckBox`;
            float $envFog_fogColor_gammaValue = `floatFieldGrp -q -value1 envFog_fogColor_GammaField`;
            if ($envFog_fogColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".fogColor") $envFog_fogColor_gammaValue`;
            }
            ////////////////////////////////////////////
            int $envFog_fogOpacity_CheckBox_State = `checkBoxGrp -q -v1 envFog_fogOpacity_CheckBox`;
            float $envFog_fogOpacity_gammaValue = `floatFieldGrp -q -value1 envFog_fogOpacity_GammaField`;
            if ($envFog_fogOpacity_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".fogOpacity") $envFog_fogOpacity_gammaValue`;
            }    
            ////////////////////////////////////////////
            int $envFog_airColor_CheckBox_State = `checkBoxGrp -q -v1 envFog_airColor_CheckBox`;
            float $envFog_airColor_gammaValue = `floatFieldGrp -q -value1 envFog_airColor_GammaField`;
            if ($envFog_airColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".airColor") $envFog_airColor_gammaValue`;
            }
            ////////////////////////////////////////////
            int $envFog_airOpacity_CheckBox_State = `checkBoxGrp -q -v1 envFog_airOpacity_CheckBox`;
            float $envFog_airOpacity_gammaValue = `floatFieldGrp -q -value1 envFog_airOpacity_GammaField`;
            if ($envFog_airOpacity_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".airOpacity") $envFog_airOpacity_gammaValue`;
            }
            ////////////////////////////////////////////
            int $envFog_waterColor_CheckBox_State = `checkBoxGrp -q -v1 envFog_waterColor_CheckBox`;
            float $envFog_waterColor_gammaValue = `floatFieldGrp -q -value1 envFog_waterColor_GammaField`;
            if ($envFog_waterColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".waterColor") $envFog_waterColor_gammaValue`;
            }
            ////////////////////////////////////////////
            int $envFog_waterOpacity_CheckBox_State = `checkBoxGrp -q -v1 envFog_waterOpacity_CheckBox`;
            float $envFog_waterOpacity_gammaValue = `floatFieldGrp -q -value1 envFog_waterOpacity_GammaField`;
            if ($envFog_waterOpacity_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".waterOpacity") $envFog_waterOpacity_gammaValue`;
            }    
            ////////////////////////////////////////////
            int $envFog_sunColor_CheckBox_State = `checkBoxGrp -q -v1 envFog_sunColor_CheckBox`;
            float $envFog_sunColor_gammaValue = `floatFieldGrp -q -value1 envFog_sunColor_GammaField`;
            if ($envFog_sunColor_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".sunColor") $envFog_sunColor_gammaValue`;
            }    
            break;

        case "dgs_material":
            int $dgs_material_diffuse_CheckBox_State = `checkBoxGrp -q -v1 dgs_material_diffuse_CheckBox`;
            float $dgs_material_diffuse_gammaValue = `floatFieldGrp -q -value1 dgs_material_diffuse_GammaField`;
            if ($dgs_material_diffuse_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".diffuse") $dgs_material_diffuse_gammaValue`;
            }
            ////////////////////////////////////////////
            int $dgs_material_glossy_CheckBox_State = `checkBoxGrp -q -v1 dgs_material_glossy_CheckBox`;
            float $dgs_material_glossy_gammaValue = `floatFieldGrp -q -value1 dgs_material_glossy_GammaField`;
            if ($dgs_material_glossy_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".glossy") $dgs_material_glossy_gammaValue`;
            }
            ////////////////////////////////////////////
            int $dgs_material_specular_CheckBox_State = `checkBoxGrp -q -v1 dgs_material_specular_CheckBox`;
            float $dgs_material_specular_gammaValue = `floatFieldGrp -q -value1 dgs_material_specular_GammaField`;
            if ($dgs_material_specular_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".specular") $dgs_material_specular_gammaValue`;
            }
            break;

        case "dielectric_material":
            int $dielectric_material_col_CheckBox_State = `checkBoxGrp -q -v1 dielectric_material_col_CheckBox`;
            float $dielectric_material_col_gammaValue = `floatFieldGrp -q -value1 dielectric_material_col_GammaField`;
            if ($dielectric_material_col_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".col") $dielectric_material_col_gammaValue`;
            }
            ////////////////////////////////////////////
            int $dielectric_material_col_out_CheckBox_State = `checkBoxGrp -q -v1 dielectric_material_col_out_CheckBox`;
            float $dielectric_material_col_out_gammaValue = `floatFieldGrp -q -value1 dielectric_material_col_out_GammaField`;
            if ($dielectric_material_col_out_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".col_out") $dielectric_material_col_out_gammaValue`;
            }
            break;

        case "mi_car_paint_phen_x":
        case "mi_car_paint_phen_x_passes":
        case "mi_car_paint_phen":
            int $mi_car_paint_phen_ambient_CheckBox_State = `checkBoxGrp -q -v1 mi_car_paint_phen_ambient_CheckBox`;
            float $mi_car_paint_phen_ambient_gammaValue = `floatFieldGrp -q -value1 mi_car_paint_phen_ambient_GammaField`;
            if ($mi_car_paint_phen_ambient_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".ambient") $mi_car_paint_phen_ambient_gammaValue`;
            }
            ////////////////////////////////////////////
            int $mi_car_paint_phen_base_color_CheckBox_State = `checkBoxGrp -q -v1 mi_car_paint_phen_base_color_CheckBox`;
            float $mi_car_paint_phen_base_color_gammaValue = `floatFieldGrp -q -value1 mi_car_paint_phen_base_color_GammaField`;
            if ($mi_car_paint_phen_base_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".base_color") $mi_car_paint_phen_base_color_gammaValue`;
            }
            ////////////////////////////////////////////
            int $mi_car_paint_phen_edge_color_CheckBox_State = `checkBoxGrp -q -v1 mi_car_paint_phen_edge_color_CheckBox`;
            float $mi_car_paint_phen_edge_color_gammaValue = `floatFieldGrp -q -value1 mi_car_paint_phen_edge_color_GammaField`;
            if ($mi_car_paint_phen_edge_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".edge_color") $mi_car_paint_phen_edge_color_gammaValue`;
            }    
            ////////////////////////////////////////////
            int $mi_car_paint_phen_lit_color_CheckBox_State = `checkBoxGrp -q -v1 mi_car_paint_phen_lit_color_CheckBox`;
            float $mi_car_paint_phen_lit_color_gammaValue = `floatFieldGrp -q -value1 mi_car_paint_phen_lit_color_GammaField`;
            if ($mi_car_paint_phen_lit_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".lit_color") $mi_car_paint_phen_lit_color_gammaValue`;
            }
            ////////////////////////////////////////////
            int $mi_car_paint_phen_spec_CheckBox_State = `checkBoxGrp -q -v1 mi_car_paint_phen_spec_CheckBox`;
            float $mi_car_paint_phen_spec_gammaValue = `floatFieldGrp -q -value1 mi_car_paint_phen_spec_GammaField`;
            if ($mi_car_paint_phen_spec_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".spec") $mi_car_paint_phen_spec_gammaValue`;
            }
            ////////////////////////////////////////////
            int $mi_car_paint_phen_spec_sec_CheckBox_State = `checkBoxGrp -q -v1 mi_car_paint_phen_spec_sec_CheckBox`;
            float $mi_car_paint_phen_spec_sec_gammaValue = `floatFieldGrp -q -value1 mi_car_paint_phen_spec_sec_GammaField`;
            if ($mi_car_paint_phen_spec_sec_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".spec_sec") $mi_car_paint_phen_spec_sec_gammaValue`;
            }
            ////////////////////////////////////////////
            int $mi_car_paint_phen_flake_color_CheckBox_State = `checkBoxGrp -q -v1 mi_car_paint_phen_flake_color_CheckBox`;
            float $mi_car_paint_phen_flake_color_gammaValue = `floatFieldGrp -q -value1 mi_car_paint_phen_flake_color_GammaField`;
            if ($mi_car_paint_phen_flake_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".flake_color") $mi_car_paint_phen_flake_color_gammaValue`;
            }    
            ////////////////////////////////////////////
            int $mi_car_paint_phen_reflection_color_CheckBox_State = `checkBoxGrp -q -v1 mi_car_paint_phen_reflection_color_CheckBox`;
            float $mi_car_paint_phen_reflection_color_gammaValue = `floatFieldGrp -q -value1 mi_car_paint_phen_reflection_color_GammaField`;
            if ($mi_car_paint_phen_reflection_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".reflection_color") $mi_car_paint_phen_reflection_color_gammaValue`;
            }
            ////////////////////////////////////////////
            int $mi_car_paint_phen_dirt_color_CheckBox_State = `checkBoxGrp -q -v1 mi_car_paint_phen_dirt_color_CheckBox`;
            float $mi_car_paint_phen_dirt_color_gammaValue = `floatFieldGrp -q -value1 mi_car_paint_phen_dirt_color_GammaField`;
            if ($mi_car_paint_phen_dirt_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".dirt_color") $mi_car_paint_phen_dirt_color_gammaValue`;
            }    
            break;

        case "mi_metallic_paint_x":
        case "mi_metallic_paint_x_passes":
        case "mi_metallic_paint":
            int $mi_metallic_paint_ambient_CheckBox_State = `checkBoxGrp -q -v1 mi_metallic_paint_ambient_CheckBox`;
            float $mi_metallic_paint_ambient_gammaValue = `floatFieldGrp -q -value1 mi_metallic_paint_ambient_GammaField`;
            if ($mi_metallic_paint_ambient_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".ambient") $mi_metallic_paint_ambient_gammaValue`;
            }
            ////////////////////////////////////////////
            int $mi_metallic_paint_base_color_CheckBox_State = `checkBoxGrp -q -v1 mi_metallic_paint_base_color_CheckBox`;
            float $mi_metallic_paint_base_color_gammaValue = `floatFieldGrp -q -value1 mi_metallic_paint_base_color_GammaField`;
            if ($mi_metallic_paint_base_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".base_color") $mi_metallic_paint_base_color_gammaValue`;
            }
            ////////////////////////////////////////////
            int $mi_metallic_paint_edge_color_CheckBox_State = `checkBoxGrp -q -v1 mi_metallic_paint_edge_color_CheckBox`;
            float $mi_metallic_paint_edge_color_gammaValue = `floatFieldGrp -q -value1 mi_metallic_paint_edge_color_GammaField`;
            if ($mi_metallic_paint_edge_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".edge_color") $mi_metallic_paint_edge_color_gammaValue`;
            }    
            ////////////////////////////////////////////
            int $mi_metallic_paint_lit_color_CheckBox_State = `checkBoxGrp -q -v1 mi_metallic_paint_lit_color_CheckBox`;
            float $mi_metallic_paint_lit_color_gammaValue = `floatFieldGrp -q -value1 mi_metallic_paint_lit_color_GammaField`;
            if ($mi_metallic_paint_lit_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".lit_color") $mi_metallic_paint_lit_color_gammaValue`;
            }
            ////////////////////////////////////////////
            int $mi_metallic_paint_spec_CheckBox_State = `checkBoxGrp -q -v1 mi_metallic_paint_spec_CheckBox`;
            float $mi_metallic_paint_spec_gammaValue = `floatFieldGrp -q -value1 mi_metallic_paint_spec_GammaField`;
            if ($mi_metallic_paint_spec_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".spec") $mi_metallic_paint_spec_gammaValue`;
            }
            ////////////////////////////////////////////
            int $mi_metallic_paint_spec_sec_CheckBox_State = `checkBoxGrp -q -v1 mi_metallic_paint_spec_sec_CheckBox`;
            float $mi_metallic_paint_spec_sec_gammaValue = `floatFieldGrp -q -value1 mi_metallic_paint_spec_sec_GammaField`;
            if ($mi_metallic_paint_spec_sec_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".spec_sec") $mi_metallic_paint_spec_sec_gammaValue`;
            }
            ////////////////////////////////////////////
            int $mi_metallic_paint_flake_color_CheckBox_State = `checkBoxGrp -q -v1 mi_metallic_paint_flake_color_CheckBox`;
            float $mi_metallic_paint_flake_color_gammaValue = `floatFieldGrp -q -value1 mi_metallic_paint_flake_color_GammaField`;
            if ($mi_metallic_paint_flake_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".flake_color") $mi_metallic_paint_flake_color_gammaValue`;
            }        
            break;

        case "mia_material_x":
        case "mia_material_x_passes":
        case "mia_material":
            int $mia_material_diffuse_CheckBox_State = `checkBoxGrp -q -v1 mia_material_diffuse_CheckBox`;
            float $mia_material_diffuse_gammaValue = `floatFieldGrp -q -value1 mia_material_diffuse_GammaField`;
            if ($mia_material_diffuse_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".diffuse") $mia_material_diffuse_gammaValue`;
            }
            ////////////////////////////////////////////
            int $mia_material_refl_color_CheckBox_State = `checkBoxGrp -q -v1 mia_material_refl_color_CheckBox`;
            float $mia_material_refl_color_gammaValue = `floatFieldGrp -q -value1 mia_material_refl_color_GammaField`;
            if ($mia_material_refl_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".refl_color") $mia_material_refl_color_gammaValue`;
            }
            ////////////////////////////////////////////
            int $mia_material_refl_falloff_color_CheckBox_State = `checkBoxGrp -q -v1 mia_material_refl_falloff_color_CheckBox`;
            float $mia_material_refl_falloff_color_gammaValue = `floatFieldGrp -q -value1 mia_material_refl_falloff_color_GammaField`;
            if ($mia_material_refl_falloff_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".refl_falloff_color") $mia_material_refl_falloff_color_gammaValue`;
            }    
            ////////////////////////////////////////////
            int $mia_material_refr_color_CheckBox_State = `checkBoxGrp -q -v1 mia_material_refr_color_CheckBox`;
            float $mia_material_refr_color_gammaValue = `floatFieldGrp -q -value1 mia_material_refr_color_GammaField`;
            if ($mia_material_refr_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".refr_color") $mia_material_refr_color_gammaValue`;
            }
            ////////////////////////////////////////////
            int $mia_material_refr_falloff_color_CheckBox_State = `checkBoxGrp -q -v1 mia_material_refr_falloff_color_CheckBox`;
            float $mia_material_refr_falloff_color_gammaValue = `floatFieldGrp -q -value1 mia_material_refr_falloff_color_GammaField`;
            if ($mia_material_refr_falloff_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".refr_falloff_color") $mia_material_refr_falloff_color_gammaValue`;
            }
            ////////////////////////////////////////////
            int $mia_material_refr_trans_color_CheckBox_State = `checkBoxGrp -q -v1 mia_material_refr_trans_color_CheckBox`;
            float $mia_material_refr_trans_color_gammaValue = `floatFieldGrp -q -value1 mia_material_refr_trans_color_GammaField`;
            if ($mia_material_refr_trans_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".refr_trans_color") $mia_material_refr_trans_color_gammaValue`;
            }
            ////////////////////////////////////////////
            int $mia_material_ao_dark_CheckBox_State = `checkBoxGrp -q -v1 mia_material_ao_dark_CheckBox`;
            float $mia_material_ao_dark_gammaValue = `floatFieldGrp -q -value1 mia_material_ao_dark_GammaField`;
            if ($mia_material_ao_dark_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".ao_dark") $mia_material_ao_dark_gammaValue`;
            }        
            break;
            ////////////////////////////////////////////
            int $mia_material_ao_ambient_CheckBox_State = `checkBoxGrp -q -v1 mia_material_ao_ambient_CheckBox`;
            float $mia_material_ao_ambient_gammaValue = `floatFieldGrp -q -value1 mia_material_ao_ambient_GammaField`;
            if ($mia_material_ao_ambient_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".ao_ambient") $mia_material_ao_ambient_gammaValue`;
            }        
            break;
            ////////////////////////////////////////////
            int $mia_material_additional_color_CheckBox_State = `checkBoxGrp -q -v1 mia_material_additional_color_CheckBox`;
            float $mia_material_additional_color_gammaValue = `floatFieldGrp -q -value1 mia_material_additional_color_GammaField`;
            if ($mia_material_additional_color_CheckBox_State == 1)
            {
                $send = `createGammaNode ($selName + ".additional_color") $mia_material_additional_color_gammaValue`;
            }        
            break;

        default:
            print ("Selected Type is: " + $selectedType + "\n");
            print ("Something went wrong in applyPressed" + "\n");
     }
    select -r $selName;
	}
global proc applyClosePressed(){
    applyPressed;
    deleteUI gammaUIMainWindow;
	}
global proc int createGammaNode(string $attr, float $gammaValue){
    global string $selectedType;
    string $outgoing[] = {};
    string $incoming[] = {};
    string $outgoingObjectType = "";
    int $gammaAlreadyHere = 0;
    int $outgoingExists = 0;
    $outgoing = `listConnections -source true -destination false -plugs true  $attr`;
        if ($outgoing[0] != "")
        {
            $outgoingObjectType = `objectType $outgoing[0]`;
            $outgoingExists = 1;
            $incoming = `listConnections -source false -destination true -plugs true -type $selectedType $outgoing[0]`;
        }
    
    if ($outgoingObjectType == "gammaCorrect")
        {
            $gammaAlreadyHere = 1;
        }
    
    if ($gammaAlreadyHere == 1)
    {
        warning ("Gamma node is already connected to: " + $attr + "\n");
    }
        else
            {
                string $gammaNodeName = `shadingNode -asUtility gammaCorrect`;
    
                vector $colorVector = `getAttr $attr`; //  Store RGB values of attribute for later transfer to gamma node
        
                float $gammaColorX = $colorVector.x;
                float $gammaColorY = $colorVector.y;
                float $gammaColorZ = $colorVector.z;
    
                setAttr ($gammaNodeName + ".gammaX") $gammaValue;
                setAttr ($gammaNodeName + ".gammaY") $gammaValue;
                setAttr ($gammaNodeName + ".gammaZ") $gammaValue;
                setAttr ($gammaNodeName + ".value") -type double3 $gammaColorX $gammaColorY $gammaColorZ;

                connectAttr -force ($gammaNodeName + ".outValue") $attr;
                
                if ($outgoingExists == 1)
                {
                    connectAttr -force $outgoing[0] ($gammaNodeName + ".value");
                }
            }

    return 1;
	}
global proc cancelPressed(){
    deleteUI gammaUIMainWindow;
	}

////LISTS
global proc rcRLMUpdateList(string $list){
	}
global proc rcRLMListLayers() {
    for ($each in (rcListRenderLayers("NoNS")))textScrollList -e -a $each layList;
    textScrollList -e -sii 1 layList;   
	}
global proc rcRLMListConnect() {				//list OBJ and OVERRIDES textscrollList 
    textScrollList -e -ra conList; 
    textScrollList -e -ra objList;    
    string $selLay[] = `textScrollList -q -si layList`;     
    if(!($selLay[0] == "")){
        string $objLay[] = `editRenderLayerMembers -q -fn $selLay`;
        string $Object[] = `ls -l -tr -type "transform" $objLay`;        
        for ($each in $Object) textScrollList -e -a $each objList;
        string $conLayer[] = `editRenderLayerAdjustment -q -layer $selLay`;
        for ($each in $conLayer) textScrollList -e -a $each conList;
        updateRPass(); rcRLMListAssociatePass(); updateContMap();
        textScrollList -e -ra objContMapList;
    	textScrollList -e -ra assoContMapList; 
    }
	}
global proc rcRLMListPasses() {					//list PASSES
    string $Passes[] = `ls -type "renderPass"`;
    string $selAllLay[] = `textScrollList -q -ai layList`;        
    if ($Passes[0] == ""  || $selAllLay[0] == ""){}
    else{
        string $selLay[] = `textScrollList -q -si layList`;
        string $AsssociatePass[];       
        string $AssociatePass[] = `listConnections (($selLay[0] + ".renderPass"))`;    
        for ($each in $Passes){
            textScrollList -e -a $each scenePassList;        
            string $PassesSolo = $each;   
            for ($i=0; $i<(size($AssociatePass)); ++$i){
                if ( $PassesSolo == $AssociatePass[$i]){
                    textScrollList -e -ri $each scenePassList;
                }   
            }
        }
    }
	}       
global proc rcRLMListAssociatePass() {		//list Associated PASSES 
    textScrollList -e -ra passList;    
    string $selLay[] = `textScrollList -q -si layList`;
    string $AssociatePass[] = `listConnections ($selLay[0]+".renderPass")`;
    string $scenePass[] = `textScrollList -q -ai scenePassList`;
    for ($each in $AssociatePass){
        textScrollList -e -a $each passList;
    }
	}
global proc rcRLMListContrMap() {				//list contr maps
    string $contMap[] = `ls -type "passContributionMap"`;
    string $selLay[] = `textScrollList -q -si layList`;
    string $AssociateContMap[] = `listConnections ($selLay[0]+".passContributionMap")`;    
    for ($each in $AssociateContMap){
        textScrollList -e -a $each contMapList;        
    }
	}
global proc rcRLMListContrMapObj() {			//list OBJ in contr Map
    textScrollList -e -ra objContMapList;    
    string $selContMap[] = `textScrollList -q -si contMapList`;     
    string $ContMapObj[] = `listConnections ($selContMap[0]+".dagObjects")`;
    
    for ($each in $ContMapObj){
        textScrollList -e -a $each objContMapList;
    }
    rcUpdateObjList();
    updateContMapPass();
	}
global proc updateRLayer() {					//Update render layers
    string $selLayer[] = `textScrollList -q -si layList`;
    enableBtn(); rcRLMListLayers();
    string $selAllLay[] = `textScrollList -q -ai layList`;     
    if ($selAllLay[0] == "") warning "Create a render layer."; 
    else {
        string $currentLay[] = `textScrollList -q -si layList`;       
        textScrollList -e -ra layList;
        rcRLMListLayers();
        textScrollList -e -si $selLayer[0] layList;
        rcUpdateObjList(); updateRPass(); updateOverrides();
    }
	} 
global proc rcUpdateObjList() {					//refresh OBJ list
    textScrollList -e -ra objList;    
    string $selLay[] = `textScrollList -q -si layList`;     
    if(!($selLay[0] == ""))
    {
        string $objLay[] = `editRenderLayerMembers -q -fn $selLay`;
        string $Object[] = `ls -l -tr $objLay`;
        for ($each in $Object) textScrollList -e -a $each objList;          
    }    
	} 
global proc updateOverrides() {
    textScrollList -e -ra conList;
    string $selLay[] = `textScrollList -q -si layList`;     
    string $conLayer[] = `editRenderLayerAdjustment -q -layer $selLay`;
    for ($each in $conLayer) textScrollList -e -a $each conList; 
	}
global proc rcUpdateList(string $list){
	textScrollList -e -ra $list;
	}
global proc updateRPass() {
     textScrollList -e -ra scenePassList; 
     rcRLMListPasses();
	}
global proc updateContMap() {
    textScrollList -e -ra contMapList;
    rcRLMListContrMap();
	}
global proc updateContMapObj() {
    textScrollList -e -ra objContMapList;
    rcRLMListContrMapObj();
	}
global proc updateContMapPass() {
    textScrollList -e -ra assoContMapList;
    contMapPassList();
	}
global proc enableBtn(){					//enable
    string $Layers[] = `textScrollList -q -ai layList`;
    if ($Layers[0] == ""){
        textScrollList -e -ra scenePassList;textScrollList -e -ra assoContMapList;
        textScrollList -e -ra passList; textScrollList -e -ra contMapList; 
        textScrollList -e -ra conList; textScrollList -e -ra objContMapList; 
        button -e -en 1 btn1;button -e -en 0 btn2;button -e -en 0 btn3;
        button -e -en 0 btn4;button -e -en 0 btn5;button -e -en 0 btn6;
        button -e -en 0 btn7;button -e -en 0 btn8;button -e -en 0 btn9;
        button -e -en 0 btn10;button -e -en 0 btn11;button -e -en 0 btn12;
        button -e -en 0 btn13;button -e -en 0 btn14;button -e -en 0 btn15;
        button -e -en 0 btn16;button -e -en 0 btn17;button -e -en 0 btn18;
        button -e -en 0 btn19;button -e -en 0 btn20;button -e -en 0 btn21;
        button -e -en 0 btn22;button -e -en 0 btn23;button -e -en 1 btn24;
        textField -e -en 0 renameLayers; textField -e -en 0 renameContrMap; 
    } 
    else {
        button -e -en 1 btn1;button -e -en 1 btn2;button -e -en 1 btn3;
        button -e -en 1 btn4;button -e -en 1 btn5;button -e -en 1 btn6;
        button -e -en 1 btn7;button -e -en 1 btn8;button -e -en 1 btn9;
        button -e -en 1 btn10;button -e -en 1 btn11;button -e -en 1 btn12;
        button -e -en 1 btn13;button -e -en 1 btn14;button -e -en 1 btn15;
        button -e -en 1 btn16;button -e -en 1 btn17;button -e -en 1 btn18;
        button -e -en 1 btn19;button -e -en 1 btn20;button -e -en 1 btn21;
        button -e -en 1 btn22;button -e -en 1 btn23;button -e -en 1 btn24;
        textField -e -en 1 renameLayers; textField -e -en 1 renameContrMap; //textScrollList -e -en 0 scenePassList;
    }
	}
global proc deleteRLayer() {				//delete LAYERS
    string $selLay[] = `textScrollList -q -si layList`;
    gotoMLayer();   
    for ($each in $selLay) delete $each; 
  
    textScrollList -e -ra layList;
    textScrollList -e -ra contMapList; 
    textScrollList -e -ra objContMapList;
    textScrollList -e -ra assoContMapList;     
    rcRLMListLayers();
    rcUpdateObjList();
    updateRLayer();
    enableBtn();
	}
global proc addObjLayer() {					//add Object to the selected render layers
    string $sel[] = `ls -sl`;
    if ($sel[0] == "") warning "Select object.";    
    else 
    {    
        string $selLay[] = `textScrollList -q -si layList`;    
        string $selObj[] = `textScrollList -q -ai objList`;   
        for ($each in $sel)
        {
            editRenderLayerMembers -nr $selLay $each;
            textScrollList -e -a $each objList;
        }
        rcUpdateObjList();
    }    
	}
global proc removeOverLayer() {				//remove Override to the selected render layers
    string $sel[] = `textScrollList -q -si conList`;
    if ($sel[0] == "")
    {
        warning "Select override in render layer.";    
    } 
    else 
    { 
        string $selLay[] = `textScrollList -q -si layList`;    
        for ($each in $sel)
        {
            editRenderLayerGlobals -currentRenderLayer $selLay;        
            editRenderLayerAdjustment -r $each $selLay;
            textScrollList -e -ri $each conList;
        }
    }
	}
global proc removeObjLayer() {				//remove Object to the selected render layers
    string $sel[] = `textScrollList -q -si objList`;
    if ($sel[0] == ""){
        warning "Select object in render layer.";    
    } else {    
        string $selLay[] = `textScrollList -q -si layList`;    
        for ($each in $sel){
            select -r $each;
            string $ObjNew[] = `ls -dag $each`;
            for ($obj in $ObjNew){
                editRenderLayerMembers -r -nr $selLay $obj;
            }
            textScrollList -e -ri $each objList;    
        }
    }
	}
global proc gotoRLayer() {					//go to selected render layer
    string $selLay[] = `textScrollList -q -si layList`;    
    editRenderLayerGlobals -currentRenderLayer $selLay;
	}
global proc selectObjList(string $objsList) {			//Select objs render layer
    string $selObjs[] = `textScrollList -q -ai $objsList`;
    if ($selObjs[0] == ""){
        warning "Render layer is empty.";    
    } else {    
        string $sel[] = `textScrollList -q -si $objsList`;        
        string $selLay[] = `textScrollList -q -si layList`;    
        if ($sel[0] == ""){
            string $objLay[] = `textScrollList -q -ai $objsList`;
            select $objLay;     
        } else {    
            select $sel; 
        }
    }
	}
global proc gotoMLayer() {					//go to master layer
    editRenderLayerGlobals -currentRenderLayer defaultRenderLayer;
	}
global proc renameLayer() {				//rename selected layer
    string $selLay[] = `textScrollList -q -si layList`;
    string $RLayName = `textField -q -tx renameLayers`;    
    if ($RLayName == ""){
       warning ("You haven't defined a name.");
    } else {    
        select $selLay;    
        rename $selLay $RLayName;
        textField -e -tx "" renameLayers;
        updateRLayer();
        textScrollList -e -si $RLayName layList;
    }    
	}
global proc createMyRPasses(){		    // create my default render passes

    createNode -name "beauty" renderPass;
    string $sel[] = `ls -sl`;
    applyAttrPreset $sel[0] "C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/beauty.mel" 1;
    
    createNode -name "depth" renderPass;
    string $sel[] = `ls -sl`;
    applyAttrPreset $sel[0] "C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/cameraDepth.mel" 1;
    
    createNode -name "diffuse" renderPass;
    string $sel[] = `ls -sl`;
    applyAttrPreset $sel[0] "C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/diffuse.mel" 1;
    
    createNode -name "incandescence" renderPass;
    string $sel[] = `ls -sl`;
    applyAttrPreset $sel[0] "C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/incandescence.mel" 1;
    
    createNode -name "indirect" renderPass;
    string $sel[] = `ls -sl`;
    applyAttrPreset $sel[0] "C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/indirect.mel" 1;
    
    createNode -name "normalWorld" renderPass;
    string $sel[] = `ls -sl`;
    applyAttrPreset $sel[0] "C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/normalWorld.mel" 1;
    
    createNode -name "mv2DToxik" renderPass;
    string $sel[] = `ls -sl`;
    applyAttrPreset $sel[0] "C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/2DMotionVector.mel" 1;
    
    createNode -name "reflection" renderPass;
    string $sel[] = `ls -sl`;
    applyAttrPreset $sel[0] "C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/reflection.mel" 1;
    
    createNode -name "refraction" renderPass;
    string $sel[] = `ls -sl`;
    applyAttrPreset $sel[0] "C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/refraction.mel" 1;
    
    createNode -name "shadow" renderPass;
    string $sel[] = `ls -sl`;
    applyAttrPreset $sel[0] "C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/shadow.mel" 1;
    
    createNode -name "specular" renderPass;
    string $sel[] = `ls -sl`;
    applyAttrPreset $sel[0] "C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/specular.mel" 1;

    string $posPass = `createNode -name "PointPass" renderPass`;
    applyAttrPreset $posPass "C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/customVector.mel" 1;
    setAttr ($posPass + ".filtering") 0;
    string $writeToVector = `createNode -name "writeToVectorBuffer_PointWorld" writeToVectorBuffer`;
    connectAttr ($posPass + ".message") ($writeToVector + ".renderPass");
    string $samplerInfoWTV = `shadingNode -asUtility samplerInfo`;
    connectAttr -f ($samplerInfoWTV + ".pointWorld") ($writeToVector + ".vector");    
    
    rcRLMListPasses();
	}
global proc associatePass() {			    //Associate selected PASSES 
    string $selLay[] = `textScrollList -q -si layList`;
    string $scenePass[] = `textScrollList -q -si scenePassList`;
    if ($scenePass[0] == ""){
        warning "Select a scene pass.";    
    } else {     
        for ($each in $scenePass){
            textScrollList -e -ri $each scenePassList;      
            connectAttr -nextAvailable ($selLay[0] + ".renderPass") ($each + ".owner");
        }
        rcRLMListAssociatePass();
    }
	}
global proc removePass() {					//disassociate selected PASSES 
    string $selLay[] = `textScrollList -q -si layList`;
    string $associatePass[] = `textScrollList -q -si passList`;
    string $checkAssociatePassContMap[] = `textScrollList -q -ai assoContMapList`;
    string $ContMapAll[] = `textScrollList -q -ai contMapList`;
    if ($associatePass[0] == ""){
        warning "Select a associated pass.";    
    } else {   
        for ($each in $associatePass){
            string $CurrentAssoPass = $each;
            disconnectAttr -nextAvailable ($selLay[0] + ".renderPass") ($each + ".owner");
            rcRLMListAssociatePass();
            updateRPass();
            string $passConnectedMap[] = `listConnections -d on ($each + ".message")`;            
            if ($passConnectedMap[0] == ""){
                print "Done.";
            } else {
                disconnectAttr -nextAvailable ($each + ".message") ($passConnectedMap[0] + ".renderPass");
                updateContMapPass();                
            }
        }
    }     
	}
global proc deletePass() {					//delete selected PASSES 
    string $scenePass[] = `textScrollList -q -si scenePassList`;
    string $associatePass[] = `textScrollList -q -si passList`;
    if ($scenePass[0] == "" && $associatePass[0] == "" ){
        warning "Select pass.";
    } else {    
        for ($each in $associatePass){
            delete $each;
        }
        for ($each in $scenePass){
            delete $each;
        }
        
    updateRPass();
    rcRLMListAssociatePass();
    updateContMapPass();
    }
	}
global proc addObjContrPass() {          //add Object to the selected contribution map
    string $selContMap[] = `textScrollList -q -si contMapList`;    
    string $sel[] = `ls -sl -type "transform"`;    
    string $objSel[] = `textScrollList -q -si objList`;
    if ($selContMap[0] == ""){
        warning "Select a pass contribution map.";
    } else if ($sel[0] == "" && $objSel[0] == ""){
        warning "Select a object.";
    } else {                
        string $selLay[] = `textScrollList -q -si layList`;    
        for ($i=0; $i<(size($sel)); ++$i){
            string $objContMap[] = `listConnections -d on ($sel[$i] + ".message")`;
            if ($objContMap[0] == $selContMap[0]){
                 print "Seleceted object is already connected.";                  
            } else {
                editRenderLayerMembers -nr $selLay[0] $sel[$i];
                textScrollList -e -a $sel[$i] objContMapList;
                connectAttr -na  ($sel[$i] + ".message") ($selContMap[0] + ".dagObjects");                 
            }
        }
        
        for ($i=0; $i<(size($objSel)); ++$i){
            string $objContMap[] = `listConnections -d on ($objSel[$i] + ".message")`;
            if ($objContMap[0] == $selContMap[0]){
                print "Seleceted object is already connected.";                 
            } else {
                textScrollList -e -a $objSel[$i] objContMapList;
                connectAttr -na  ($objSel[$i] + ".message") ($selContMap[0] + ".dagObjects");          
            }
        }        
    }
    rcUpdateObjList();
	}
global proc removeObjContrPass() {	//remove Object to the selected contribution map
    string $objSel[] = `textScrollList -q -si objContMapList`;
    if ($objSel[0] == ""){
        warning "Select object in pass contribution map.";    
    } else {    
        string $selContMap[] = `textScrollList -q -si contMapList`;    
        for ($each in $objSel){
            textScrollList -e -ri $each objContMapList;
            disconnectAttr -na  ($each + ".message") ($selContMap[0] + ".dagObjects");
        }
    }    
    rcUpdateObjList();
	}
global proc contMapPassList() {			//List selected PASSES to contribution map
    textScrollList -e -ra assoContMapList;    
    string $selContMap[] = `textScrollList -q -si contMapList`;
    if ($selContMap[0] == ""){
    } else {    
        string $AssociatePassContMap[] = `listConnections ($selContMap[0]+".renderPass")`;
        for ($each in $AssociatePassContMap){
            textScrollList -e -a $each assoContMapList;
        }
    }
	}
global proc associatePassContMap() {	//Associate selected PASSES to contribution map
    string $selContMap[] = `textScrollList -q -si contMapList`;
    string $selAssociatePass[] = `textScrollList -q -si passList`;
    string $checkAssociatePassContMap[] = `textScrollList -q -ai assoContMapList`;
    if ($selContMap[0] == ""){
        warning "Select a pass contribution map.";    
    } else if ($selAssociatePass[0] == ""){
        warning "Select a associated pass.";
    } else {
        int $num = 0;    
        for ($each in $selAssociatePass){
            string $selAssociatePassSolo = $each;   
            for ($i=0; $i<(size($checkAssociatePassContMap)); ++$i){
                if ( $selAssociatePassSolo == $checkAssociatePassContMap[$i]){
                    $num += 1;                 
                } else {
                //print $num;
                }
            }    
            if ($num >= 1) {
                print "Render pass is already connected.";
            } else {                    
                connectAttr -nextAvailable ($selAssociatePassSolo + ".message") ($selContMap[0] + ".renderPass");
            }  
        }
        updateContMapPass();    
    }
	}                
global proc disassociatePass() {			//disassociate selected PASSES to contribution map
    string $selContMap[] = `textScrollList -q -si contMapList`;
    string $disassociatePass[] = `textScrollList -q -si assoContMapList`;
    if ($selContMap[0] == ""){
        warning "Select a pass contribution map.";    
    } else if ($disassociatePass[0] == ""){
        warning "Select a pass used by the pass contribution map.";
        } else {
        for ($each in $disassociatePass){
            disconnectAttr -nextAvailable ($each + ".message") ($selContMap[0] + ".renderPass");
        }
        updateContMapPass();
        rcRLMListAssociatePass(); 
    }
	}
global proc selPass(string $listSel){		//render pass attributes
    string $selPass[] = `textScrollList -q -si $listSel`;    
    select $selPass[0];
    setAttributeEditorVisible( false );
    ToggleAttributeEditor;
	}
global proc selectObjListCont() {			//Select objs contr map
    string $listObjContMap[] = `textScrollList -q -ai objContMapList`;
    if ($listObjContMap[0] == ""){
        warning "Pass contribution map is empty.";    
    } else {
        string $sel[] = `textScrollList -q -si objContMapList`;
        string $selContMap[] = `textScrollList -q -si contMapList`;    
        if ($sel[0] == ""){
            string $objContMap[] = `listConnections -d off ($selContMap[0] + ".dagObjects")`;
            select $objContMap;     
        } else {    
            select $sel; 
        }
    }
	}
global proc createContrMap(){				//create contr pass and connect to selected layer
    string $newContrMap = `createNode passContributionMap`;
    string $selLay[] = `textScrollList -q -si layList`; 
    connectAttr -na ($selLay[0] + ".passContributionMap") ($newContrMap + ".owner");
    updateContMap();     
	}
global proc deleteContrMap(){				//create contr pass and connect to selected layer
    string $selContrMap[] = `textScrollList -q -si contMapList`; 
    if ($selContrMap[0] == ""){
        warning "Select a pass contribution map.";
    } else {
        delete $selContrMap;
        textScrollList -e -ra objContMapList;
        textScrollList -e -ra assoContMapList;      
        updateContMap();
    }    
	}
global proc renameContrMap() {			//rename selected contribution Map
    string $selContrMap[] = `textScrollList -q -si contMapList`; 
    string $contMapName = `textField -q -tx renameContrMap`;    
    if ($contMapName == ""){
       warning ("You haven't defined a name.");
    } else if ($selContrMap[0] == ""){
        warning ("You haven't select a pass contribution map.");
    } else {     
        select $selContrMap;    
        rename $selContrMap $contMapName;
        textField -e -tx "" renameContrMap;
        updateContMap();
        textScrollList -e -si $contMapName contMapList;
    }    
	}
global proc copySelRLayer(){				//copy selected layer
    string $copySLay = `editRenderLayerGlobals -q -currentRenderLayer`; 
    renderLayerEditorCopyLayer RenderLayerTab $copySLay;
	}
global proc copyRLayer(){					//copy layer render manager
    string $copySelLay[] = `textScrollList -q -si layList`; 
    for ($each in $copySelLay){        
        renderLayerEditorCopyLayer RenderLayerTab $copySelLay[0];
        updateRLayer();
    }
	}
global proc rcExportRenderLayerMel(){	// export Render Layer procedure
    string $defLay = "defaultRenderLayer";
    string $fileName = `file -q -shortName -sceneName`;    
    string $DirName = `workspace -q -fullName`;
    string $saveFileName[] = `fileDialog2  -caption "Export Render Layers." -fileMode 0 -startingDirectory $DirName -fileFilter "*.mel"`;
    if (!($saveFileName[0] == "")){
        //updateRLayer();
        $fileName = substituteAllString($fileName, ".mb", "");
        $fileName = substituteAllString($fileName, ".ma", "");
        sysFile -makeDir ($DirName + "/data/piko/");
        string $filePath = $saveFileName[0];
        $fileId = `fopen $filePath "w"`;
        string $queryScenePass[] = `ls -type "renderPass"`;   
        print "\n";
        for ($each in $queryScenePass)
        {
            string $ScenePassPrint = ("string $PassNew = `createNode -name " + ($each + "_new") + " renderPass`;\n");
            fprint $fileId $ScenePassPrint; 
            string $pass = $each;
            string $passAllAttr[] = `listAttr $pass`;
            string $pass = $each;
            string $PassTypePreset = `getAttr ($each + ".passID")`;    
            if (`gmatch $PassTypePreset "MV2E"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/2DMotionVector.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "MV3"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/3DMotionVector.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "AMBIRR"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/ambientIrradiance.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "AMBRAW"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/ambientMaterialColor.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "AO"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/ambientOcclusion.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "AMB"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/ambient.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "BEAUTY"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/beauty.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "CAMZ"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/cameraDepth.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "COV"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/coverage.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "CSTCOL"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/customColor.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "CSTZ"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/customDepth.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "CSTLBL"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/customLabel.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "CSTVCT"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/customVector.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "DIFRAW"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/diffuseMaterialColor.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "DIFF"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/diffuse.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "DIFFNS"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/diffuseWithoutShadows.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "DIRIRR"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/directIrradiance.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "DIRRNS"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/directIrradianceWithoutShadows.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "GLORAW"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/glowSource.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "INC"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/incandescence.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "INCILN"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/incidenceLightNorm.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "INDIRR"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/indirect.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "INCICN"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/incidenceCamNorm.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "INCMCN"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/incidenceCamNormMaterial.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "MATTE"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/matte.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "MV2N"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/normalized2DMotionVector.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "NORMAL"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/normalWorld.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "NORMAM"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/normalWorldMaterial.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "OPACTY"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/opacity.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "VOLLIT"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/lightVolume.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "VOLOBJ"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/objectVolume.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "REFLRA"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/reflectedMaterialColor.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "REFL"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/reflection.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "REFRRA"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/refractionMaterialColor.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "REFR"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/refraction.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "SCAT"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/scatter.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "SHDRAW"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/rawShadow.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "SHD"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/shadow.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "SPECNS"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/specularWithoutShadows.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "SPEC"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/specular.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "TRNSNS"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/translucenceWithoutShadows.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "TRNSLU"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/translucence.mel\" 1;\n");
            }
            if (`gmatch $PassTypePreset "VOLSCN"`){
                fprint $fileId ("applyAttrPreset $PassNew \"C:/Program Files/Autodesk/Maya2011/presets/attrPresets/renderPass/sceneVolume.mel\" 1;\n");
            }
            fprint $fileId ("addAttr -ln \"new\"  -at double $PassNew;\n");
            for ($each in $passAllAttr){
                if (`gmatch $each "backup*"` || `gmatch $each "brightColorR*"` || `gmatch $each "brightColorG*"` || `gmatch $each "brightColorB*"` || `gmatch $each "darkColorR*"` || `gmatch $each "darkColorG*"` || `gmatch $each "darkColorB*"`){
                } else {
                    string $passAttrType = `getAttr -type ($pass + "." + $each)`;             
                    if ($passAttrType == "message"){
                    } else if ($passAttrType == "string"){
                        string $passGetAttr = `getAttr ($pass + "." + $each)`;
                        fprint $fileId ("setAttr -type \"string\" ($PassNew + \"." + $each + "\") " + $passGetAttr + ";\n");
                    } else if ($passAttrType == "float3"){
                        string $conAttribute[] = `listConnections -d 0 -p 1 ($pass + "." + $each)`;
                        int $conAttributeSize = `size($conAttribute)`;
                        if ($conAttribute[0] == ""){ 
                            string $getAttrFloat = (" " + `getAttr ($pass + "." + $each + "R")` + " " + `getAttr ($pass + "." + $each + "G")` + " " + `getAttr ($pass + "." + $each + "B")`);
                            fprint $fileId ("setAttr ($PassNew + \"." + $each + "\") " + $getAttrFloat + ";\n");
                        } else {
                            string $ObjsExistsPrint = ("if ( `objExists " + $conAttribute[0] + "` ) {\n    ");          
                            fprint $fileId $ObjsExistsPrint;                      
                            fprint $fileId ("connectAttr -force " + $conAttribute[0] + " ($PassNew + \"." + $each + "\");\n");
                            fprint $fileId "}\n";
                        }
                    } else {
                        string $passGetAttr = `getAttr ($pass + "." + $each)`;
                        fprint $fileId ("setAttr ($PassNew + \"." + $each + "\") " + $passGetAttr + ";\n");
                    }        
                }
            }
            fprint $fileId "\n";
        } 
        
        string $queryAllLay[] = `textScrollList -q -si layList`;
        for ($i = 0; $i<(size($queryAllLay)); ++$i){
            string $currentLayer = $queryAllLay[$i];
            string $layersPrint = "string $currentLayer = `createRenderLayer -name ";
            editRenderLayerGlobals -currentRenderLayer $currentLayer;
            fprint $fileId ($layersPrint + $currentLayer + "`;\n");      
            string $queryObjLay[] = `editRenderLayerMembers -q -fn -nr $currentLayer`; 
            fprint $fileId "editRenderLayerGlobals -currentRenderLayer $currentLayer;\n\n";         
            for ($each in $queryObjLay) {
                string $ObjsExistsPrint = ("if ( `objExists " + $each + "` ) {\n    ");         
                string $ObjsPrint = "editRenderLayerMembers ";         
                fprint $fileId $ObjsExistsPrint;           
                fprint $fileId ($ObjsPrint + "$currentLayer " + $each + ";\n}\n\n");
            }
    
            string $queryOverrideLayer[] = `editRenderLayerAdjustment -q -layer $currentLayer`;
            for ($each in $queryOverrideLayer){
                select $each;
                string $SName[] = `ls -o $each`;
                string $nodeType = `nodeType $SName[0]`;                
                string $openObjs[] = `ls -sl -l`;                
                if (size($openObjs) > 1){
                    for ($obj in $openObjs){
                        string $attrType = `getAttr -type $obj`;
                        select -r $obj;                    
                        string $objShort[] = `ls -sl -o -l`;
                        if ($attrType == "TdataCompound"){
                            string $conAttr[] = `listConnections -d 1 -t "shadingEngine" -p 1 $obj`;
                            string $conAttrSG[] = `listConnections -d 1 -t "shadingEngine" $obj`;                        
                            if ($conAttrSG[0] == ""){
                            } else {                            
                                fprint $fileId ("if ( `objExists " + $conAttrSG[0] + "` && `objExists " + $obj + "` ) {\n");                     
                                fprint $fileId ("    select -r " + $objShort[0] + ";\n");                    
                                fprint $fileId ("    hyperShade -assign " + $conAttrSG[0] + ";\n}\n");  
                            }
                        }                    
                        string $SName[] = `ls -o $obj`;
                        string $attrType = `getAttr -type $obj`;
                        if ( $attrType == "float" || $attrType == "bool" || $attrType == "short" || $attrType == "enum" || $attrType == "time" || $attrType == "long"){
                            string $conAttribute[] = `listConnections -d 0 -p 1 $obj`;
                            string $conAttributeShort[] = `listConnections -d 0 -p 0 $obj`;
                            if ($conAttribute[0] == ""){               
                                editRenderLayerGlobals -currentRenderLayer $currentLayer;
                                string $getAttrOverride = `getAttr $obj`;
                                fprint $fileId  ("if ( `objExists " + $SName[0] + "` ) {\n");
                                fprint $fileId  ("    string $conAttribute[] = `listConnections -d 0 -p 1 " + $obj + "`;\n");
                                fprint $fileId  ("    editRenderLayerAdjustment " + $obj + ";\n");             
                                fprint $fileId  ("    if ($conAttribute[0] == \"\"){\n");            
                                fprint $fileId  ("        setAttr " + $obj + " " + $getAttrOverride + ";\n");
                                fprint $fileId  ("    } else if (size($conAttribute) >= 1){\n");
                                fprint $fileId  ("        disconnectAttr $conAttribute[0] " + $obj + ";\n");
                                fprint $fileId  ("        setAttr " + $obj + " " + $getAttrOverride + ";\n");            
                                fprint $fileId  ("    }\n");
                                fprint $fileId  ("}\n");
                            } else {
                                fprint $fileId  ("if ( `objExists " + $SName[0] + "` && `objExists " + $conAttributeShort[0] + "` ) {\n");                                
                                fprint $fileId  ("    editRenderLayerAdjustment " + $obj + ";\n");                           
                                fprint $fileId  ("    connectAttr -force " + $conAttribute[0] + " " + $obj + ";\n");
                                fprint $fileId  ("}\n");
                            }
                        }
                        string $SName[] = `ls -o $obj`;
                        string $attrType = `getAttr -type $obj`;
                        if ($attrType == "typed"){
                            string $conAttribute[] = `listConnections -d 0 -p 1 $obj`;
                            string $conAttributeShort[] = `listConnections -d 0 -p 0 $obj`;
                            if ($conAttribute[0] == ""){               
                                editRenderLayerGlobals -currentRenderLayer $currentLayer;
                                string $getAttrOverride = `getAttr $obj`;
                                fprint $fileId  ("if ( `objExists " + $SName[0] + "` ) {\n");
                                fprint $fileId  ("    string $conAttribute[] = `listConnections -d 0 -p 1 " + $obj + "`;\n");
                                fprint $fileId  ("    editRenderLayerAdjustment " + $obj + ";\n");             
                                fprint $fileId  ("    if ($conAttribute[0] == \"\"){\n");            
                                fprint $fileId  ("        setAttr -type \"string\" " + $obj + " \"" + $getAttrOverride + "\";\n");
                                fprint $fileId  ("    } else if (size($conAttribute) >= 1){\n");
                                fprint $fileId  ("        disconnectAttr $conAttribute[0] " + $obj + ";\n");
                                fprint $fileId  ("        setAttr -type \"string\" " + $obj + " \"" + $getAttrOverride + "\";\n");            
                                fprint $fileId  ("    }\n");
                                fprint $fileId  ("}\n");
                            } else {
                                fprint $fileId  ("if ( `objExists " + $SName[0] + "` && `objExists " + $conAttributeShort[0] + "` ) {\n");                                
                                fprint $fileId  ("    editRenderLayerAdjustment " + $obj + ";\n");                           
                                fprint $fileId  ("    connectAttr -force " + $conAttribute[0] + " " + $obj + ";\n");
                                fprint $fileId  ("}\n");
                            }
                        }
                        string $SName[] = `ls -o $obj`;
                        string $attrType = `getAttr -type $obj`;
                        if ( $attrType == "float3"){
                            string $conAttribute[] = `listConnections -d 0 -p 1 $obj`;
                            string $conAttributeShort[] = `listConnections -d 0 -p 0 $obj`;
                            if ($conAttribute[0] == ""){               
                                editRenderLayerGlobals -currentRenderLayer $currentLayer;
                                vector $color = `getAttr $each`;
                                string $getAttrOverride = $color;
                                fprint $fileId ("if ( `objExists " + $SName[0] + "` ) {\n");
                                fprint $fileId ("    string $conAttribute[] = `listConnections -d 0 -p 1 " + $obj + "`;\n");
                                fprint $fileId ("    editRenderLayerAdjustment " + $obj + ";\n");             
                                fprint $fileId ("    if ($conAttribute[0] == \"\"){\n");            
                                fprint $fileId ("        setAttr " + $obj + " " + $getAttrOverride + ";\n");
                                fprint $fileId ("    } else if (size($conAttribute) >= 1){\n");
                                fprint $fileId ("        disconnectAttr $conAttribute[0] " + $obj + ";\n");
                                fprint $fileId ("        setAttr " + $obj + " " + $getAttrOverride + ";\n");            
                                fprint $fileId ("    }\n");
                                fprint $fileId ("}\n");
                            } else {
                                fprint $fileId ("if ( `objExists " + $SName[0] + "` && `objExists " + $conAttributeShort[0] + "` ) {\n");                                
                                fprint $fileId ("    editRenderLayerAdjustment " + $obj + ";\n");                           
                                fprint $fileId ("    connectAttr -force " + $conAttribute[0] + " " + $obj + ";\n");
                                fprint $fileId ("}\n");
                            }
                        }
                        string $SName[] = `ls -o $obj`;
                        string $attrType = `getAttr -type $obj`;
                        if ( $attrType == "string"){
                            string $conAttribute[] = `listConnections -d 0 -p 1 $obj`;
                            string $conAttributeShort[] = `listConnections -d 0 -p 0 $obj`;
                            if ($conAttribute[0] == ""){               
                                editRenderLayerGlobals -currentRenderLayer $currentLayer;
                                string $getAttrOverride = `getAttr $obj`;
                                fprint $fileId  ("if ( `objExists " + $SName[0] + "` ) {\n");
                                fprint $fileId  ("    string $conAttribute[] = `listConnections -d 0 -p 1 " + $obj + "`;\n");
                                fprint $fileId  ("    editRenderLayerAdjustment " + $obj + ";\n");             
                                fprint $fileId  ("    if ($conAttribute[0] == \"\"){\n");            
                                fprint $fileId  ("        setAttr -type \"string\" " + $obj + " \"" + $getAttrOverride + "\";\n");
                                fprint $fileId  ("    } else if (size($conAttribute) >= 1){\n");
                                fprint $fileId  ("        disconnectAttr $conAttribute[0] " + $obj + ";\n");
                                fprint $fileId  ("        setAttr -type \"string\" " + $obj + " \"" + $getAttrOverride + "\";\n");            
                                fprint $fileId  ("    }\n");
                                fprint $fileId  ("}\n");
                            } else {
                                fprint $fileId  ("if ( `objExists " + $SName[0] + "` && `objExists " + $conAttributeShort[0] + "` ) {\n");                                
                                fprint $fileId  ("    editRenderLayerAdjustment " + $obj + ";\n");                           
                                fprint $fileId  ("    connectAttr -force " + $conAttribute[0] + " " + $obj + ";\n");
                                fprint $fileId  ("}\n");
                            }
                        }
                    }
                } else {
                    string $nodeType = `nodeType $each`;
                    string $attrType = `getAttr -type $each`;
                    select -r $each;                    
                    string $eachShort[] = `ls -sl -o -l`;                
                    if ($attrType == "TdataCompound"){
                        string $conAttr[] = `listConnections -d 1 -t "shadingEngine" -p 1 $each`;
                        string $conAttrSG[] = `listConnections -d 1 -t "shadingEngine" $each`;
                        if ($conAttrSG[0] == ""){
                        } else {                        
                            fprint $fileId ("if ( `objExists " + $conAttrSG[0] + "` && `objExists " + $each + "` ) {\n");                     
                            fprint $fileId ("    select -r " + $eachShort[0] + ";\n");                    
                            fprint $fileId ("    hyperShade -assign " + $conAttrSG[0] + ";\n}\n");
                        }   
                    }
                    string $SName[] = `ls -o $each`;
                    string $attrType = `getAttr -type $each`;
                    if ( $attrType == "float" || $attrType == "bool" || $attrType == "short" || $attrType == "enum" || $attrType == "time" || $attrType == "long"){
                        string $conAttribute[] = `listConnections -d 0 -p 1 $each`;
                        string $conAttributeShort[] = `listConnections -d 0 -p 0 $each`;
                        if ($conAttribute[0] == ""){               
                            editRenderLayerGlobals -currentRenderLayer $currentLayer;
                            string $getAttrOverride = `getAttr $each`;
                            fprint $fileId  ("if ( `objExists " + $SName[0] + "` ) {\n");
                            fprint $fileId  ("    string $conAttribute[] = `listConnections -d 0 -p 1 " + $each + "`;\n");
                            fprint $fileId  ("    editRenderLayerAdjustment " + $each + ";\n");             
                            fprint $fileId  ("    if ($conAttribute[0] == \"\"){\n");            
                            fprint $fileId  ("        setAttr " + $each + " " + $getAttrOverride + ";\n");
                            fprint $fileId  ("    } else if (size($conAttribute) >= 1){\n");
                            fprint $fileId  ("        disconnectAttr $conAttribute[0] " + $each + ";\n");
                            fprint $fileId  ("        setAttr " + $each + " " + $getAttrOverride + ";\n");            
                            fprint $fileId  ("    }\n");
                            fprint $fileId  ("}\n");
                        } else {
                            fprint $fileId  ("if ( `objExists " + $SName[0] + "` && `objExists " + $conAttributeShort[0] + "` ) {\n");                                
                            fprint $fileId  ("    editRenderLayerAdjustment " + $each + ";\n");                           
                            fprint $fileId  ("    connectAttr -force " + $conAttribute[0] + " " + $each + ";\n");
                            fprint $fileId  ("}\n");
                        }
                    }
                    string $SName[] = `ls -o $each`;
                    string $attrType = `getAttr -type $each`;
                    if ($attrType == "typed"){
                        string $conAttribute[] = `listConnections -d 0 -p 1 $each`;
                        string $conAttributeShort[] = `listConnections -d 0 -p 0 $each`;
                        if ($conAttribute[0] == ""){               
                            editRenderLayerGlobals -currentRenderLayer $currentLayer;
                            string $getAttrOverride = `getAttr $each`;
                            fprint $fileId  ("if ( `objExists " + $SName[0] + "` ) {\n");
                            fprint $fileId  ("    string $conAttribute[] = `listConnections -d 0 -p 1 " + $each + "`;\n");
                            fprint $fileId  ("    editRenderLayerAdjustment " + $each + ";\n");             
                            fprint $fileId  ("    if ($conAttribute[0] == \"\"){\n");            
                            fprint $fileId  ("        setAttr -type \"string\" " + $each + " \"" + $getAttrOverride + "\";\n");
                            fprint $fileId  ("    } else if (size($conAttribute) >= 1){\n");
                            fprint $fileId  ("        disconnectAttr $conAttribute[0] " + $each + ";\n");
                            fprint $fileId  ("    }\n");
                            fprint $fileId  ("}\n");
                        } else {
                            fprint $fileId  ("if ( `objExists " + $SName[0] + "` && `objExists " + $conAttributeShort[0] + "` ) {\n");                                
                            fprint $fileId  ("    editRenderLayerAdjustment " + $each + ";\n");                           
                            fprint $fileId  ("    connectAttr -force " + $conAttribute[0] + " " + $each + ";\n");
                            fprint $fileId  ("}\n");
                        }
                    }
                    string $SName[] = `ls -o $each`;
                    string $attrType = `getAttr -type $each`;
                    if ( $attrType == "float3"){
                        string $conAttribute[] = `listConnections -d 0 -p 1 $each`;
                        string $conAttributeShort[] = `listConnections -d 0 -p 0 $each`;
                        if ($conAttribute[0] == ""){               
                            editRenderLayerGlobals -currentRenderLayer $currentLayer;
                            vector $color = `getAttr $each`;
                            string $getAttrOverride = $color;
                            fprint $fileId ("if ( `objExists " + $SName[0] + "` ) {\n");
                            fprint $fileId ("    string $conAttribute[] = `listConnections -d 0 -p 1 " + $each + "`;\n");
                            fprint $fileId ("    editRenderLayerAdjustment " + $each + ";\n");             
                            fprint $fileId ("    if ($conAttribute[0] == \"\"){\n");            
                            fprint $fileId ("        setAttr " + $each + " " + $getAttrOverride + ";\n");
                            fprint $fileId ("    } else if (size($conAttribute) >= 1){\n");
                            fprint $fileId ("        disconnectAttr $conAttribute[0] " + $each + ";\n");
                            fprint $fileId ("        setAttr " + $each + " " + $getAttrOverride + ";\n");                                      
                            fprint $fileId ("    }\n");
                            fprint $fileId ("}\n");
                        } else {
                            fprint $fileId ("if ( `objExists " + $SName[0] + "` && `objExists " + $conAttributeShort[0] + "` ) {\n");                                
                            fprint $fileId ("    editRenderLayerAdjustment " + $each + ";\n");                           
                            fprint $fileId ("    connectAttr -force " + $conAttribute[0] + " " + $each + ";\n");
                            fprint $fileId ("}\n");
                        }
                    }
                    string $SName[] = `ls -o $each`;
                    string $attrType = `getAttr -type $each`;
                    if ( $attrType == "string"){
                        string $conAttribute[] = `listConnections -d 0 -p 1 $each`;
                        string $conAttributeShort[] = `listConnections -d 0 -p 0 $each`;
                        if ($conAttribute[0] == ""){               
                            editRenderLayerGlobals -currentRenderLayer $currentLayer;
                            string $getAttrOverride = `getAttr $each`;
                            fprint $fileId  ("if ( `objExists " + $SName[0] + "` ) {\n");
                            fprint $fileId  ("    string $conAttribute[] = `listConnections -d 0 -p 1 " + $each + "`;\n");
                            fprint $fileId  ("    editRenderLayerAdjustment " + $each + ";\n");             
                            fprint $fileId  ("    if ($conAttribute[0] == \"\"){\n");            
                            fprint $fileId  ("        setAttr -type \"string\" " + $each + " \"" + $getAttrOverride + "\";\n");
                            fprint $fileId  ("    } else if (size($conAttribute) >= 1){\n");
                            fprint $fileId  ("        disconnectAttr $conAttribute[0] " + $each + ";\n");
                            fprint $fileId  ("        setAttr -type \"string\" " + $each + " \"" + $getAttrOverride + "\";\n");            
                            fprint $fileId  ("    }\n");
                            fprint $fileId  ("}\n");
                        } else {
                            fprint $fileId  ("if ( `objExists " + $SName[0] + "` && `objExists " + $conAttributeShort[0] + "` ) {\n");                                
                            fprint $fileId  ("    editRenderLayerAdjustment " + $each + ";\n");                           
                            fprint $fileId  ("    connectAttr -force " + $conAttribute[0] + " " + $each + ";\n");
                            fprint $fileId  ("}\n");
                        }
                    }
                    string $SName[] = `ls -o $each`;
                    string $attrType = `getAttr -type $each`;
                    if ( $attrType == ""){
                        string $conAttribute[] = `listConnections -d 0 -p 1 $each`;
                        string $conAttributeShort[] = `listConnections -d 0 -p 0 $each`;
                        if ($conAttribute[0] == ""){               
                            editRenderLayerGlobals -currentRenderLayer $currentLayer;
                            string $getAttrOverride = `getAttr $each`;
                            fprint $fileId  ("if ( `objExists " + $SName[0] + "` ) {\n");
                            fprint $fileId  ("    string $conAttribute[] = `listConnections -d 0 -p 1 " + $each + "`;\n");
                            fprint $fileId  ("    editRenderLayerAdjustment " + $each + ";\n");             
                            fprint $fileId  ("    if ($conAttribute[0] == \"\"){\n");            
                            fprint $fileId  ("        setAttr " + $each + " " + $getAttrOverride + ";\n");
                            fprint $fileId  ("    } else if (size($conAttribute) >= 1){\n");
                            fprint $fileId  ("        disconnectAttr $conAttribute[0] " + $each + ";\n");
                            fprint $fileId  ("        setAttr " + $each + " " + $getAttrOverride + ";\n");            
                            fprint $fileId  ("    }\n");
                            fprint $fileId  ("}\n");
                        } else {
                            fprint $fileId  ("if ( `objExists " + $SName[0] + "` && `objExists " + $conAttributeShort[0] + "` ) {\n");                                
                            fprint $fileId  ("    editRenderLayerAdjustment " + $each + ";\n");                           
                            fprint $fileId  ("    connectAttr -force " + $conAttribute[0] + " " + $each + ";\n");
                            fprint $fileId  ("}\n");
                        }
                    }
                }
            }
    
            string $queryAssociatePass[] = `listConnections ($currentLayer + ".renderPass")`;
            int $AssociatePassSize = `size($queryAssociatePass)`;     
            if ($AssociatePassSize == 0){
            } else {
                int $num = 1; 
                fprint $fileId ("string $PassCon[] = {");      
                for ($each in $queryAssociatePass){
                    if ($AssociatePassSize == $num){    
                        fprint $fileId ("\"" + $each + "_new\"");   
                    } else {
                        fprint $fileId ("\"" + $each + "_new\",");
                    }
                    $num += 1;
                }
                fprint $fileId "};\n";
                fprint $fileId "for ($each in $PassCon){\n";
                for ($each in $queryAssociatePass){        
                    fprint $fileId ("        if (`gmatch $each \"" + $each + "_new\"`){\n");     
                    fprint $fileId ("            if (`attributeExists \"new\" $each`){\n");
                    fprint $fileId ("                connectAttr -nextAvailable ($currentLayer + \".renderPass\") ( $each  + \".owner\");\n");
                    fprint $fileId ("            }\n");
                    fprint $fileId ("    }\n");
                }
                fprint $fileId "}\n";          
            }           
        
            string $currentLayer = $queryAllLay[$i];   
            string $contMap[] = `ls -type "passContributionMap"`;
            string $AssociateContMap[] = `listConnections ($currentLayer + ".passContributionMap")`;    
            if (size($AssociateContMap) == 0){
                    
            } else {     
                for ($each in $AssociateContMap) {
                    fprint $fileId ("string $newContrMap = `createNode -n " + $each + "_new" + " passContributionMap`;\n");               
                    fprint $fileId ("connectAttr -na ($currentLayer + \".passContributionMap\") ($newContrMap + \".owner\");\n\n");    
                    string $contMapObj = $each;           
                    string $AssociatePassContMap[] = `listConnections  ($each + ".renderPass")`;
                    int $AssociatePassContMapSize = `size($AssociatePassContMap)`;     
                    if ($AssociatePassContMapSize == 0){
                    } else {
                        int $num = 1; 
                        fprint $fileId ("string $PassToContr[] = {");      
                        for ($each in $AssociatePassContMap){
                            if ($AssociatePassContMapSize == $num){    
                                fprint $fileId ("\"" + $each + "_new\"");   
                            } else {
                                fprint $fileId ("\"" + $each + "_new\",");
                            }
                            $num += 1;
                        }
                        fprint $fileId "};\n";
                        fprint $fileId "for ($each in $PassToContr){\n";
                        fprint $fileId "    if ( `objExists $each` ) {\n";                       
                        fprint $fileId "        connectAttr -nextAvailable ($each + \".message\") ($newContrMap + \".renderPass\");\n";
                        fprint $fileId "    }\n\n";                      
                        fprint $fileId "}\n\n";  
                    }
                    string $ContMapObj[] = `listConnections ($contMapObj + ".dagObjects")`;     
                    select $ContMapObj;
                    string $ContMapObj[] = `ls -sl -l`;
                    for ($obj in $ContMapObj){
                        fprint $fileId ("if ( `objExists "+ $obj +" ` ) {\n");                     
                        fprint $fileId ("    connectAttr -na " + $obj + ".message ($newContrMap + \".dagObjects\");\n");
                        fprint $fileId "}\n\n";
                    }
                fprint $fileId "\n";
                }
            }
            fprint $fileId "\n";
            fprint $fileId ("print \"" + $currentLayer + " imported.\";\n"); 
            fprint $fileId "\/\/-----------------------------------------------------------------------------------------------------\n\n\n";
            print ($currentLayer + " exported.\n");    
        }
        
        fprint $fileId "string $ConMapCorrectName[] = `ls -type \"passContributionMap\"`;\n";
        fprint $fileId "for ($each in $ConMapCorrectName){\n";
        fprint $fileId "    if (`gmatch $each \"*_new\"`){\n";
        fprint $fileId "        string $conMapRename = substituteAllString($each,\"_new\", \"\");\n";
        fprint $fileId "        rename $each $conMapRename;\n";
        fprint $fileId "    }\n";
        fprint $fileId "}\n";
        
        fprint $fileId "string $PassCorrectName[] = `ls -type \"renderPass\"`;\n";
        fprint $fileId "for ($each in $PassCorrectName){\n";
        fprint $fileId "    if (`gmatch $each \"*_new\"`){\n";
        fprint $fileId "        deleteAttr -at new $each;\n";
        fprint $fileId "        string $passRename = substituteAllString($each,\"_new\", \"\");\n";
        fprint $fileId "        rename $each $passRename;\n";
        fprint $fileId "    }\n";
        fprint $fileId "}\n";
        fprint $fileId "editRenderLayerGlobals -currentRenderLayer defaultRenderLayer;\n";
        
        
        fprint $fileId "print \"Import Complete.\";";
        fclose $fileId ;
        editRenderLayerGlobals -currentRenderLayer defaultRenderLayer;
        print $saveFileName[0];
        print "\n";
        print "Export Done!!!";
    }
	}
global proc SourceScript(string $script) {//source script 
    string $command = "source \""+$script+"\"";  
    eval $command ;
	}
global proc importRenderLayer(){		   // import Render Layer procedure
    string $DirName = `workspace -q -fullName`;
    string $openFileName[] = `fileDialog2  -caption "Import Render Layers." -fileMode 1 -startingDirectory $DirName -fileFilter "*.mel"`;
    SourceScript $openFileName[0];
    updateRLayer();
    enableBtn();

	}
////__INIIT___
//plugMR;
//renderMR;
